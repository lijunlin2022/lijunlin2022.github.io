import{_ as s,c as i,ae as l,o as e}from"./chunks/framework.BzDBnRMZ.js";const k=JSON.parse('{"title":"H5 离线包放入 HTML 后降级方案如何设计？","description":"","frontmatter":{"tags":["H5"]},"headers":[],"relativePath":"blog/2024/01/27/index.md","filePath":"blog/2024/01/27/index.md"}'),n={name:"blog/2024/01/27/index.md"};function t(p,a,h,o,d,r){return e(),i("div",null,a[0]||(a[0]=[l(`<h1 id="h5-离线包放入-html-后降级方案如何设计" tabindex="-1">H5 离线包放入 HTML 后降级方案如何设计？ <a class="header-anchor" href="#h5-离线包放入-html-后降级方案如何设计" aria-label="Permalink to &quot;H5 离线包放入 HTML 后降级方案如何设计？&quot;">​</a></h1><p>离线包是移动端 H5 常见的性能优化方案。开发者们或多或少都接触过离线包。francecil 大佬还总结了离线包是否要放入 HTML 的两种决策，以及决策的优缺点： [^1]：</p><ul><li>放入 HTML（缓存优先）：更好的性能，但更新不及时。</li><li>不放入 HTML（网络优先）：实时更新，但性能较差，可能会加载失败。</li></ul><p>我选择把 HTML 放入离线包，这意味着 H5 出现线上故障时，没有办法及时修复。因此，我必须额外设计一套降级方案，保证离线包发生故障时能够快速降级。</p><p>如果你也为离线包的降级而烦恼，看了这篇文章，你一定有所收获。我会从离线包的机制说起，解释离线包放入 HTML 后为什么更新不及时，然后我会介绍自己设计的降级方案，最后我会对这个方案做一个总结。</p><h2 id="离线包的生效机制" tabindex="-1">离线包的生效机制 <a class="header-anchor" href="#离线包的生效机制" aria-label="Permalink to &quot;离线包的生效机制&quot;">​</a></h2><p>为什么离线包放入 HTML 后更新不及时？为了回答这个问题，我们必须先知道它是如何生效的。</p><p>离线包首先会把 HTML、CSS 和 JS 等资源文件打包成一个压缩包，并预先下载到 App 本地，解压到缓存中。当用户访问 H5 时，Webview 开始加载资源的 URL 并发出资源请求，App 会拦截这些请求。</p><ul><li>如果缓存中有满足请求的资源，App 会使用缓存资源；</li><li>如果缓存中没有满足请求的资源，App 会使用线上资源。</li></ul><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A(加载离线包) --&gt; B[解压到缓存]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  B --&gt; C[Webview 加载 URL]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C --&gt; D{{从缓存读取}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D --&gt; |有|E[返回缓存数据]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D --&gt; |无|F[请求线上地址]</span></span></code></pre></div><p>什么时候叫缓存资源满足请求呢？就是缓存文件名字和请求文件名字一致。</p><ul><li>如果我们在离线包里放入 HTML，由于 HTML 文件不会轻易改变，即使线上资源有更新，App 也会优先使用缓存资源；</li><li>如果我们不放入 HTML，由于 CSS 和 JS 文件名的哈希会改变，所以线上资源有更新时，App 内 HTML、CSS 和 JS 都会使用线上资源。</li></ul><h2 id="我设计的降级方案" tabindex="-1">我设计的降级方案 <a class="header-anchor" href="#我设计的降级方案" aria-label="Permalink to &quot;我设计的降级方案&quot;">​</a></h2><p>上一节我们已经知道，HTML 文件名没有变化，离线包就不会失效。我们可以利用跳转间接改变文件名。</p><h3 id="利用跳转降级离线包" tabindex="-1">利用跳转降级离线包 <a class="header-anchor" href="#利用跳转降级离线包" aria-label="Permalink to &quot;利用跳转降级离线包&quot;">​</a></h3><p>首先，我们需要准备两个内容一样的 HTML，一个是 index.html，另一个是 index-online.html。</p><ul><li>index.html 会放入离线包；</li><li>index-online.html 不会放入离线包。</li></ul><p>然后，我们会设计一个开关，控制 index.html 是否要跳转。</p><ul><li>开关开启时，index.html 会跳转到 index-online.html；</li><li>开关关闭时，index.html 保持原始逻辑。</li></ul><p>这样发生线上故障时，我们可以回滚线上的 H5 页面，此时 index-online.html 恢复正常，而缓存在用户 App 本地的 index.html 还有问题。</p><p>我们开启开关后，离线的 index.html 直接跳转到已经恢复正常的 index-online.html，就实现了离线包的降级。</p><h3 id="利用版本大小设计开关" tabindex="-1">利用版本大小设计开关 <a class="header-anchor" href="#利用版本大小设计开关" aria-label="Permalink to &quot;利用版本大小设计开关&quot;">​</a></h3><p>上一小节，我们提到降级方案需要一个开关，设计这个开关，我们需要考虑两个问题：</p><ul><li>离线包有 n 个版本，有时多个版本均存在问题。比如 1.0.0 离线包没有问题，1.0.1 和 1.0.2 都有问题，我们需要保证开关能够降级多个版本。</li></ul><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A[1.0.0 正确] --&gt; B[1.0.1 错误] --&gt; C[1.0.2 错误]</span></span></code></pre></div><ul><li>我们会发布修复的离线包，比如我们会在 1.0.3 修复问题。开关打开后，不能把修复版本降级。</li></ul><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A[1.0.0 正确] --&gt; B[1.0.1 错误] --&gt; C[1.0.2 错误] --&gt; D[1.0.3 正确]</span></span></code></pre></div><p>怎么设计呢？我这里采取最简单粗暴的思路，把离线包本身的版本 H5_VERSION 和要降级的版本 rollbackVersion 做一个比较。</p><ul><li><code>H5_VERSION &lt;= rollbackVersion</code>，相当于打开降级开关。</li><li><code>H5_VERSION &gt; rollbackVersion</code>，相当于关闭降级开关。</li></ul><p>继续使用之前的例子，1.0.2 是出现问题的最高版本，我们可以把 rollbackVersion 设置为 1.0.2，<code>&lt;= 1.0.2</code> 全部降级。这样虽然会误伤 1.0.0 版本，但能既满足降级多个有问题的版本，又满足不降级修复版本。</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph 降级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A[1.0.0 正确] --&gt; B[1.0.1 错误] --&gt; C[1.0.2 错误]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">C --&gt; D[1.0.3 正确]</span></span></code></pre></div><p>发生下一次故障时，我们再更新 rollbackVersion，比如 1.0.4 发生了故障，我们把 rollbackVersion 设置为 1.0.4，<code>&lt;= 1.0.4</code> 全部降级。</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart LR</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">subgraph 降级</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">A[1.0.0 正确] --&gt; B[1.0.1 错误] --&gt; C[1.0.2 错误] --&gt; D[1.0.3 正确] --&gt; E[1.0.4 错误]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">end</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">E --&gt; F[1.0.5 正确]</span></span></code></pre></div><h3 id="利用-localstorage-延迟开关生效时间" tabindex="-1">利用 localStorage 延迟开关生效时间 <a class="header-anchor" href="#利用-localstorage-延迟开关生效时间" aria-label="Permalink to &quot;利用 localStorage 延迟开关生效时间&quot;">​</a></h3><p>上一节我们介绍了如何设计开关。需要注意的是，我们不能一发现开关打开、就立即跳转，这会中断用户正常的操作。（比如用户正在浏览页面，突然页面跳转）</p><p>我们等开关打开后，在 localStorage 中存储一下代表打开的标识，等到用户下次进入页面时，发现有打开标识再跳转到 index-online.html。</p><h3 id="流程图" tabindex="-1">流程图 <a class="header-anchor" href="#流程图" aria-label="Permalink to &quot;流程图&quot;">​</a></h3><p>考虑完上面三个问题后，我们就可以设计一个比较完善的降级方案了，它的流程图如下：</p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flowchart TD</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  A(开始) --&gt; B[获取 localStorage 中的 needRollback]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  B --&gt; C{{needRollback 等于 1}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C --&gt; |No| D[获取 H5 版本号 H5_VERSION, 获取降级离线包的配置 rollbackVersion]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  C --&gt; |Yes| E[跳转 index-online.html]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  E --&gt; I(结束)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  D --&gt; F{{H5_VERSION 小于等于 rollbackVersion}}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  F --&gt; |Yes| G[在 localStorage 中设置 needRollback]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  F --&gt; |No| H[删除 localStorage 中的 needRollback]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  G --&gt; I</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  H --&gt; I</span></span></code></pre></div><ol><li>用户一进入页面，会先获取 localStorage 中的 needRollback 开关标识。</li><li>如果 needRollback 标识打开，则跳转 index-online.html 实现降级。（注：<strong>index-online.html 中不能继续判断 needRollback，否则会无限跳转</strong>）</li><li>如果 needRollback 标识没有打开，则继续获取 H5 本身的版本号，以及接口下发的 rollbackVersion。</li><li>如果 <code>H5_VERSION &lt;= rollbackVersion</code>，则在 localStorage 把 needRollback 设置为 1。</li><li>如果 <code>H5_VERSION &gt; rollbackVersion</code>，则删除 localStorage 中的 needRollback 标识。</li></ol><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>本文介绍了一种离线包放入 HTML 的降级方案，它主要有三个特点：</p><ol><li>利用从离线化的 index.html 跳转到线上的 index-online.html 实现降级。</li><li>利用离线包版本 <code>H5_VERSION &lt;= rollbackVersion</code> 做开关，判断是否需要降级。</li><li>利用 localStorage 中设置 needRollback 标识，延迟开关作用时间。</li></ol><p>这种方案是离线包放入 HTML 后，一种成本较低的降级方案。它会在降级时误伤低版本的离线包，以损耗性能为代价，保障质量。</p><p>[^1]: <a href="https://juejin.cn/post/7254549436625256506" target="_blank" rel="noreferrer">HTML 放入离线包？你需要了解的离线策略</a></p>`,45)]))}const E=s(n,[["render",t]]);export{k as __pageData,E as default};
