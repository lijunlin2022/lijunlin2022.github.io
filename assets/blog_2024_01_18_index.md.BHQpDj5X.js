import{_ as i,c as a,ae as n,o as t}from"./chunks/framework.BzDBnRMZ.js";const e="/assets/loop-progress.DX0kTla-.gif",p="/assets/rem-mod.DIX57wHI.png",l="/assets/5rem2.BmXtvyhY.png",h="/assets/-5rem2.zAgslMsW.png",k="/assets/5rem-2.CXNgS9Os.png",r="/assets/-5rem-2.LTVB1YWB.png",d="/assets/verify-func-1.Dj2EDziZ.png",o="/assets/verify-func-2.Duuud0jD.png",C=JSON.parse('{"title":"取余和取模如何区分与应用？","description":"","frontmatter":{},"headers":[],"relativePath":"blog/2024/01/18/index.md","filePath":"blog/2024/01/18/index.md"}'),g={name:"blog/2024/01/18/index.md"};function c(E,s,y,F,u,m){return t(),a("div",null,s[0]||(s[0]=[n('<h1 id="取余和取模如何区分与应用" tabindex="-1">取余和取模如何区分与应用？ <a class="header-anchor" href="#取余和取模如何区分与应用" aria-label="Permalink to &quot;取余和取模如何区分与应用？&quot;">​</a></h1><p>取余（remainer）和取模（modulo），很多书籍没有说明它们的区别、也没有说明它们的应用场景。比如《JavaScript 高级程序设计（第 4 版）》直接说：</p><blockquote><p>取模（余数）操作符由一个百分比符号（%）表示。</p></blockquote><p>但实际上，两个概念并不完全一致。严格来说，JavaScript 中的 % 是取余，而不是取模。</p><p>有读者可能认为，没必要区分取余和取模。但我想说，区分取余和取模，能帮助你写出更优雅的代码。</p><p>以掘金的创作话题轮播为例，它带有灰色进度条，当你左滑或右滑时，话题对应的圆点会变长。</p><p><img src="'+e+`" alt=""></p><p>假如让你来实现灰色进度条，需要计算左滑后的下标（prevIndex）和右滑后的下标（nextIndex），你会怎么做呢？</p><ul><li>要是你完全不理解取余和取模，为了兼顾左滑、右滑的边界情况，你可能会这样写：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">                  0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><ul><li>要是你只理解取余，不理解取模，你可能会这样写：</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  (currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                  currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len</span></span></code></pre></div><ul><li>要是你既理解取余，又理解取模，你可以写出更优雅的代码：（mod 不是 JavaScript 原生函数，需要额外实现）</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> prevIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, len)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nextIndex</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(currentIndex </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, len)</span></span></code></pre></div><p>如果你想知道取余和取模的区别和应用、以及 mod 函数如何实现，看完这篇文章，你一定有所收获。</p><p>我会先给出取余和取模的计算方式，再用四个例子解释计算方式，接着我会谈一谈什么时候该取余，什么时候该取模，最后我会介绍 JavaScript 中 2 种实现 mod 函数的方法。</p><h2 id="计算方式" tabindex="-1">计算方式 <a class="header-anchor" href="#计算方式" aria-label="Permalink to &quot;计算方式&quot;">​</a></h2><p>余数和模的计算方式如下图：</p><p><img src="`+p+'" alt=""></p><p>其中 fix 代表向 0 取整，而 floor 代表向负无穷取整。你可能并不理解什么叫作「向 0 取整」，什么叫作「向负无穷取整」，先不要着急，在例子中我会详细讲解。</p><h2 id="例子" tabindex="-1">例子 <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子&quot;">​</a></h2><h3 id="_5-除以-2" tabindex="-1">5 除以 2 <a class="header-anchor" href="#_5-除以-2" aria-label="Permalink to &quot;5 除以 2&quot;">​</a></h3><p>把 x = 5，y = 2 代入公式后，你需要计算的是 <code>fix(2.5)</code> 和 <code>floor(2.5)</code>。</p><p><img src="'+l+'" alt=""></p><p>你可以画出一个右箭头，代表从负无穷指向正无穷的数轴。</p><p>找到 2.5 的位置，可以发现 0 和负无穷都在 2.5 的左边。对 2.5 来说，向 0 取整和向负无穷取整，都是往左边取。</p><p>所以 <code>fix(2.5) = 2</code>， <code>floor(2.5) = 2</code>，把它们代入公式，得到余数和模都是 1。</p><h3 id="_5-除以-2-1" tabindex="-1">-5 除以 2 <a class="header-anchor" href="#_5-除以-2-1" aria-label="Permalink to &quot;-5 除以 2&quot;">​</a></h3><p>再看 -5 除以 2，继续代入公式画数轴，你需要计算的是 <code>fix(-2.5)</code> 和 <code>floor(-2.5)</code>。</p><p><img src="'+h+'" alt=""></p><p>找到 -2.5 的位置，可以看到 0 在 -2.5 的右边，而负无穷在 -2.5 的左边。此时向 0 取整就是取 -2.5 右边的整数，向负无穷取整就是取 -2.5 左边的整数。</p><p>所以 <code>fix(-2.5) = -2</code>，<code>floor(-2.5) = -3</code>。把它们代入公式，得到余数为 -1，模为 1。</p><h3 id="_5-除以-2-2" tabindex="-1">5 除以 -2 <a class="header-anchor" href="#_5-除以-2-2" aria-label="Permalink to &quot;5 除以 -2&quot;">​</a></h3><p>继续看 5 除以 -2，你需要计算的是 <code>fix(-2.5)</code> 和 <code>floor(-2.5)</code>。</p><p><img src="'+k+'" alt=""></p><p>之前已经知道 <code>fix(-2.5) = -2</code>，<code>floor(-2.5) = -3</code>，把它们代入公式，得到余数为 1，模为 -1。</p><h3 id="_5-除以-2-3" tabindex="-1">-5 除以 -2 <a class="header-anchor" href="#_5-除以-2-3" aria-label="Permalink to &quot;-5 除以 -2&quot;">​</a></h3><p>最后看 -5 除以 -2，你需要计算的是 <code>fix(2.5)</code> 和 <code>floor(2.5)</code>。</p><p><img src="'+r+`" alt=""></p><p>之前已经知道 <code>fix(2.5) = 2</code>，<code>floor(2.5) = 2</code>，把它们代入公示后得到余数和模都是 -1。</p><h2 id="余数和模的区别" tabindex="-1">余数和模的区别 <a class="header-anchor" href="#余数和模的区别" aria-label="Permalink to &quot;余数和模的区别&quot;">​</a></h2><p>观察上面的 4 个例子，不难发现，取余和取模的结果，和 x 和 y 的正负号有关。</p><ul><li>当 x 和 y 同为正数、或者同为负数时，x rem y 和 x mod y 的结果一样。</li><li>当 x 和 y 符号不一致时，x rem y 和 x mod y 的结果不一样。rem 计算结果符号和 x 一样，mod 计算结果和 y 一样。</li></ul><p>实际应用中，y 一般都是正数，因此只需要考虑 x 符号的正负。</p><ul><li><p>当 x 为正数时，此时取余数和取模结果一致，因此最好使用 JavaScript 的 % 运算符。</p><p>例如你想访问数组中的某个元素，又担心下标超出数组的范围，你可以先求下标除以数组长度的余数，把余数作为新下标。</p></li><li><p>当 x 可能为正数也可能为负数时，此时可以实现一个 mod 函数。</p><p>例如我在文章开头举的例子，prevIndex 可能是一个负数，你可以直接求 prevIndex 除以轮播长度的模。</p></li></ul><h2 id="实现取模函数" tabindex="-1">实现取模函数 <a class="header-anchor" href="#实现取模函数" aria-label="Permalink to &quot;实现取模函数&quot;">​</a></h2><p>取模函数，我知道的有两种实现方法，一种是偏重工程，另一种偏重学术。两者有什么区别呢？</p><p>之前提到过，实际应用中，x mod y 时，y 一般是正数。</p><ul><li><strong>工程方法追求简单实用，只考虑 y 为正数的情况。</strong></li></ul><p>它的写法简单易懂，先求 x 除以 y 的余数，如果结果为负数，就给结果再加上一个 y，保证结果始终为正数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> res</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> res</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+d+`" alt=""></p><p>Ant Design Mobile Swiper [^1] 源码用的就是这种方法。</p><ul><li><strong>学术方法追求逻辑严密，既会考虑 y 为正数，也会考虑 y 为负数。</strong></li></ul><p>它的写法如下，我不清楚怎么证明，但代入数字计算，可以验证结果正确。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> mod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">y</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+o+'" alt=""></p><p>MDN [^2] 和 stackoverflow [^3] 推荐的就是这种方法。</p><p>[^1]: <a href="https://github.com/ant-design/ant-design-mobile/blob/master/src/components/swiper/swiper.tsx" target="_blank" rel="noreferrer">ant-design-mobile | github</a> [^2]: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Remainder" target="_blank" rel="noreferrer">remainder | mdn</a> [^3]: <a href="https://stackoverflow.com/questions/4467539/javascript-modulo-gives-a-negative-result-for-negative-numbers/17323608#17323608" target="_blank" rel="noreferrer">JavaScript % (modulo) gives a negative result for negative numbers | stackoverflow</a></p>',59)]))}const b=i(g,[["render",c]]);export{C as __pageData,b as default};
