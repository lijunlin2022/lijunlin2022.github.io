[{"id":0,"title":"H5、小程序 Tab 如何滚动居中？","content":"#\n\nTab 在 PC 端、移动端应用都上很常见，不过 Tab 在移动端 比 PC 端更复杂。为什么呢？移动端设备屏幕较窄，一般仅能展示 4 ~ 7 个\nItem。考虑到用户体验，UI 往往要求程序员实现一个功能——点击 Item 后，Item 滚动到屏幕中央，拼多多的 Tab 就实现了这个功能。\n\n\n\n如果你也想实现这个功能，看了这篇文章，你一定会有所收获。我会先说明 Tab 滚动的本质，分析出滚动距离的计算公式，接着给出伪代码，最后再给出 Vue、React\n和微信小程序的示例代码。\n\n\nTab 滚动的本质#\n\nTab 滚动，本质是包裹着 Item 的容器在滚动。\n\n如下图，竖着的虚线长方形代表手机屏幕，横着的长方形代表 Tab 的容器，标着数字的小正方形代表一个个 Tab Item。\n\n左半部分中，Tab 容器紧贴手机屏幕左侧。右半部分中，Item 4 位于屏幕中央，两部分表示 Item 4 从屏幕右边滚动到屏幕中央。\n\n\n\n不难看出，Item 4 滚动居中，其实就是容器向左移动 distance。此时容器滚动条到容器左边缘的距离也是 distance。\n\n换句话说，让容器向左移动 distance，Item 4 就能居中。 因此只要你能找出计算 distance 的公式，就能控制某个 Item 居中。\n\n\n计算 distance 的公式#\n\n该如何计算 distance 呢？你看下方这张更细致的示意图。\n\n屏幕中央有一条线，它把 Item 4 分成了左右等宽的两部分，也把手机屏幕分成了左右等宽的两部分。你可以把 Item 4 一半的宽度记为\nhalfItemWidth，把手机屏幕一半的宽度记为 halfScreenWidth。再把 Item 4 左侧到容器左侧的距离记为\nitemOffsetLeft。\n\n\n\n不难看出，这四个值满足如下等式：\n\n\n\n简单推导一下，就得到了计算 distance 的公式。\n\n\n\n\n公式的伪代码实现#\n\n现在开始解释公式的代码实现。\n\n先看下 itemOffsetLeft、halfItemWidth 和 halfScreenWidth 如何获取。\n\n * itemOffsetLeft 是 Item 元素到容器左侧的距离，你可以用 HTMLElement.offsetLeft 作它的值。\n\n * halfItemWidth 是 Item 元素一半的宽度。HTMLElement.offsetWidth 是元素的整体宽度，你可以用\n   offsetWidth / 2 作它的值，也可以先用 Element.getBoundingClientRect() 获取一个 itemRect\n   对象，再用 itemRect.width / 2 作它的值。\n\n * halfScreenWidth 是手机屏幕一半的宽度。 window.innerWidth 是手机屏幕的整体宽度，你可以用 innerWidth / 2\n   作它的值。\n\n再看下如何把 distance 设置到容器上。\n\n在 HTML 中，你可以使用 Element.scrollLeft 来读取和设置元素滚动条到元素左边的位置。因此，你只需要容器的 scrollLeft 赋值为\ndistance，就可以实现 Item 元素滚动居中。\n\n现在给出点击 tab 的函数的伪代码：\n\n\n\n\n代码示例#\n\n\nVue#\n\nTab 滚动居中 | Vue\n\n\nReact#\n\nTab 滚动居中 | React\n\n\n微信小程序#\n\nTab 滚动居中 | 微信小程序\n\n:::info 小程序的 API 和浏览器的 API 有差异。\n\n * itemOffsetLeft ，你需要从点击事件的 event.currentTarget 中获取。\n * halfItemWidth，你需要先用 wx.createSelectorQuery() 选取到 Item 后，从 exec() 的执行结果中获取到\n   Item 整体宽度，然后再除以 2。\n * halfScreenWidth，你需要先用 wx.getSystemInfoSync() 获取屏幕整体宽度，然后再除以 2。\n\n至于把 distance 设置到容器上，微信小程序 scroll-view 组件中，有 scroll-left 这个属性，你可以把 distance 赋值给\nscroll-left。","routePath":"/blog/2023/07/30/","lang":"","toc":[{"text":"Tab 滚动的本质","id":"tab-滚动的本质","depth":2,"charIndex":248},{"text":"计算 distance 的公式","id":"计算-distance-的公式","depth":2,"charIndex":565},{"text":"公式的伪代码实现","id":"公式的伪代码实现","depth":2,"charIndex":822},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":1407},{"text":"Vue","id":"vue","depth":3,"charIndex":1415},{"text":"React","id":"react","depth":3,"charIndex":1438},{"text":"微信小程序","id":"微信小程序","depth":3,"charIndex":1465}],"domain":"","frontmatter":{"tags":["H5","小程序"]},"version":""},{"id":1,"title":"H5 不复制元素的循环轮播图如何实现？——取模","content":"#\n\n循环轮播图，你肯定并不陌生，实现方案非常多。大多数实现方案需要复制元素，比如实现 5 个元素的轮播需要用 7 个元素。多出的 2\n个元素一个是头部元素，另一个是尾部元素。\n\n\n\n能不复制元素吗？可以的，Ant Design Mobile Swiper 1 就做到了。它不需要复制元素，只需要改变 translate3d，就能循环播放。\n\n\n\n如果你也想知道它是怎么做到的，看了这篇文章，你一定有所收获。我会先解释循环轮播的原理，再用 HTML + JavaScript 实现循环轮播，效果如下：\n\n\n\n\n轮播的原理#\n\n初始顺序\n\n我们先思考一个问题。5 个元素、轮播初始顺序应该怎么排？答案是 34012。\n\n\n\n首先，Item 0 必须放在放到视口中央（橘黄色），我们要保证用户往左滑、往右滑都能看到元素。\n\n其次，Item 0 前一个元素必须是 Item 4，后一个元素必须是 Item 1。因为我们要欺骗用户视觉，让用户觉得自己看到的是 01234 循环播放。\n\n同理，为了欺骗用户视觉，Item 4 的前一个元素必须是 Item 3，Item 1 的后一个元素必须是 Item 2。\n\n经过推理我们得到答案 34012。但推理过程太麻烦了，有没有办法可以简化思考呢？\n\n我们可以这样想，把 Item 按 01234 的顺序，从中央区域开始向右放置。放完 Item 0、Item 1 和 Item 2，Item 0 右边已经有 2\n个元素。接下来我们只需要把 Item 3 和 Item 4 平移到 Item 0 左边，就可以得到答案 34012。\n\n\n\n向右滑动\n\n接下来思考第二个问题。5 个元素的轮播向右播放一张后，应该怎么排？答案是 40123。\n\n\n\n我们可以延续之前的思路，把 Item 1 放在中央，再按 12340 的顺序向右放置。放完 Item 1、Item 2 和 Item 3 后，Item 1\n右边已经有 2 个元素，接下来我们只需要把 Item 4 和 Item 0 平移到 Item 1 左边，就得到了 40123。\n\n\n\n轮播循环\n\n沿着之前的思路，我们这样把 Item 2、Item 3 和 Item 4 轮流放在中央看看情况：\n\n * 2 放在中央，按 23401 的顺序，需要把 3、4 放到 2 右边，再把 0、1 平移到 2 左边；\n * 3 放在中央，按 34012 的顺序，需要把 4、0 放到 3 右边，再把 1、2 平移到 3 左边；\n * 4 放在中央，按 40123 的顺序，需要把 0、1 放到 4 右边，再把 2、3 平移到 4 左边。\n\n这样就得到循环轮播，示意图如下：\n\n\n\n\n计算轮播位置的代码#\n\n现在我们一起把上述思路转变为代码。先看 HTML 布局代码，我只保留布局关键部分，这样代码更精简。\n\n\n布局代码#\n\nHTML 初始布局代码如下（所有的 定位为相对定位）：\n\n\n\n它的效果示意图如下，正是我们在「轮播的原理」一节提到的「初始顺序」：\n\n\n\n这个布局是如何得到的呢？\n\n首先我们把每个元素的 translateX 设置为 0%、再把 Item 0 ~ Item 4 的 left 设置成 0% ~ -400%。\n\n\n\n效果图如下，所有 Item 都重叠在中央：\n\n\n\n接着，我们把 Item 0 ~ Item 4 的 translateX 设置成 0% ~ 400%。\n\n\n\n效果图如下，正是我们在「轮播的原理」一节提到的「把 Item 按 01234 的顺序，从中央区域开始向右放置」：\n\n\n\n下一步我们要把 Item 3 和 Item 4 平移到 Item 0 左边，也就是把 Item 3、Item 4 的 translateX 减去\n500%（轮播的整体长度）。\n\n\n\n效果图如下，这样就实现了 Item 3 和 Item 4 向左平移：\n\n\n\n到这里，如何得到 HTML 初始布局我们已经解答完毕。\n\n\n逻辑代码#\n\n接下来，我们看看 JavaScript 代码。HTML 代码，只是实现轮播图的初始顺序，而 JavaScript 代码，则是实现播放前一个元素、播放后一个元素。\n\n\n\n我们来逐句解读代码。可以看到，我们监听了 prevBtn 和 nextBtn 的点击事件。当 prevBtn 被点击时，currentIndex 被更新为\ncurrentIndex - 1，意思是播放前一个元素；当 nextBtn 被点击时，currentIndex 被更新为 currentIndex +\n1，意思是播放后一个元素。\n\n接下来，mod(activeIndex, len) 是求 activeIndex 除以 len 的模，作用是把 currentIndex 取值限定在 0 ~\n4，如果 activeIndex 等于 5，currentIndex 就变为 0。如果 activeIndex 等于 -1，currentIndex 就变为\n4。如果你不理解取模函数，可以先看我的另一篇文章 取余和取模如何区分和应用。\n\n然后，forEach 给每一个元素设置了 translateX，作用是——把元素往中央元素的右边放置，发现中央 Item 右侧有 2 个元素后，再把剩余元素放到\nItem 左边。我们以 01234 变为 34012 为例：\n\n把 Item 0 ~ Item 4 的下标代入代码中计算 position，不难发现，currentIndex 为 0 时：\n\n * Item 0 的 position 为 0\n * Item 1 的 position 为 100%\n * Item 2 的 position 为 200%\n * Item 3 的 position 为 300%\n * Item 4 的 position 为 400%\n\n如果直接以 position 为 translateX，效果如下，和之前提到的「把 Item 按 01234 的顺序，从中央区域开始向右放置」效果一致：\n\n\n\n然后我们再把 Item0 ~ Item 4 的 position 代入代码中计算 finalPosition，不难发现：\n\n * Item 0、Item 1 和 Item2 的 finalPosition 等于 position，也就是说 3 者的位置没有变动。这是因为它们的\n   position + halfTotalWidth 是 250%、350% 和 450%，都比 totalWidth 小；\n * Item 3 和 Item 4 的 finalPosition 等于 position - totalWidth，也就是说 2 者的位置都往左平移了\n   totalWidth（500%）。这是因为它们的 position + halfTotalWidth 是 550% 和 650%，都比\n   totalWidth 大。\n\n\n\n这么说你可能还是难以理解，我再换另一种说法。\n\n我们已经知道两个条件：\n\n * 要实现不复制元素的循环轮播，需要保证中央元素左右元素数量尽量相等。这样用户往左滑、往右滑都能看到元素。\n * 当元素的 translateX 为 0% 时，所有元素会重叠在中央。\n\n不难想到，把元素的 translateX 设置为正数，元素就会在中央元素右侧；把元素的 translateX 设置为负数，元素就会在中央元素左侧。\n\n一个合理的想法就是，把 Item 的 translateX 范围限定在 -X 到 X 之间，这样就能保证中央元素左右的元素数量尽量相等。5 元素的轮播图，X\n可以取值 halfTotalWidth（也就是 250%）。\n\n什么方法可以限定取值范围呢？答案是取模，不过当除数是正数时，求出的模也必定是正数2。如果直接用 mod(position, totalWidth)\n限定取值范围，会把 translateX 限定在 0% ~ 500% 之间。\n\n我们可以这样做，先把 position + halfTotalWidth 除以 totalWidth 取模，mod(position +\nhalfTotalWidth, totalWidth) 取值范围为 0% ~ 500%，然后把 mod(position + halfTotalWidth,\ntotalWidth) 整体减去 halfTotalWidth，取值范围就是 -250% 到 250% 了。\n\n\n代码示例#\n\n下面给出代码示例：\n\n无复制元素的循环轮播图 | codepen\n\n\n总结#\n\n本文说明了不复制元素的循环轮播如何实现。\n\n首先，我们通过 01234 转变为 34012 的例子，解释循环轮播的初始顺序如何设置。然后，我们用 HTML 代码，实现了 34012 顺序的轮播。\n\n接着，我们用两种思路解释 JavaScript\n代码：第一种思路是先找到中央元素，然后往中央元素的右边放剩余元素，放完一半的剩余元素后，再把另外一半放到中央元素左边。第二种思路是，先找到 translateX\n为 0% 的元素，它就是中央元素。然后用取模的方式，把其他元素的 translateX 限定在 -halfTotalWidth 和 halfTotalWidth\n之间。\n\n最后，我们给出了 JavaScript 不复制元素实现循环轮播的代码。\n\n\nFootnotes\n\n 1. Ant Design Mobile Swiper ↩\n\n 2. 取余和取模如何区分和应用 ↩","routePath":"/blog/2023/12/14/","lang":"","toc":[{"text":"轮播的原理","id":"轮播的原理","depth":2,"charIndex":254},{"text":"计算轮播位置的代码","id":"计算轮播位置的代码","depth":2,"charIndex":1125},{"text":"布局代码","id":"布局代码","depth":3,"charIndex":1189},{"text":"逻辑代码","id":"逻辑代码","depth":3,"charIndex":1651},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":3513},{"text":"总结","id":"总结","depth":2,"charIndex":3555}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":2,"title":"取余和取模如何区分与应用？","content":"#\n\n取余（remainer）和取模（modulo），很多书籍没有说明它们的区别、也没有说明它们的应用场景。比如《JavaScript 高级程序设计（第 4\n版）》直接说：\n\n> 取模（余数）操作符由一个百分比符号（%）表示。\n\n但实际上，两个概念并不完全一致。严格来说，JavaScript 中的 % 是取余，而不是取模。\n\n有读者可能认为，没必要区分取余和取模。但我想说，区分取余和取模，能帮助你写出更优雅的代码。\n\n以掘金的创作话题轮播为例，它带有灰色进度条，当你左滑或右滑时，话题对应的圆点会变长。\n\n\n\n假如让你来实现灰色进度条，需要计算左滑后的下标（prevIndex）和右滑后的下标（nextIndex），你会怎么做呢？\n\n * 要是你完全不理解取余和取模，为了兼顾左滑、右滑的边界情况，你可能会这样写：\n\n\n\n * 要是你只理解取余，不理解取模，你可能会这样写：\n\n\n\n * 要是你既理解取余，又理解取模，你可以写出更优雅的代码：（mod 不是 JavaScript 原生函数，需要额外实现）\n\n\n\n如果你想知道取余和取模的区别和应用、以及 mod 函数如何实现，看完这篇文章，你一定有所收获。\n\n我会先给出取余和取模的计算方式，再用四个例子解释计算方式，接着我会谈一谈什么时候该取余，什么时候该取模，最后我会介绍 JavaScript 中 2 种实现\nmod 函数的方法。\n\n\n计算方式#\n\n余数和模的计算方式如下图：\n\n\n\n其中 fix 代表向 0 取整，而 floor 代表向负无穷取整。你可能并不理解什么叫作「向 0\n取整」，什么叫作「向负无穷取整」，先不要着急，在例子中我会详细讲解。\n\n\n例子#\n\n\n5 除以 2#\n\n把 x = 5，y = 2 代入公式后，你需要计算的是 fix(2.5) 和 floor(2.5)。\n\n\n\n你可以画出一个右箭头，代表从负无穷指向正无穷的数轴。\n\n找到 2.5 的位置，可以发现 0 和负无穷都在 2.5 的左边。对 2.5 来说，向 0 取整和向负无穷取整，都是往左边取。\n\n所以 fix(2.5) = 2， floor(2.5) = 2，把它们代入公式，得到余数和模都是 1。\n\n\n-5 除以 2#\n\n再看 -5 除以 2，继续代入公式画数轴，你需要计算的是 fix(-2.5) 和 floor(-2.5)。\n\n\n\n找到 -2.5 的位置，可以看到 0 在 -2.5 的右边，而负无穷在 -2.5 的左边。此时向 0 取整就是取 -2.5 右边的整数，向负无穷取整就是取\n-2.5 左边的整数。\n\n所以 fix(-2.5) = -2，floor(-2.5) = -3。把它们代入公式，得到余数为 -1，模为 1。\n\n\n5 除以 -2#\n\n继续看 5 除以 -2，你需要计算的是 fix(-2.5) 和 floor(-2.5)。\n\n\n\n之前已经知道 fix(-2.5) = -2，floor(-2.5) = -3，把它们代入公式，得到余数为 1，模为 -1。\n\n\n-5 除以 -2#\n\n最后看 -5 除以 -2，你需要计算的是 fix(2.5) 和 floor(2.5)。\n\n\n\n之前已经知道 fix(2.5) = 2，floor(2.5) = 2，把它们代入公示后得到余数和模都是 -1。\n\n\n余数和模的区别#\n\n观察上面的 4 个例子，不难发现，取余和取模的结果，和 x 和 y 的正负号有关。\n\n * 当 x 和 y 同为正数、或者同为负数时，x rem y 和 x mod y 的结果一样。\n * 当 x 和 y 符号不一致时，x rem y 和 x mod y 的结果不一样。rem 计算结果符号和 x 一样，mod 计算结果和 y 一样。\n\n实际应用中，y 一般都是正数，因此只需要考虑 x 符号的正负。\n\n * 当 x 为正数时，此时取余数和取模结果一致，因此最好使用 JavaScript 的 % 运算符。\n   \n   例如你想访问数组中的某个元素，又担心下标超出数组的范围，你可以先求下标除以数组长度的余数，把余数作为新下标。\n\n * 当 x 可能为正数也可能为负数时，此时可以实现一个 mod 函数。\n   \n   例如我在文章开头举的例子，prevIndex 可能是一个负数，你可以直接求 prevIndex 除以轮播长度的模。\n\n\n实现取模函数#\n\n取模函数，我知道的有两种实现方法，一种是偏重工程，另一种偏重学术。两者有什么区别呢？\n\n之前提到过，实际应用中，x mod y 时，y 一般是正数。\n\n * 工程方法追求简单实用，只考虑 y 为正数的情况。\n\n它的写法简单易懂，先求 x 除以 y 的余数，如果结果为负数，就给结果再加上一个 y，保证结果始终为正数。\n\n\n\n\n\nAnt Design Mobile Swiper 1 源码用的就是这种方法。\n\n * 学术方法追求逻辑严密，既会考虑 y 为正数，也会考虑 y 为负数。\n\n它的写法如下，我不清楚怎么证明，但代入数字计算，可以验证结果正确。\n\n\n\n\n\nMDN 2 和 stackoverflow 3 推荐的就是这种方法。\n\n\nFootnotes\n\n 1. ant-design-mobile | github ↩\n\n 2. remainder | mdn ↩\n\n 3. JavaScript % (modulo) gives a negative result for negative numbers |\n    stackoverflow ↩","routePath":"/blog/2024/01/18/","lang":"","toc":[{"text":"计算方式","id":"计算方式","depth":2,"charIndex":597},{"text":"例子","id":"例子","depth":2,"charIndex":707},{"text":"5 除以 2","id":"5-除以-2","depth":3,"charIndex":713},{"text":"-5 除以 2","id":"-5-除以-2","depth":3,"charIndex":923},{"text":"5 除以 -2","id":"5-除以--2","depth":3,"charIndex":1141},{"text":"-5 除以 -2","id":"-5-除以--2","depth":3,"charIndex":1263},{"text":"余数和模的区别","id":"余数和模的区别","depth":2,"charIndex":1379},{"text":"实现取模函数","id":"实现取模函数","depth":2,"charIndex":1810}],"domain":"","frontmatter":{},"version":""},{"id":3,"title":"H5 离线包放入 HTML 后降级方案如何设计？","content":"#\n\n离线包是移动端 H5 常见的性能优化方案。开发者们或多或少都接触过离线包。francecil 大佬还总结了离线包是否要放入 HTML\n的两种决策，以及决策的优缺点： 1：\n\n * 放入 HTML（缓存优先）：更好的性能，但更新不及时。\n * 不放入 HTML（网络优先）：实时更新，但性能较差，可能会加载失败。\n\n我选择把 HTML 放入离线包，这意味着 H5 出现线上故障时，没有办法及时修复。因此，我必须额外设计一套降级方案，保证离线包发生故障时能够快速降级。\n\n如果你也为离线包的降级而烦恼，看了这篇文章，你一定有所收获。我会从离线包的机制说起，解释离线包放入 HTML\n后为什么更新不及时，然后我会介绍自己设计的降级方案，最后我会对这个方案做一个总结。\n\n\n离线包的生效机制#\n\n为什么离线包放入 HTML 后更新不及时？为了回答这个问题，我们必须先知道它是如何生效的。\n\n离线包首先会把 HTML、CSS 和 JS 等资源文件打包成一个压缩包，并预先下载到 App 本地，解压到缓存中。当用户访问 H5 时，Webview\n开始加载资源的 URL 并发出资源请求，App 会拦截这些请求。\n\n * 如果缓存中有满足请求的资源，App 会使用缓存资源；\n * 如果缓存中没有满足请求的资源，App 会使用线上资源。\n\n\n\n什么时候叫缓存资源满足请求呢？就是缓存文件名字和请求文件名字一致。\n\n * 如果我们在离线包里放入 HTML，由于 HTML 文件不会轻易改变，即使线上资源有更新，App 也会优先使用缓存资源；\n * 如果我们不放入 HTML，由于 CSS 和 JS 文件名的哈希会改变，所以线上资源有更新时，App 内 HTML、CSS 和 JS 都会使用线上资源。\n\n\n我设计的降级方案#\n\n上一节我们已经知道，HTML 文件名没有变化，离线包就不会失效。我们可以利用跳转间接改变文件名。\n\n\n利用跳转降级离线包#\n\n首先，我们需要准备两个内容一样的 HTML，一个是 index.html，另一个是 index-online.html。\n\n * index.html 会放入离线包；\n\n * index-online.html 不会放入离线包。\n\n然后，我们会设计一个开关，控制 index.html 是否要跳转。\n\n * 开关开启时，index.html 会跳转到 index-online.html；\n * 开关关闭时，index.html 保持原始逻辑。\n\n这样发生线上故障时，我们可以回滚线上的 H5 页面，此时 index-online.html 恢复正常，而缓存在用户 App 本地的 index.html\n还有问题。\n\n我们开启开关后，离线的 index.html 直接跳转到已经恢复正常的 index-online.html，就实现了离线包的降级。\n\n\n利用版本大小设计开关#\n\n上一小节，我们提到降级方案需要一个开关，设计这个开关，我们需要考虑两个问题：\n\n * 离线包有 n 个版本，有时多个版本均存在问题。比如 1.0.0 离线包没有问题，1.0.1 和 1.0.2 都有问题，我们需要保证开关能够降级多个版本。\n\n\n\n * 我们会发布修复的离线包，比如我们会在 1.0.3 修复问题。开关打开后，不能把修复版本降级。\n\n\n\n怎么设计呢？我这里采取最简单粗暴的思路，把离线包本身的版本 H5_VERSION 和要降级的版本 rollbackVersion 做一个比较。\n\n * H5_VERSION <= rollbackVersion，相当于打开降级开关。\n * H5_VERSION > rollbackVersion，相当于关闭降级开关。\n\n继续使用之前的例子，1.0.2 是出现问题的最高版本，我们可以把 rollbackVersion 设置为 1.0.2，<= 1.0.2 全部降级。这样虽然会误伤\n1.0.0 版本，但能既满足降级多个有问题的版本，又满足不降级修复版本。\n\n\n\n发生下一次故障时，我们再更新 rollbackVersion，比如 1.0.4 发生了故障，我们把 rollbackVersion 设置为 1.0.4，<=\n1.0.4 全部降级。\n\n\n\n\n利用 localStorage 延迟开关生效时间#\n\n上一节我们介绍了如何设计开关。需要注意的是，我们不能一发现开关打开、就立即跳转，这会中断用户正常的操作。（比如用户正在浏览页面，突然页面跳转）\n\n我们等开关打开后，在 localStorage 中存储一下代表打开的标识，等到用户下次进入页面时，发现有打开标识再跳转到 index-online.html。\n\n\n流程图#\n\n考虑完上面三个问题后，我们就可以设计一个比较完善的降级方案了，它的流程图如下：\n\n\n\n 1. 用户一进入页面，会先获取 localStorage 中的 needRollback 开关标识。\n 2. 如果 needRollback 标识打开，则跳转 index-online.html 实现降级。（注：index-online.html 中不能继续判断\n    needRollback，否则会无限跳转）\n 3. 如果 needRollback 标识没有打开，则继续获取 H5 本身的版本号，以及接口下发的 rollbackVersion。\n 4. 如果 H5_VERSION <= rollbackVersion，则在 localStorage 把 needRollback 设置为 1。\n 5. 如果 H5_VERSION > rollbackVersion，则删除 localStorage 中的 needRollback 标识。\n\n\n总结#\n\n本文介绍了一种离线包放入 HTML 的降级方案，它主要有三个特点：\n\n 1. 利用从离线化的 index.html 跳转到线上的 index-online.html 实现降级。\n 2. 利用离线包版本 H5_VERSION <= rollbackVersion 做开关，判断是否需要降级。\n 3. 利用 localStorage 中设置 needRollback 标识，延迟开关作用时间。\n\n这种方案是离线包放入 HTML 后，一种成本较低的降级方案。它会在降级时误伤低版本的离线包，以损耗性能为代价，保障质量。\n\n\nFootnotes\n\n 1. HTML 放入离线包？你需要了解的离线策略 ↩","routePath":"/blog/2024/01/27/","lang":"","toc":[{"text":"离线包的生效机制","id":"离线包的生效机制","depth":2,"charIndex":335},{"text":"我设计的降级方案","id":"我设计的降级方案","depth":2,"charIndex":746},{"text":"利用跳转降级离线包","id":"利用跳转降级离线包","depth":3,"charIndex":808},{"text":"利用版本大小设计开关","id":"利用版本大小设计开关","depth":3,"charIndex":1197},{"text":"利用 localStorage 延迟开关生效时间","id":"利用-localstorage-延迟开关生效时间","depth":3,"charIndex":1763},{"text":"流程图","id":"流程图","depth":3,"charIndex":1945},{"text":"总结","id":"总结","depth":2,"charIndex":2371}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":4,"title":"H5、小程序商品加入购物车的抛物线动画如何实现？","content":"#\n\n电商类 H5、小程序把商品加入到购物车时，常常有一个抛物线动画。比如麦当劳小程序，当你点击加购按钮时，会看到有一个小汉堡从卡片汉堡上抛出，然后掉落到购物袋里。\n\n\n\n这种动画该怎么做呢？如果你也想实现它，看完这篇文章，你一定有所收获。我会先说明抛物线动画的原理，再解释实现它的关键代码，最后给出完整的代码示例。代码效果如下：\n\n\n\n\n抛物线动画的原理#\n\n高中物理告诉我们，平抛运动、斜抛运动可以分解为水平方向的匀速直线运动、竖直方向自由落体运动（匀加速直线运动）。\n\n\n\n同理，我们可以把抛物线动画分解为水平的匀速动画、竖直的匀加速动画。\n\n水平匀速动画很容易实现，直接 animation-timing-function 取值 linear 就行。\n\n竖直的匀加速直线运动，严格实现非常困难，我们可以近似实现。因为匀加速直线运动，速度是越来越快的，所以我们可以用一个先慢后快的动画替代，你可能立刻就想到给\nanimation-timing-function 设置 ease-in。不过 ease-in\n先慢后快的效果不是很明显。针对这个问题，张鑫旭大佬提供了一个贝塞尔曲线 cubic-bezier(0.55, 0, 0.85, 0.36);1。当然，你也可以用\ncubic-bezier 自己调一个先慢后快的贝塞尔曲线。\n\n\n关键代码实现#\n\n我们把代码分为两部分，第一部分是布局代码、第二部分是动画代码。\n\n\n布局代码#\n\n首先是 HTML 代码，代码非常简单。下图中小球代表商品、长方形代表购物车。\n\n\n\n\n\n你可能比较好奇，小球用一个 ball 元素就可以实现，为什么我要用 ball 和 ball-box 两个元素呢？因为 animation\n只能给一个元素定义一个动画效果，而我们需要给小球添加两个动画效果。于是我们将动画分解，给 ball-box 添加水平运动的动画，给 ball\n添加竖直运动的动画。\n\n\n动画代码#\n\n再看动画代码，moveX 是水平运动动画，moveY 是竖直动画，动画时间均为 1s。为了让效果更加明显，我还特意将动画设置成无限循环的动画。\n\n\n\n\n代码示例#\n\n抛物线动画 | codepen\n\n\n总结#\n\n本文我们介绍了抛物线动画的实现方法，我们可以将抛物线动画拆分为水平匀速直线动画和竖直从慢变快的动画，水平动画我们可以使用 linear\n来实现，竖直动画我们可以使用一个先慢后快的贝塞尔曲线替代。设置动画时，我们还需要注意，一个元素只能设置一个动画。\n\n\nFootnotes\n\n 1. 这回试试使用CSS实现抛物线运动效果 | 张鑫旭 ↩","routePath":"/blog/2024/02/03/","lang":"","toc":[{"text":"抛物线动画的原理","id":"抛物线动画的原理","depth":2,"charIndex":169},{"text":"关键代码实现","id":"关键代码实现","depth":2,"charIndex":568},{"text":"布局代码","id":"布局代码","depth":3,"charIndex":611},{"text":"动画代码","id":"动画代码","depth":3,"charIndex":815},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":898},{"text":"总结","id":"总结","depth":2,"charIndex":923}],"domain":"","frontmatter":{"tags":["H5","小程序"]},"version":""},{"id":5,"title":"H5 蛟龙闹海动画如何实现（不引用图片）？","content":"#\n\n龙年要到了，祝大家在新的一年里，如龙腾飞、事业有成；如龙入海、财源广进。\n\n我使用 HTML 和 CSS 实现了一个蛟龙闹海效果。\n\n\n\n它很简略，但是代码中我没有引用图片，我是怎么做的呢？\n\n下面我会从下往上、依次解释如何实现海浪、龙和云朵，接着我会给出整体代码，最后，我会做一个简单总结。\n\n\n海浪如何实现#\n\n我使用 2 个不同 border-radius 圆角的正方形实现了海浪效果。首先，我实现了一个圆形和两个圆角正方形，然后把两个圆角正方形移动到圆形的底部。\n\n\n\n然后，我给圆角正方形添加旋转动画，\n\n\n\n之后给圆形添加 overflow: hidden;，就可以得到海浪效果。\n\n\n\n\n龙如何实现#\n\n再看下龙如何实现，我使用 clip-path 实现了龙的效果。\n\nclip-path 是 CSS 一个属性，可以裁剪元素。裁剪区域内的显示，区域外的隐藏。可以利用 ploygon() 定义多个顶点，连接好后就成为了多边形。\n\n我裁剪了 10 个多边形，组合成了龙。其中 1 个 8 边形是龙头、1 个 4 边形是眼睛、2 个 5 边形是龙角、4 个 4 边形是鬃毛，还有 1 个 12\n边形是脖子、1 个 12 边形是肚子。\n\n不过，以我的设计经验，肯定是没办法轻松裁剪出这些多边形的，我使用了 clippy 这个工具，这个工具可以像描图一样把多边形裁剪出来。\n\n\n\n理论上裁剪得越精细，多边形数量越多，描边的龙就越像。这是纯粹的体力活，我这里偷个懒，只裁剪出大概的形状。\n\n\n云朵如何实现#\n\n实现了龙，我们再看下云朵如何实现，我使用 6 个圆重叠形成了云朵。\n\n简单画 6 个圆，如下所示：\n\n\n\n只要将这些圆的边框全部变透明，再填充上颜色，就可以得到一朵云。\n\n\n\n我没有创建 6 个 div 元素然后叠加，而是使用了 box-shadow 来实现。box-shadow 最多有五个参数。\n\n\n\n不需要阴影模糊半径和阴影扩散半径，只需要设置 x 偏移量和 y 偏移量，就可以实现圆形的偏移：\n\n\n\n\n示例代码#\n\n现在，我们看完整代码：\n\n蛟龙闹海 | codepen\n\n\n总结#\n\n本文我们利用 HTML 和 CSS 实现了一个蛟龙闹海效果。其中：\n\n 1. 海浪，可以使用两个旋转的圆角正方形实现。\n 2. 龙，可以使用 clip-path 裁剪多边形，再拼接多边形实现。\n 3. 云朵，不需要创建多个元素，可以使用 box-shadow 并设置多组值实现。","routePath":"/blog/2024/02/09/","lang":"","toc":[{"text":"海浪如何实现","id":"海浪如何实现","depth":2,"charIndex":151},{"text":"龙如何实现","id":"龙如何实现","depth":2,"charIndex":303},{"text":"云朵如何实现","id":"云朵如何实现","depth":2,"charIndex":650},{"text":"示例代码","id":"示例代码","depth":2,"charIndex":864},{"text":"总结","id":"总结","depth":2,"charIndex":901}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":6,"title":"H5、小程序高度变化的轮播图如何实现？","content":"#\n\n高度固定的轮播图，你肯定经常看到、并知道怎么实现，但高度变化的轮播图呢？\n\n下面是 Keep 的课程轮播，可以看到 9 号的视频数量是少于 10 号和 11 号的，所以 9 号的视频列表的高度比 10、11 号低。当播放到 9\n号课程时，下方的主题课程模块会往上移动，填充 9 号视频列表下方的空白。\n\n\n\n如果你也想实现高度变化的轮播，看完这篇文章，你一定有所收获。我会先解释高度变化的原理，然后说明关键实现，最后再给出原生 H5 和小程序的示例代码。代码效果如下：\n\n\n\n\n高度变化的原理#\n\n如果我们使用 flex 布局实现轮播图 Swiper，那么轮播图的整体高度，将会是最高一项的高度。\n\n如下图，虚线框代表 Swiper，Swiper 的每项都是 List。如果播放到某个 List，这个 List\n就是红色。可以看到，只要轮播图播放到较矮项，就会在较矮项底部留下大量空白。\n\n\n\n要想实现高度变化、且不留下空白的轮播图，原理很简单。我们只需要在轮播切换时，先获取即将播放的 List 高度，再把它的高度设置给 Swiper。\n\n如下图，播放到某个 List，Swiper 的高度就变为这个 List 的高度。我们还可以给 Swiper 设置 overflow: hidden;，把找出\nSwiper 范围的元素都给隐藏掉。\n\n\n\n\n关键代码实现#\n\n聊完原理，我们来看代码，代码非常简单粗暴。\n\n我们为每个 List 都设置了一个 id，利用 id 获取 List 的高度再设置到 Swiper 元素的 style 上。\n\n\n\n\n代码示例#\n\n现在来看 H5 和小程序的代码示例，为了突出重点，我并没有实现左右滑动，而是用点击切换近似替代：\n\n\nH5#\n\n高度变化的轮播图 | codepen\n\n\n小程序#\n\n高度变化的轮播图 | 小程序\n\n:::info\n\n * 小程序有原生的 swiper 组件，我们可以给 swiper 直接增加一个 style，在 style 中改变 swiper 的高度。\n * 小程序没有 querySelector()，可以用 createSelectorQuery() 替代。 :::\n\n\n额外提醒#\n\n高度变化的轮播图非常少见，你需要仔细斟酌什么时候用它。\n\n如果你不需要左右滑动，那么选择 Tab + 卡片更适合。比如 12306 的选项卡，高度就是不等的：\n\n\n\n如果轮播每一项轮播都是长列表，且随着用户上拉屏幕，列表加载的数据还会变多。这种轮播通常还是固定高度（100vh）的轮播。\n\n它在拼多多、淘宝、京东上很常见。你需要注意，这种轮播每一项需要自带滚动条，否则处理列表滚动条会变得非常麻烦。因为这种轮播往往要求记住用户在每个列表滚动的位置，如\n果轮播共用滚动条，左右切换会有一个很明显的闪烁。\n\n\n\n\n总结#\n\n本文我们介绍了高度变化的轮播图实现原理——先获取对应轮播项的高度，再改变轮播图的整体高度。之后我们给出了 H5 和小程序的代码示例。","routePath":"/blog/2024/02/16/","lang":"","toc":[{"text":"高度变化的原理","id":"高度变化的原理","depth":2,"charIndex":241},{"text":"关键代码实现","id":"关键代码实现","depth":2,"charIndex":575},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":674},{"text":"H5","id":"h5","depth":3,"charIndex":732},{"text":"小程序","id":"小程序","depth":3,"charIndex":758},{"text":"额外提醒","id":"额外提醒","depth":2,"charIndex":921},{"text":"总结","id":"总结","depth":2,"charIndex":1183}],"domain":"","frontmatter":{"tags":["H5","小程序"]},"version":""},{"id":7,"title":"H5、小程序中四个反向圆角的图片如何实现？","content":"#\n\n最近我逛热风小程序（一个卖鞋的小程序）时，发现了一个奇特的图片样式。图片的四个圆角是反向的，和常规图片不一样。\n\n\n\n思索一番后，我发现想实现这个效果，需要的 CSS 知识还挺多，于是整理这篇文章。\n\n下面我会先介绍如何实现四个反向圆角的矩形，再介绍如何把特殊矩形作为遮罩、得到和热风小程序的图片效果。接着，我会给出完整的代码，最后，我会给做一个简单的总结。\n\n\n如何实现四个反向圆角的矩形#\n\n不难想到，四个反向圆角的矩形，就是四个边角都被圆遮挡的矩形。\n\n\n\n\n径向渐变#\n\n知道圆遮挡矩形的原理后，我们最容易想到的办法是 —— 先用 50% 的 border-radius 得到圆，再改变圆形的定位去遮挡矩形。\n\n不过这种方法需要多个元素，并不优雅，我将介绍另一种更巧妙的办法。\n\n我们需要先了解一个 CSS 函数 —— radial-gradient。radial-gradient\n中文名称是径向渐变，它可以指定渐变的中心、形状、颜色和结束位置。语法如下：\n\n\n\n\n利用径向渐变在矩形中心画圆#\n\n光看语法比较抽象，我们用代码写一个实际的例子。如图所示，我们要在矩形中心画圆：\n\n\n\n下面是关键代码：\n\n\n\n其中：\n\n * radial-gradient 函数用于创建渐变效果。\n * circle at center 指定了圆形渐变，并且渐变的中心在矩形的中心。\n * transparent 0 指定了第一个渐变颜色为透明，位置是从中心开始。\n * transparent 20px 指定了第二个渐变颜色也为透明，位置距离中心 20px。\n * #ddd 20px 指定了第三个渐变颜色为淡灰色，位置距离中心 20px，第三个渐变颜色之后的颜色都是淡灰色。\n\n通过 radial-gradient，我们成功让矩形中心、半径为 20px 的圆变透明，超过半径 20px\n的地方颜色都变为灰色，这样看起来就是矩形中心有一个圆。\n\n\n矩形左上角画圆#\n\n不难想到，只要我们把圆的中心从矩形中心移动到矩形的左上角，就可以让圆挡住矩形左上角，得到一个反向圆角。\n\n\n\n关键代码如下，我们可以把 circle at center 改写为 circle at left top：\n\n\n\n\n矩形四个角画圆#\n\n我们已经知道 radial-gradient 如何实现 1 个反向圆角，接下来再看如何实现 4 个反向圆角。继续之前的思路，我们很容易想到给\nbackground 设置多个反向渐变。\n\n多个渐变之间可以用逗号分隔、且它们会按照声明的顺序依次堆叠。于是我们会写出如下关键代码：\n\n\n\n遗憾的是，上述代码运行后我们看不到四个反向圆角，而是看到一个矩形。\n\n\n\n这是因为四个矩形互相堆叠，反而把反向圆角给遮住了。\n\n\n\n遮挡怎么解决呢？我们可以分四步来解决。\n\n设置背景宽度和高度#\n\n我们先单独看一个径向渐变。\n\n第一步是设置 background-size: 50% 50%;，它设置了背景图像的大小是容器宽度和高度的 50%。代码运行后效果如下：\n\n\n\n可以看到左上角有反向圆角的矩形重复出现了四次。\n\n设置不允许重复#\n\n第二步是设置 background-repeat: no-repeat;。我们需要去除第一步中出现的重复。代码运行后效果如下：\n\n\n\n给每个径向渐变设置位置#\n\n第三步是设置不允许重复时，应该保留的背景图像位置。\n\n第一步中左上角是反向圆角的矩形出现了四次，第二步不允许重复时默认保留了左上角的矩形。事实上我们可以选择保留四个矩形中的任何一个，比如我们可以选择保留右下角的矩形\n。\n\n\n\n代码运行后效果如下：\n\n\n\n组合前三个步骤#\n\n第四步是组合前三个步骤的语法。\n\n看完第三步后，一个很自然的想法，就是用四个渐变分别形成四个特殊矩形，然后把四个特殊矩形分别放在左上、右上、左下和右下角，最后得到有四个反向圆角的矩形。\n\n关键代码如下,为了区分四个径向渐变，我给左上、右上、左下、右下分别设置了红、绿、蓝、黄四种颜色：\n\n\n\n代码运行效果如下：\n\n\n\n不难想到，只要把红、绿、蓝、黄都换为灰色，就可以得到一个全灰、有四个反向圆角的矩形。\n\n\n\n\n把背景改写为遮罩#\n\n知道四个反向圆角的矩形如何实现后，我们可以：\n\n * 把 background-size 改写为 mask-size；\n * 把 background-repeat 改写为 mask-repeat;\n * 把 background 改写为 mask；\n\n这样就可以得到四个反向圆角的矩形遮罩。\n\n\n\n我们可以把四个反向圆角的矩形覆盖在一张背景图片上，就得到了和热风小程序一样的效果：\n\n\n\n需要注意的是，部分手机浏览器不支持 mask 语法，所以我们有必要再设置一份 -webkit-mask、-webkit-mask-size 和\n-webkit-mask-repeat。\n\n\n代码示例#\n\n四个反向圆角的图片 | codepen\n\n\n总结#\n\n本文我们介绍了如何实现四个反向圆角的图片。\n\n我们可以利用径向渐变，实现四个反向圆角的矩形。然后我们把这个矩形作为遮罩，覆盖在背景图片上，这样就实现了四个反向圆角的图片。","routePath":"/blog/2024/02/19/","lang":"","toc":[{"text":"如何实现四个反向圆角的矩形","id":"如何实现四个反向圆角的矩形","depth":2,"charIndex":184},{"text":"径向渐变","id":"径向渐变","depth":3,"charIndex":235},{"text":"利用径向渐变在矩形中心画圆","id":"利用径向渐变在矩形中心画圆","depth":3,"charIndex":440},{"text":"矩形左上角画圆","id":"矩形左上角画圆","depth":3,"charIndex":823},{"text":"矩形四个角画圆","id":"矩形四个角画圆","depth":3,"charIndex":946},{"text":"设置背景宽度和高度","id":"设置背景宽度和高度","depth":4,"charIndex":1184},{"text":"设置不允许重复","id":"设置不允许重复","depth":4,"charIndex":1308},{"text":"给每个径向渐变设置位置","id":"给每个径向渐变设置位置","depth":4,"charIndex":1385},{"text":"组合前三个步骤","id":"组合前三个步骤","depth":4,"charIndex":1526},{"text":"把背景改写为遮罩","id":"把背景改写为遮罩","depth":3,"charIndex":1742},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":2043},{"text":"总结","id":"总结","depth":2,"charIndex":2072}],"domain":"","frontmatter":{"tags":["H5","小程序"]},"version":""},{"id":8,"title":"H5 下拉刷新如何实现？","content":"#\n\n最近我需要做一个下拉刷新的功能，实现功能后我发现，它需要处理的情况还蛮多，于是我整理了这篇文章。\n\n下图是我实现的效果，分为三步：开始下拉时，屏幕顶部会出现加载动画；加载过程中，屏幕顶部高度保持不变；加载完成后，加载动画隐藏。\n\n\n\n首先我会讲解下拉的原理、根据原理写出初始代码；然后我会说明代码存在的缺陷、解决缺陷并做些额外优化；最后我会给出完整代码，并做一个总结。\n\n\n下拉的原理#\n\n\n\n如图所示，蓝色框代表视口，绿色框代表容器，橙色框代表加载动画。最开始时，加载动画处于视口外；开始下拉之后，容器向下移动，加载动画从上方进入视口；结束下拉后，容器\n又开始向上移动，加载动画也从上方退出视口。\n\n\n下拉基础代码#\n\n知道原理，我们现在开始写代码，首先是布局的代码：\n\n\n布局代码#\n\n我们把 box 元素当作容器，把 loader-box，loader-box + loading 元素当作动画，至于 h1\n元素不需要关注，我们只把它当作操作提示。\n\n\n\nloader-box 的高度是 80px，按上一节原理中的分析，初始时我们需要让 loader-box 位于视口上方，因此 CSS\n代码中我们需要把它的位置向上移动 80px。\n\n\n\nloader-box 中的 loader 是纯 CSS 的加载动画。我们利用 border 画出的一个圆形边框，左、上、右边框是浅灰色，下边框是深灰色：\n\n\n\n\n\n开始刷新时，我们给 loader 元素增加一个动画，让它从 0 度到 360 度无限旋转，就实现了加载动画：\n\n\n\n\n\n\n逻辑代码#\n\n看完布局代码，我们再看逻辑代码。逻辑代码中，我们要监听用户的手指滑动、实现下拉手势。我们需要用到三个事件：\n\n * touchstart 代表触摸开始；\n * touchmove 代表触摸移动；\n * touchend 代表触摸结束。\n\n从 touchstart 和 touchmove 事件中我们可以获取手指的坐标，比如 event.touches[0].clientX 是手指相对视口左边缘的\nX 坐标，event.touches[0].clientY 是手指相对视口上边缘的 Y 坐标；从 touchend 事件中我们则无法获得 clientX 和\nclientY。\n\n我们可以先记录用户手指 touchstart 的 clientY 作为开始坐标，记录用户最后一次触发 touchmove 的 clientY\n作为结束坐标，二者相减就得到手指移动的距离 distanceY。\n\n设置手指移动多少距离，容器就移动多少距离，就得到了我们的逻辑代码：\n\n\n\n逻辑代码实现一个简陋的下拉效果，当然现在还有很多缺陷。\n\n\n\n\n简陋下拉效果的 6 个缺陷#\n\n之前我们实现了简陋的下拉效果，它还需要解决 6 个缺陷，才能算一个完善的功能。\n\n\n没有最小、最大距离限制#\n\n第一个缺陷是，下拉没有做最小、最大距离的限制。\n\n通常来说，我们下拉屏幕时，距离太小应该不能触发刷新，距离太大也不行，下滑到一定距离后，就应该无法继续下滑。\n\n因此我们可以给下拉设置最小距离限制 DISTANCE_Y_MIN_LIMIT、最大距离限制 DISTANCE_Y_MAX_LIMIT。如果 touchend\n中发现下拉距离小于最小距离，直接不触发加载；如果 touchmove 中下拉距离超过最大距离，页面只向下移动最大距离。\n\n解决缺陷关键代码如下：\n\n\n\n\n加载动画没有停留在视口顶部#\n\n第二个缺陷是，下拉没有让加载动画停留在视口顶部。\n\n我们可以把 end 函数加以改造，在数据还没有加载完成时（用 setTimeout 模拟的），让加载动画 style 的 translateY 一直是\n80px，translateY(80px) 可以和 初始 CSS 的 top: -80px; 相互抵消，让动画在未刷新完成前停留在视口顶部。\n\n\n\n\n重复触发#\n\n第三个缺陷是，下拉可以重复触发。\n\n正常来说，如果我们已经下拉过，数据正在加载中时，我们不能继续下拉。\n\n我们可以增加一个加载锁 loadLock。当加载锁开启时，start，move 和 end 事件都不会触发。\n\n\n\n\n没有限制方向#\n\n第四个缺陷是，没有限制方向。\n\n目前我们的代码，用户上拉也能触发。我们可以增加判断，当 endY - startY 小于 0 时，阻止 touchmove 和 touchend 的逻辑。\n\n\n\n你可能会疑惑，为什么我宁愿写多个判断拦截，也不取消监听事件。这是因为一旦取消监听事件，我们需要考虑在一个合适的时间重新监听，这会把问题变得更复杂。\n\n\n没有阻止原生滚动#\n\n第五个缺陷时，我们在加载数据时没有阻止原生滚动。\n\n虽然我们已经阻止了重复下拉，touchmove 和 touchend 事件被拦截了，但是 H5 原生滚动还能用。\n\n我们可以在刷新时给 body 设置一个 overflow: hidden; 属性，刷新结束后清除 overflow: hidden，这样就可以阻止原生滚动。\n\n\n\n\n\n\n没有阻止 iOS 橡皮筋效果#\n\n第 6 个缺陷是，没有阻止 iOS 的橡皮筋效果。\n\niOS 浏览器默认滑动时有一个橡皮筋效果，我们需要阻止它，避免影响我们的下拉手势。阻止方式就是给监听器设置 passive: false。\n\n\n\n解决完 6 个缺陷后，我们已经得到无缺陷的下拉刷新功能，但离丝滑的下拉刷新还有一段距离。我们还可以做一些优化，让下拉刷新更完善。\n\n\n优化#\n\n我们可以做两个优化，第一个优化是添加阻尼效果：\n\n\n增加阻尼效果#\n\n所谓阻尼效果，就是下拉过程我们可以感受到一股阻力的存在，虽然我们下拉力度是一样的，但距离的增加速度变慢了。用物理术语表示的话，就是加速度变小了。\n\n体现到代码上，我们可以设置一个百分比，百分比会随着下拉距离增加而减少，把百分比乘以距离当作最后的距离。\n\n代码中百分比 percent 设为 (100 - distanceY * 0.5) / 100，当 distanceY 越来越大时，百分比 percent\n越来越小，最后再把 distanceY * percent 赋值给 distanceY。\n\n\n\n\n利用角度判断用户下拉意图#\n\n第二个优化是利用角度判断用户下拉意图。\n\n下图展示了两种用户下拉的情况，β 角度比 α 角度小，角度越小用户下拉意图越明显、误触的可能性更小。\n\n\n\n我们可以利用反三角函数求出角度来判断下拉意图。\n\nJavaScript 中，反正切函数是 Math.atan()，需要注意的是，反正切函数算出的是弧度，我们还需要将它乘以 180 / π 才能获取角度。\n\n下面的代码中，我们做了一个限制，只有角度小于 40 时，我们才认为用户的真实意图是想要下拉刷新。\n\n\n\n\n代码示例#\n\n你可以在 codepen 中查看效果，web 端需要按 F12 用手机浏览器打开。\n\n\n\n\n总结#\n\n本文讲解了下拉的原理、并根据原理写出初始代码。在初始代码的基础上，我解决了 6 个缺陷、做了 2 个优化，实现了一个完善的下拉刷新效果。","routePath":"/blog/2024/02/28/","lang":"","toc":[{"text":"下拉的原理","id":"下拉的原理","depth":2,"charIndex":189},{"text":"下拉基础代码","id":"下拉基础代码","depth":2,"charIndex":304},{"text":"布局代码","id":"布局代码","depth":3,"charIndex":340},{"text":"逻辑代码","id":"逻辑代码","depth":3,"charIndex":668},{"text":"简陋下拉效果的 6 个缺陷","id":"简陋下拉效果的-6-个缺陷","depth":2,"charIndex":1137},{"text":"没有最小、最大距离限制","id":"没有最小最大距离限制","depth":3,"charIndex":1195},{"text":"加载动画没有停留在视口顶部","id":"加载动画没有停留在视口顶部","depth":3,"charIndex":1445},{"text":"重复触发","id":"重复触发","depth":3,"charIndex":1638},{"text":"没有限制方向","id":"没有限制方向","depth":3,"charIndex":1757},{"text":"没有阻止原生滚动","id":"没有阻止原生滚动","depth":3,"charIndex":1939},{"text":"没有阻止 iOS 橡皮筋效果","id":"没有阻止-ios-橡皮筋效果","depth":3,"charIndex":2119},{"text":"优化","id":"优化","depth":2,"charIndex":2303},{"text":"增加阻尼效果","id":"增加阻尼效果","depth":3,"charIndex":2334},{"text":"利用角度判断用户下拉意图","id":"利用角度判断用户下拉意图","depth":3,"charIndex":2597},{"text":"代码示例","id":"代码示例","depth":2,"charIndex":2843},{"text":"总结","id":"总结","depth":2,"charIndex":2896}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":9,"title":"H5 上滑加载（触底加载）如何实现？","content":"#\n\n上滑加载（触底加载）是 H5 常见的功能，今天我们来看下如何实现。\n\n效果如下：分页请求开始前，列表滚动，加载动画出现在屏幕中；分页请求过程中，加载动画一直旋转；分页请求完成后，列表底部插入了新节点，加载动画被挤出屏幕。\n\n如此循环往复，直到分页请求无法返回更多数据，列表底部展示「没有更多了」提示，加载动画隐藏。\n\n\n\n首先我会讲解上滑加载的原理，并简单说明 IntersectionObserver\n的用法；接着我会给出上滑加载的关键布局代码、逻辑代码，接着我会介绍上滑加载需要注意的三个问题，最后我会再做个简单的总结。\n\n\n上滑加载的原理#\n\n\n\n如图所示，蓝色矩形代表视口，绿色矩形代表包裹列表和动画的容器，金黄色矩形代表列表，橙色则代表加载动画。\n\n最开始时，加载动画处于视口下方；当用户滚动列表到达底部时，加载动画就进入了视口，此时可以请求列表下一页数据，请求成功后新节点插入到列表底部，新节点把动画挤出了视\n口。\n\n也就是说，想实现加载更多，关键就是监听加载动画有没有进入视口内部。我们可以使用 IntersectionObserver 这个 API 监听动画有没有进入视口。\n\nIntersectionObserver 使用方法如下，我们首先创建了一个监听器 observer，再用这个监听器去监视元素 element。当\nentry.isIntersecting 为 true 时，说明 element 已经进入视口。\n\n\n\n\n上滑加载关键代码#\n\n知道原理后，现在我们来看实现上滑加载的关键代码，首先是布局代码：\n\n\n布局代码#\n\n布局代码和原理图相互对应，box 是包裹列表和加载动画的容器、list 有 5 个子元素、list 下方则是加载动画的容器。\n\n\n\n列表布局很基础，我们主要看动画。loader-box 中的 loader 是纯 CSS 的加载动画。我们利用 border\n画出的一个圆形边框，左、上、右边框是浅灰色，下边框是深灰色：\n\n\n\n\n\n我们给 loader 元素增加一个动画，让它从 0 度到 360 度无限旋转，就实现了加载动画：\n\n\n\n\n\nloader 也是我们真正需要监听是否进入视口的元素。\n\n\n逻辑代码#\n\n关键逻辑代码4和原理中一致，我们只需要监听到动画 loader 进入视口，就直接调用 pullUp 函数。\n\n\n\n\n上滑加载的两个注意点#\n\n实现上滑加载，我们除了关键完布局代码、逻辑代码外，还有三个点需要注意：\n\n\n加载锁#\n\n第一点，前一次上滑加载未完成之前，不应该再次触发上滑加载。\n\n为此，我们需要创建一个加载锁变量 loadLock，数据加载前先把 loadLock 赋值为 true，数据加载完成后再把 loadLock 赋值为\nfalse。如果 loadLock 一直为 true，就说明前一次加载未完成，我们需要直接 return 结束 pullUp 函数。\n\n代码如下：\n\n\n\n\n没有更多数据#\n\n第二点，需要考虑没有更多数据的情况。上滑加载请求的数据是分页的，一定有请求结束的情况。请求结束时，我们需要给用户一些提示。\n\n我们可以设置一个 hasMore 变量。hasMore 为 true 表示时候有更多数据，为 false\n时表示数据了，应该隐藏加载动画，展示「没有更多了」提示。\n\n代码如下，我限制了分页数据最多只有 LIST_LIMIT_CNT 条：\n\n\n\n\n请求失败#\n\n第三点，需要考虑请求失败的情况。我们无法保证服务器一直运转正常，很可能列表前一次分页请求还成功，后一次分页请求就失败了。\n\n这种情况有两种常见交互：\n\n * 直接展示「请求出错了」，让用户点击重试。\n * 继续展示加载动画，重新请求服务器数据。\n\n因为请求失败不好模拟，所以 Demo 中只实现了加载锁和没有更多数据的情况，你可以根据自己的需要改写 Demo。\n\n\n示例代码#\n\n上滑加载、触底加载 | codepen\n\n\n总结#\n\n本文讲解了上滑加载的原理——利用 IntersectionObserver\n监听加载动画是否进入视口，如果动画进入则请求下一页数据。此外，本文还说明了上滑加载需要注意的三个点：加载锁、没有更多数据和请求失败。","routePath":"/blog/2024/03/02/","lang":"","toc":[{"text":"上滑加载的原理","id":"上滑加载的原理","depth":2,"charIndex":267},{"text":"上滑加载关键代码","id":"上滑加载关键代码","depth":2,"charIndex":625},{"text":"布局代码","id":"布局代码","depth":3,"charIndex":671},{"text":"逻辑代码","id":"逻辑代码","depth":3,"charIndex":926},{"text":"上滑加载的两个注意点","id":"上滑加载的两个注意点","depth":2,"charIndex":991},{"text":"加载锁","id":"加载锁","depth":3,"charIndex":1042},{"text":"没有更多数据","id":"没有更多数据","depth":3,"charIndex":1232},{"text":"请求失败","id":"请求失败","depth":3,"charIndex":1427},{"text":"示例代码","id":"示例代码","depth":2,"charIndex":1617},{"text":"总结","id":"总结","depth":2,"charIndex":1646}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":10,"title":"百亿补贴为什么用 H5？H5 未来会如何发展？","content":"#\n\n23 年 11 月末，拼多多市值超过了阿里。我想写一篇文章《百亿补贴为什么用 H5》，没有动笔；24 年新年，我想写一篇《新的一年，H5\n会如何发展》，也没有动笔。\n\n眼看着灵感就要烂在手里，我决定把两篇文章合为一篇，与大家分享。当然，这些分析预测只是个人观点，如果你有不同的意见，欢迎在评论区讨论交流。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n百亿补贴为什么用 H5#\n\n我们在 Android 手机开发者模式下，开启显示布局边界，可以看到「百亿补贴」是一个完整大框，说明「百亿补贴」在 App 内是\nH5；拷贝分享链接，在浏览器打开，可以看到资源中有 react 名字的 js 文件，说明「百亿补贴」技术栈大概率是 React。\n\n\n\n不只是拼多多，我特地确认了，京东、淘宝的的「百亿补贴」技术栈也是 H5。\n\n\n\n那么，为什么电商巨头会在「百亿补贴」这种重要活动上选择 H5 呢？用 H5 有什么好处呢？\n\n\nH5 技术已经成熟#\n\n第一个原因，也是最基础的原因，就是 H5 技术已经成熟，能够完整地实现功能。具体来说：\n\n浏览器兼容性不断提高#\n\n自 2008 年 HTML5 草案发布以来，截止 2014 年，HTML5 已有 18 年历史。18 年间，主流浏览器对 HTML5、CSS3 和\nJavaScript 的标准语法兼容性一直持续改进，22 年微软更是亲手盖上了 IE 棺材板。虽然 Safari（iOS\n浏览器）的兼容性仍然备受诟病，但总体来说兼容成本已经变得可以接受。\n\n主流框架已经成熟#\n\n前端最主流的两大框架 Vue 和 React 已经成熟。它们的成熟体现在多个方面：\n\n * 从时间的角度看，截止 2024 年，React 已经发布了 11 年，而 Vue 已经发布了 10 年。经过多年的发展，前端开发者已经非常熟悉 React\n   和 Vue，能熟练地应用它们进行开发。\n * 从语法的角度看，自 React16.8 发布 Hooks，以及 Vue3 发布 Composition API\n   以来，两大框架语法基本稳定，不再有大的变化。前端开发者可以更加专注于业务逻辑，无需过多担心框架语法的变动。\n * 从未来发展方向看，React 目前致力于推广 React Server Component 1；Vue 则在尝试着无 VDom 的 Vapor\n   方向，并计划利用 Rust 重写 Vite 2。这表明旧领域不再有大的颠覆，两大框架已经正寻求新的发展领域。\n\n混合开发已经成熟#\n\n混合开发是指将原生开发（Android 和 iOS）和 Web 开发结合起来的一种技术。简而言之，它将 H5\n嵌入到移动应用内部运行。近些年，业界对混合开发的优势和缺陷已经有清晰的认识，并针对其缺陷进行了相应的优化。具体来说：\n\n * 混合开发的优势包括开发速度快、一套代码适配 Android 和\n   iOS，以及实现代码的热更新。这意味着程序员能更快地编写跨平台应用，及时更新应用、修复缺陷；\n * 混合开发的缺陷则是性能较差、加载受限于网络。针对这个缺陷，各大 App、以及云服务商如阿里云 3 和腾讯云 4\n   都推出了自己的离线包方案。离线包方案可以将网页的静态资源（如 HTML、CSS、JS、图片等）缓存到本地，用户访问 H5\n   页面时，可以直接读取本地的离线资源，从而提升页面的加载速度。可以说，接入离线包后，H5 不再有致命缺陷。\n\n前端基建工具已经成熟#\n\n近些年来，业界最火的技术话题之一，就是用 Rust 替代前端基建，包括：用 Rust 替代 Webpack 的 Rspack；用 Rust 替代 Babel 的\nSWC；用 Rust 替代 Eslint 的 OxcLint 等等。\n\n前端开发者对基建工具抱怨，已经从「这工具能不能用」，转变为「这工具好不好用」。这种「甜蜜的烦恼」，只有基建工具成熟后才会出现。\n\n综上所述，浏览器的兼容性提升、主流框架的成熟、混合开发的发展和前端基建工具的完善，使 H5 完全有能力承载「百亿补贴」业务。\n\n\nH5 开发成本低#\n\n前文我们已经了解到，成熟的技术让 H5 可以实现「百亿补贴」的功能。现在我们介绍另一个原因——H5 开发成本低。\n\n「百亿补贴」需要多个 H5#\n\n「百亿补贴」的方式，是一个常住的 H5，搭配上多个流动的 H5。（「常住」和「流动」是我借鉴「常住人口」和「流动人口」造的词）\n\n * 常住 H5 链接保持不变。站外投放的链接基本都是常住 H5 的，站内首页入口链接也是常住 H5 的，这样方便用户二次访问。\n\n * 流动 H5 链接位于常住 H5 的不同位置，比如头图、侧边栏等。时间不同、用户不同、算法不同，流动 H5 的链接都会不同，流动 H5\n   可以区分用户，方便分发流量。\n   \n   具体来看，拼多多至少有三个流量的分发点，第一个是可点击的头图，第二个是列表上方的活动模块，第三个是右侧浮动的侧边栏，三者可以投放不同的链接。最近就分别投放\n   3.8 女神节链接、新人链接和品牌链接：\n\n\n\n「百亿补贴」需要及时更新#\n\n不难想到，每到一个节日、每换一个品牌，「百亿补贴」就需要更新一次。\n\n有时还需要为一些品牌定制化 H5 代码。如果使用其他技术栈，排期跟进通常会比较困难，但是使用 H5 就能够快速迭代并上线。\n\n\nH5 投放成本低#\n\n我们已经「百亿补贴」使用 H5 技术栈的两个原因，现在来看第三个原因——H5 适合投放。\n\n拼多多的崛起过程中，投放到其他 App\n的链接功不可没。早期它通过微信等社交平台「砍一刀」的模式，低成本地吸引了大量用户。如今，它通过投放「百亿补贴」策略留住用户。\n\nH5 的独特之处，在于它能够灵活地在多个平台上进行投放，其他技术栈很难有这样的灵活性。即使是今天，抖音、Bilibili 和小红书等其他 App\n中，「百亿补贴」的 H5 链接也随处可见。\n\n\n\n拼多多更是将 H5 这种灵活性发挥到极致，只要你有「百亿补贴」的链接，你甚至可以在微信、飞书、支付宝等地方直接查看「百亿补贴」 H5 页面。\n\n\n\n综上所述，能开发、能快速开发、且开发完成后能大量投放，是「百亿补贴」青睐 H5 的原因。\n\n\nH5 未来会如何发展#\n\n了解「百亿补贴」选择 H5 的原因后，我们来看看电商巨头对 H5 未来发展的影响。我认为有三个影响：\n\n\nH5 数量膨胀，定制化要求苛刻#\n\nC 端用户黏性相对较低，换一个 App 的成本微不足道。近年 C\n端市场增长缓慢，企业重点从获取更多的新客变成留住更多的老客，很难容忍用户丢失。因此其他企业投放活动 H5 时，企业必须也投放活动 H5，电商活动 H5\n就变得越来越多。\n\n这个膨胀的趋势不仅仅存在于互联网巨头的 App 中，中小型应用也不例外，甚至像 12306、中国移动、招商银行这种工具性极强的应用也无法幸免。\n\n\n\n随着市场的竞争加剧，定制化要求也变得越来越苛刻，目的是让消费者区分各种活动。用互联网黑话来说，就是「建立用户心智」。在可预见的未来，尽管电商活动 H5\n结构基本相同，但是它们的外观将变得千差万别、极具个性。\n\n\n\n\nSSR 比例增加，CSR 占据主流#\n\n在各家 H5 数量膨胀、竞争激烈的情况下，一定会有企业为提升 H5 的秒开率接入 SSR，因此 SSR 的比例会增加。\n\n但我认为 CSR 依然会是主流，主要是因为两个原因：\n\n 1. SSR 需要额外的服务器费用，包括服务器的维护、扩容等。这对于中小型公司来说是一个负担。\n 2. SSR 对程序员技术水平要求比 CSR 更高。SSR 需要程序员考虑更多的问题，例如内存泄露。使用 CSR\n    在用户设备上发生内存泄露，影响有限；但是如果在服务器上发生内存泄露，则是会占用公司的服务器内存，增加额外的成本和风险。\n\n因此，收益丰厚、技术雄厚的公司更愿意使用 SSR。没有金刚钻别揽瓷器活，总不能向老板汇报结果时，告诉老板「虽然您亏钱了，但是 SSR 真的很酷」。\n\n\nMonorepo 比例会上升，类 Shadcn UI 组件库也许会兴起#\n\n如前所述，H5 的数量膨胀，代码复用就会被着重关注。我猜测更多企业会选择 Monorepo 管理方式。所谓\nMonorepo，简单来说，就是将原本应该放到多个仓库的代码放入一个仓库，让它们共享相同的版本控制。这样可以降低代码复用成本。\n\n定制化要求苛刻，我猜测社区中类似 Shadcn UI 的 H5 组件库或许会兴起。现有的 H5 组件库样式太单一，即使是 Shadcn UI，也很难满足国内\nH5 的定制化需求。然而，Shadcn UI 的基本思路——「把源码下载到项目」，是解决定制化组件难复用的问题的好思路。因此，我认为类似 Shadcn 的 H5\n组件库可能会逐渐兴起。\n\n\n总结#\n\n本文介绍了我认为「百亿补贴」会选用 H5 的三大原因：\n\n * H5 技术已经成熟\n * H5 开发成本低\n * H5 投放成本低\n\n以及电商巨头对 H5 产生的三个影响：\n\n * 数量膨胀，定制化要求苛刻\n * SSR 比例增加，CSR 占据主流\n * Monorepo 比例增加，类 Shadcn UI 组件库也许会兴起\n\n总而言之，H5 开发会越来越专业，对程序员要求会越来越高。至于这种情况是好是坏，仁者见仁智者见智，欢迎大家在评论区沟通交流。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\nFootnotes\n\n 1. 11 岁的 React 正迎来自己口碑的拐点 ↩\n\n 2. Rust! 无VDom! 尤雨溪解析 Vue.js 2024 新特性 ↩\n\n 3. 离线包 | 阿里云 ↩\n\n 4. 离线包 | 腾讯云 ↩","routePath":"/blog/2024/03/03/","lang":"","toc":[{"text":"百亿补贴为什么用 H5","id":"百亿补贴为什么用-h5","depth":2,"charIndex":206},{"text":"H5 技术已经成熟","id":"h5-技术已经成熟","depth":3,"charIndex":441},{"text":"浏览器兼容性不断提高","id":"浏览器兼容性不断提高","depth":4,"charIndex":498},{"text":"主流框架已经成熟","id":"主流框架已经成熟","depth":4,"charIndex":681},{"text":"混合开发已经成熟","id":"混合开发已经成熟","depth":4,"charIndex":1089},{"text":"前端基建工具已经成熟","id":"前端基建工具已经成熟","depth":4,"charIndex":1480},{"text":"H5 开发成本低","id":"h5-开发成本低","depth":3,"charIndex":1740},{"text":"「百亿补贴」需要多个 H5","id":"百亿补贴需要多个-h5","depth":4,"charIndex":1809},{"text":"「百亿补贴」需要及时更新","id":"百亿补贴需要及时更新","depth":4,"charIndex":2156},{"text":"H5 投放成本低","id":"h5-投放成本低","depth":3,"charIndex":2270},{"text":"H5 未来会如何发展","id":"h5-未来会如何发展","depth":2,"charIndex":2630},{"text":"H5 数量膨胀，定制化要求苛刻","id":"h5-数量膨胀定制化要求苛刻","depth":3,"charIndex":2696},{"text":"SSR 比例增加，CSR 占据主流","id":"ssr-比例增加csr-占据主流","depth":3,"charIndex":3016},{"text":"Monorepo 比例会上升，类 Shadcn UI 组件库也许会兴起","id":"monorepo-比例会上升类-shadcn-ui-组件库也许会兴起","depth":3,"charIndex":3373},{"text":"总结","id":"总结","depth":2,"charIndex":3704}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":11,"title":"H5、小程序能用 webp 图片吗？如何判断环境是否支持？","content":"#\n\n最近我在做 H5、小程序的性能优化，其中一项优化是把 H5、小程序的 jpg、png 图片转换为 webp 图片，这是因为相比 jpg、png，webp\n体积更小、传输速度更快。\n\n转换方法很简单，现在各大云服务商基本都提供了方法。比如 腾讯云 只需要在图片 CDN 链接后面拼接一些参数：\n\n * 转换前：https://example-1258125638.cos.ap-shanghai.myqcloud.com/sample.png\n * 转换后：http://example-1258125638.cos.ap-shanghai.myqcloud.com/sample.png?imageMo\n   gr2/format/webp\n\n不过我还是遇到了些小麻烦，从 can I use 查询发现，目前还有少部分浏览器不支持 webp。所以在 H5、小程序使用 webp\n格式图片时，我需要做一些兼容。\n\n\n\n一番研究后，我知道了判断环境是否支持 webp 的几种办法。对这些办法的优劣，我也有自己的观点，于是我便整理了这篇文章。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\ntoDataURL('image/webp')#\n\n\n代码#\n\n第一种 H5 的判断方法，其实是判断 H5 能不能利用 canvas 的 toDataURL() API 得到一张 webp 图片。\n\n\n\n\n原理#\n\n这种方法原理是啥呢？我们可以继续在 Can I use 查询 toDataURL('image/webp') 的兼容性。\n\n\n\n可以看到，兼容 toDataURL('image/webp') 的浏览器、是兼容 webp 浏览器的子集。\n\n\n\n换句话说，这是一种「宁杀错一百，也不放过一个」的方法。举 Safari 浏览器为例子，它其实是可以展示 webp 图片的，但它会被这种\ntoDataURL('image/webp') 方法误伤。\n\n\n\n\n优缺点#\n\n这种方法的优缺点如下:\n\n * 优点：代码短小，且方法是同步的，不影响首屏性能。\n * 缺点：误伤性太高，iOS 的 Safari 浏览器被全部误伤。\n\n\n微信小程序能用吗#\n\n这种判断方法微信小程序可以使用吗？很遗憾不可以。\n\n我们之所以用 toDataURL('image/webp') 判断 H5 能不能使用 webp，前提是我们知道 兼容\ntoDataURL('image/webp') 的浏览器、是兼容 webp 浏览器的子集。\n\n但我在微信官方文档中，没有看到类似 canvas 的 toDataURL('image/webp') 是 webp\n子集的描述。基于此，我判断微信小程序不能用这个方法。\n\n\n加载一张 webp 图片试试，看会不会出错#\n\n\n代码#\n\n第二种 H5 的判断方法，是直接异步加载一张 webp 格式的图片。如果加载成功，证明环境能支持 webp；如果加载失败，证明环境不支持 webp。\n\n\n\n\n原理#\n\n这种方法来源于 Google 官方文档，webp 其实支持四个功能，无损压缩、有损压缩、透明度和动画，每个功能对应了一张 webp 图片：\n\n\n\n如果对四种功能都进行判断的话，代码会变得很臃肿。所以实际开发中，基本只选择一张 webp 的图片。\n\n从 Can I use 查询结果来看，浏览器要么是先支持 webp 的有损压缩，再支持 webp\n的无损压缩、透明度和动画；要么是有损压缩、无损压缩、透明度和动画一起支持。因此，我们往往选择一张支持动画的 webp 图片，用它去试探浏览器是否支持 webp\n格式。\n\n\n优缺点#\n\n * 优点：基本不会误伤；\n * 缺点：异步加载，可能无法及时转换图片链接、影响首屏性能。如果 H5 不选择 CSR，而选择 SSR，则无法使用此方法。\n\n\n微信小程序能用吗#\n\n这种方法小程序可以用吗？理论上可以，但不推荐使用。\n\n微信官方文档上虽然提到了 createImage 方法，但我实际测试发现，这个方法竟然没了 (* ￣︿￣)。\n\n\n\n我们使用此方法，就必须在 wxml 中手动写一个 image 标签，再给它绑定 onload 和 onerror 事件。这意味着：\n\n * 如果我们把这个标签放到自己封装的 WebpImage 组件中，WebpImage 被多次使用后，小程序页面会多出很多额外的节点。\n * 如果我们把这个标签放到页面上（比如 index 页面），就需要给每一个用户可能直接访问的页面都加上这个标签。也会出现很多额外的节点。\n\n因此不推荐使用。\n\n\n直接判断版本#\n\n\n代码#\n\n第三种方法，就是直接判断版本号，Android 版本大于 4.2.0，iOS 大于 14.0.0 时，认为 webp 可用。\n\nH5 通过 ua 获取系统版本号的文章很多，我们这里给出小程序的代码。\n\n\n\n\n原理#\n\n我们已经通过 Can I use 知道：\n\n * Android 4.2.0 以下，iOS 14 以下的浏览器不支持 webp。\n\n又从 微信小程序 image 组件文档 里知道：\n\n * 基础库版本 >= 2.9.0 支持 webp。\n\n那么干脆把所有条件都做一个组合，就得到了上述代码，其中 compareVersion() 是 微信官方文档 中比较版本号的代码。\n\n\n优缺点#\n\n * 优点：同步判断、不影响首屏性能；误伤范围小；且 CSR 和 SSR 可用。\n * 缺点：无明显缺点。\n\n\n总结#\n\n本文介绍了 H5、小程序使用 webp 格式图片时，判断环境是否支持的方法。\n\n * 方法一：利用 toDataURL('image/webp') 判断。H5 支持，但是会误伤大部分浏览器；小程序不支持。\n * 方法二：利用一张小体积的 webp 图片试探。H5 CSR 时支持，但因为方法是异步的、可能影响首屏性能；H5 SSR\n   时不支持；小程序支持，但实现不优雅。\n * 方法三：利用版本号判断。H5 和浏览器均支持，是最佳实现方案。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/03/10/","lang":"","toc":[{"text":"toDataURL('image/webp')","id":"todataurlimagewebp","depth":2,"charIndex":522},{"text":"代码","id":"代码","depth":3,"charIndex":549},{"text":"原理","id":"原理","depth":3,"charIndex":625},{"text":"优缺点","id":"优缺点","depth":3,"charIndex":853},{"text":"微信小程序能用吗","id":"微信小程序能用吗","depth":3,"charIndex":937},{"text":"加载一张 webp 图片试试，看会不会出错","id":"加载一张-webp-图片试试看会不会出错","depth":2,"charIndex":1167},{"text":"代码","id":"代码-1","depth":3,"charIndex":1192},{"text":"原理","id":"原理-1","depth":3,"charIndex":1276},{"text":"优缺点","id":"优缺点-1","depth":3,"charIndex":1540},{"text":"微信小程序能用吗","id":"微信小程序能用吗-1","depth":3,"charIndex":1625},{"text":"直接判断版本","id":"直接判断版本","depth":2,"charIndex":1938},{"text":"代码","id":"代码-2","depth":3,"charIndex":1948},{"text":"原理","id":"原理-2","depth":3,"charIndex":2057},{"text":"优缺点","id":"优缺点-2","depth":3,"charIndex":2249},{"text":"总结","id":"总结","depth":2,"charIndex":2311}],"domain":"","frontmatter":{},"version":""},{"id":12,"title":"仿百亿补贴，H5 中图片先模糊后清晰的效果如何实现？","content":"#\n\n逛过拼多多百亿补贴的同学，可能有一个体会，那就是图片加载非常快，很多图片瞬间就出现了，这是为什么呢？\n\n答案是：百亿补贴先加载了一张模糊小图、再加载了一张清晰大图。用户很难感知到模糊到清晰的过程，误以为图片加载很快。\n\n接下来我会先给出证据、再分析原理、提供关键代码，之后给百亿补贴的方法做扩展、补充，最后做一个简单总结。\n\n当然，图片优化是涉及知识很琐碎、广泛，先模糊小图后清晰大图只是其中一种手段，百亿补贴肯定还使用了其他技术。 如果朋友你想了解更多相关手段，可以点赞关注我。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n证据#\n\n我们可以有三个证据，可以证明：百亿补贴是先加载模糊小图，再加载清晰大图。\n\n第一个证据：我们可以在控制台把网络调整成 Slow 3G，然后强制刷新浏览器，可以看到拼多多的图片，存在一个模糊到清晰的过程。\n\n\n\n\n\n第二个证据：我们在控制台查看网络请求，可以看到请求中有一张小商品图、一张大商品图。\n\n\n\n第三个证据：我们在控制台找到图片元素，可以看到图片元素是一个 a 标签包裹着一个 img 标签。其中 a 标签的 background-image\n是模糊小图链接，img 标签的 src 是清晰大图链接。\n\n\n\n\n原理及代码#\n\n要想知道先模糊、后清晰的原理，我们得先看一张 img 标签是如何加载图片的，如下所示：开始时 img 占据的区域为空白，随着图片的逐步加载，空白部分被慢慢填充。\n\n\n\n准确地说，img 标签占据的区域，不是「空白」而是「透明」。这意味着，我们只需要给 img 标签设置一张模糊小图链接，给 img 标签的 src\n设置清晰大图链接，当大图慢慢加载时，清晰图片会一步步遮挡住模糊图片，从而实现模糊到清晰的效果。\n\n\n\n关键代码如下，非常简单：\n\n\n\n\n\n获取小图链接也很简单，现在各大云服务商基本都提供了方法。比如 阿里云 只需要在图片 CDN 链接后面拼接一些参数，就可以得到图片缩放的小图。\n\n * 缩放前：https://oss-console-img-demo-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/exa\n   mple.jpg\n * 缩放后：https://oss-console-img-demo-cn-hangzhou.oss-cn-hangzhou.aliyuncs.com/exa\n   mple.jpg?x-oss-process=image/resize,w_100,m_lfit\n\n\n更进一步，加模糊滤镜#\n\n百亿补贴的做法，对于电商活动 H5 已经足够。但更讲究氛围感的 H5，也许会觉得百亿补贴的效果很粗糙。针对这种\nH5，我们可以更进一步，给小图加上模糊滤镜，等到大图加载完成时再去除模糊滤镜，并增加 transition 的过渡效果，就得到如下效果：\n\n\n\n关键代码为：\n\n\n\n\n\n\n总结#\n\n本文分析了百亿补贴图片加载非常快的主要原因：先加载模糊小图，再加载清晰大图。并给出了关键证据，以及实现原理和代码。最后在百亿补贴方法的基础上，增加模糊滤镜，实现\n了更有氛围感的效果。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/03/23/","lang":"","toc":[{"text":"证据","id":"证据","depth":2,"charIndex":294},{"text":"原理及代码","id":"原理及代码","depth":2,"charIndex":558},{"text":"更进一步，加模糊滤镜","id":"更进一步加模糊滤镜","depth":2,"charIndex":1092},{"text":"总结","id":"总结","depth":2,"charIndex":1246}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":13,"title":"对比小红书与电商三巨头的瀑布流，H5 瀑布流实现方案应该如何选择？","content":"#\n\n瀑布流布局，我们既能在小红书这类图文网站看到，也能在拼多多、京东和淘宝这类电商网站看到。小红书的瀑布流，是利用绝对定位计算高度实现。而电商三巨头的瀑布流，则是利\n用 Flex 布局实现。\n\n那么，同样是瀑布流，两种实现方式的优点、缺点是什么呢？如果想用 H5 实现瀑布流，应该用哪一种方案呢？\n\n\n\n\n\n本文中，我会首先介绍瀑布流是什么，接着我会介绍小红书瀑布流实现方式，并给出示例代码；然后，我会给出电商三巨头瀑布流实现方式，并给出示例代码；最后，我会做一个两种\n方案的对比总结。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n瀑布流是什么#\n\n瀑布流是一种宽度相同，高度不同的卡片布局方式。\n\n如下图所示，传统布局中宽度相同、高度不同的卡片排列在一起时，会出现大量空白。这样既浪费了空间、又不美观。\n\n\n\n而瀑布流布局，则可以有效利用空白的空间，实现美观的效果。\n\n\n\n在开始介绍瀑布流如何实现之前，我们先给出一个工具函数，这个工具函数可以生成长度为 len 的图片数组，且每张图片都是 svg，宽度范围在 300px 到\n400px，高度在 250px 到 500px。我们会使用数组中的图片实现瀑布流布局。\n\n\n\n\n\n\n小红书的瀑布流#\n\n\n原理#\n\n假如小红书需要实现左、中、右三列的瀑布流，它会先找高度最低的列放置图片，如果相同高度的列，则按照从左到右的顺序放置。\n\n如下图所示，初始时每一列初始高度都为 0，所以图片应该先放最左侧的列。\n\n\n\n放完第 0 张图片后，此时中、右两列高度为 0，所以第 1 张图放在中列。\n\n\n\n放完第 1 张图片后，此时右列高度为 0，是最低的列，所以第 2 张图放在右列。\n\n\n\n放完第 2 张图片后，此时右列高度最低，所以第 3 张图放在右列。\n\n\n\n放完第 3 张图片后，此时中、右两列高度相同，所以第 4 张图放在中列。\n\n\n\n放完第 4 张图片后，此时右列高度最低，所以第 5 张图片放在右列。\n\n\n\n我们可以打开小红书网页版的控制台，在控制台可以检查元素，可以看到它的布局完全符合这个规律。\n\n\n\n\n关键代码解释#\n\n说完原理，我们现在来看下关键代码，代码整体思路，可以理解为先插入图片，再设置图片位置。\n\n插入图片#\n\n先看基础布局，布局非常简单，就是一个定位为 relative 的盒子元素。之后我们会在盒子中元素中一张张插入图片，每一个图片的定位都是 absolute。\n\n\n\n插入图片的 JavaScript 代码如下，入参 items 可以前文提到的工具函数 getItems() 生成。至于 imgWidth\n则是每一列的宽度，我们可以自行指定。\n\n我们在 getItems() 中生成了宽高不一的图片，当图片实际显示在屏幕上时，它们的宽度都会缩写为 imgWidth，因此我们也要将它们的高度等比例缩放。\n\n我们的做法就是计算出 imgWidth 与每一张图片 width 的比例 ratio，然后用每一张图片的 height * ratio 获得等比例缩放的高度。\n\n\n\n设置图片位置#\n\n设置图片位置之前，我们需要知道瀑布流被分为几列，以及每一列的间隙。\n\n如下图所示，瀑布流的列数 colNumber = Math.floor(boxWidth / imgWidth)，间隙的列数则是 colNumber - 1。\n\n\n\n\n\n接下来，我们需要设置每一张图片的位置。因为图片定位是 absolute，所以如果要设置位置，我们需要知道每一张图片到顶部的距离 top，以及到左侧的距离\nleft。\n\nsetPosition() 函数有四个入参：\n\n * items 代表图片数组，也就是之前提到的工具函数 getItems() 的结果。\n * colNumber 代表瀑布流有几列，之前 getColumnsInfo() 结果中包含这个结果。\n * colSpace 代表瀑布流列与列之间的间隙，之前的 getColumnsInfo() 结果中也包含这个结果。\n * rolSpace 代表瀑布流行与行之间的间隙，这个间隙我们可以自行设置，我们也设置 rolSpace 等于 colSpace。\n\n我们在瀑布流原理一节已经知道，设置瀑布流图片时，要找到瀑布流高度最低的列放置图片，如果相同高度的列，则按照从左到右的顺序放置。为此，在\nsetPosition() 函数中，我们设置了一个长度为 colNumber 的数组，数组保留了一行瀑布流图片的 top 的数组。\n\n需要注意的是，我们这里用 Math.min.apply(null, nextTops) 找出最低 top 的下标。\n\n每摆放一个图片，nextTops 都会更新对应下标的 top 值。下一行图片的 top 值，就是本行图片的 top + 本行图片的高度 + 行之间的间隙。至于\nleft 值，则是（图片本身的宽度 + 列之间的间隙）* 下标。\n\n\n\n重新设置位置#\n\n我们可以把设置位置的函数封装为 init() 函数，并给页面宽高变化的事件绑定上 init() 函数，这样就能实现当窗口变化时，瀑布流也重新改变的效果。\n\n我们实现的瀑布流效果如下：\n\n\n\n\n完整代码#\n\nabsolute-waterfall | codepen\n\n\n电商三巨头的瀑布流#\n\n\n原理#\n\n电商三巨头中，我们以京东首页为例。我们也是需要找到瀑布流中高度最低的一例，然后把图片放置到这一列中。不同的是，小红书的绝对定位布局中，瀑布流的列只是一个概念，并\n没有实际的 Dom 元素；而京东的瀑布流的列，则是一个实际的 Dom 元素。\n\n当列变为 Dom 元素之后，我们便不再需要计算 top 和 left 值，只需要知道目前那一列比较低，就把图片元素插入到哪一列中。\n\n我们可以打开京东网站的控制台，并检查它瀑布流的元素：\n\n\n\n\n关键代码解释#\n\n之前我们提到，小红书的关键代码可以认为是「为先插入图片，再设置图片位置」。而京东的关键代码则可以理解为「先算出图片要插入的列，再插入图片」。\n\n和小红书的关键代码类似，我们先是让图片的高度做了一个等比例的缩放。\n\n为了确认图片应该插入到左右哪一列中，我们分别设置了\nleftHeight、rightHeight。如果左列较低，就把图片插入到左列，并更新左列的高度；如果右列较低，就把图片插入到右列，并更新右列的高度。如此循环往\n复，就实现了双列的瀑布流。\n\n\n\n双列瀑布流可以结合我之前的文章 H5 上滑加载（触底加载）如何实现，得到如下效果。\n\n\n\n\n完整代码#\n\nflex-waterfall | codepen\n\n\n对比总结#\n\n现在我们对小红书的瀑布流和电商三巨头的瀑布流做一个对比总结：\n\n           小红书    拼多多、京东、淘宝\n实现方式       绝对定位   Flex 布局\n计算量        大      小\n复杂程度       高      低\n列数是否可以改变   是      否\n\n如果瀑布流的列数不会改变，那么推荐使用 Flex 布局，它的计算量更小、复杂程度更低；如果瀑布流的列数需要改变，那么推荐使用绝对定位实现。\n\n通常来说，C 端 H5 总是会保留两列，用 Flex 布局更合适。但是有部分产品会推出单双列切换的功能，此时用绝对定位方式会更好。\n\n\n总结#\n\n本文我们介绍了小红书和电商三巨头（拼多多、京东、淘宝）的瀑布流实现方案，并给出了两种实现瀑布流的代码，最后我们做了一个对比，无论是实现计算量还是难度，Flex\n布局均比较简单。但是 Flex 布局无法实现列数切换的情况。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/04/08/","lang":"","toc":[{"text":"瀑布流是什么","id":"瀑布流是什么","depth":2,"charIndex":295},{"text":"小红书的瀑布流","id":"小红书的瀑布流","depth":2,"charIndex":544},{"text":"原理","id":"原理","depth":3,"charIndex":555},{"text":"关键代码解释","id":"关键代码解释","depth":3,"charIndex":909},{"text":"插入图片","id":"插入图片","depth":4,"charIndex":963},{"text":"设置图片位置","id":"设置图片位置","depth":4,"charIndex":1303},{"text":"重新设置位置","id":"重新设置位置","depth":4,"charIndex":2075},{"text":"完整代码","id":"完整代码","depth":3,"charIndex":2180},{"text":"电商三巨头的瀑布流","id":"电商三巨头的瀑布流","depth":2,"charIndex":2218},{"text":"原理","id":"原理-1","depth":3,"charIndex":2231},{"text":"关键代码解释","id":"关键代码解释-1","depth":3,"charIndex":2455},{"text":"完整代码","id":"完整代码-1","depth":3,"charIndex":2741},{"text":"对比总结","id":"对比总结","depth":2,"charIndex":2775},{"text":"总结","id":"总结","depth":2,"charIndex":3068}],"domain":"","frontmatter":{},"version":""},{"id":14,"title":"仿拼多多现金大转盘，H5 抽奖转盘如何实现？","content":"#\n\n电商应用中我们常常看到抽奖转盘活动，比如拼多多的「抽奖大转盘」：点击中央的抽奖按钮，转盘开始旋转，一段时间后指针停止在奖品上。\n\n\n\n这个效果如果用 H5 应该怎么实现呢？\n\n本文我会先说明如何实现转盘布局，再介绍如何让转盘旋转，接着解释如何控制中奖概率，最后给出完整的代码，并做一个总结。最终效果如下：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\nCSS 旋转相关的语法#\n\n实现转盘布局之前，我们先来复习 CSS 与旋转有关的语法。\n\n * transform 的 rotate() 函数可以控制旋转角度。比如 transform: rotate(60deg); 是顺时针旋转 60\n   度，transform: rotate(-60deg); 是逆时针旋转 60 度。\n * transform-origin 可以控制旋转中心。比如 transform-origin: right bottom; 是以元素右下角为旋转中心。\n\n举个例子，下面代码中 item0 和 item1 两个矩形以自己的右下角为中心，逆时针旋转了 0 度和 60 度。\n\n\n\n\n\n\n转盘的布局#\n\n\n有问题的思路#\n\n复习完语法，你可能会想 6 个矩形围着自己右下角旋转，似乎能实现转盘布局。\n\n代码如下，其中 --i 和 --clr 是 CSS 的变量，方便我们计算角度、获取颜色。\n\n\n\n但这种思路是有问题的，如图所示，6 个矩形依次逆时针旋转，会导致第 5 个矩形覆盖在第 0 个矩形上，无法实现转盘布局。\n\n\n\n\n正确的思路#\n\n6 个矩形依次逆时针旋转的思路虽然有问题，但也能给我们一些启发。\n\n我们把 6 个矩形拆成左、右两部分：\n\n * 左边是 3 个矩形，以矩形右下角为中心逆时针旋转 0 度、60 度和 120 度，再加上 overflow: hidden; 就得到左半圆。\n * 右边是 3 个矩形，以矩形左下角为中心顺时针旋转 0 度、60 度和 120 度，再加上 overflow: hidden; 就得到右半圆。\n * 拼接左右两个半圆，就得到一个完整的转盘。\n\n\n\n关键代码如下：\n\n\n\n\n转盘的旋转#\n\n我们已知晓转盘的布局如何实现，至于中央按钮和奖品都可以用绝对定位实现，这里我就不再详细说明。一起来看看如何控制转盘的旋转。\n\n\n旋转的原理#\n\n控制转盘旋转很简单，我们只旋转外层的容器 box 即可。如下图所示，在 Chrome 元素控制台中，我们逐渐增加 transform: rotate(0deg)\n的取值，就实现了转盘的顺时针旋转。\n\n\n\n需要注意的是，当容器 box 旋转时，会带动着中央按钮 btn 一起旋转。为了实现 box 旋转而 btn 保持不变的效果，box\n顺时针旋转多少度，我们就需要让中央按钮逆时针旋转多少度。因此后续旋转的 js 代码中，我们会有如下代码：\n\n\n\n\n基础代码#\n\n现在我给出基础的旋转代码：\n\n\n\n代码主要分为 2 部分，第 1 部分绑定 btn 点击事件，第 2 部分控制 box 和 btn 的旋转。\n\n我们先看第 1 部分，这部分我们会先获取一个 0 ~ 5 的随机下标 randomIndex，利用 randomIndex * 60\n来计算旋转的角度（一个奖品扇形区域是 60 度）。之所以要再加上 30 度，是因为我们希望旋转结束之后，指针指向中奖区域的中轴线。\n\n再看第 2 部分，我们设置了 1800 度的基础角度 base（因为 1800 = 360 * 5，也就是至少要旋转 5\n圈后才会停止）。又设置了一个计时器，每过 16 秒就旋转 30 度，直到超过目标度数后才停止旋转。\n\n代码的效果如下：\n\n\n\n\n改善体验#\n\n基础旋转代码虽然实现了效果，但体验还有待改善。主要有两点需要优化。\n\n旋转时，按钮不能被再次点击#\n\n开始旋转时，此时按钮应该不能被再次点击。只有旋转结束后，按钮才能被再次点击，因此我们需要增加一个点击锁 clickLock。关键代码如下：\n\n\n\n开始时 clickLock 为 false，转盘旋转时 clickLock 会被置为 true，停止旋转时 clickLock 会被置为\nfalse。这样转盘旋转期间，如果用户继续点击按钮，点击事件会被拦截、不再触发旋转函数 run。\n\n旋转时，速度需要越来越慢#\n\n基础代码实现的转盘，转盘旋转的速度是恒定的。当旋转结束时，转盘会瞬间停止，这会让用户感觉很突兀。正常来说，转盘的旋转速度应该越来越慢。\n\n旋转速度越来越慢，可以用旋转的角度越来越小简介实现，越来越小的旋转角度可以用下面的公式计算：\n\n\n\n * current 是已经旋转的角度。\n * step 是在 current 基础上，下一次转动需要增加的角度。\n * ratio 是一个比例。\n\n从公式中可以看出，随着 current 越来越大，step 会越来越小，也就是下一次转动的角度会越来越小。\n\n我们把公式写成代码，假设每 16ms 需要旋转一定角度，最终要旋转 1800 度：\n\n\n\n此段代码的打印的 step 如下，不难看出 step 变得越来越小了。\n\n\n\n上述代码可以应用到基础代码中，从而让转盘的旋转速度越来越慢。\n\n\n中奖的概率#\n\n之前旋转角度，我们是先获取了 0 ~ 5 之间的一个随机下标（此下标就是奖品的下标），然后计算了旋转角度。这时每个奖品的中奖概率都是 20%。\n\n但抽奖一般都需要控制中奖的概率，这个该怎么实现呢？\n\n在抽奖转盘中，我们可以利用权重的方式控制抽奖概率。\n\n假设我们有 6 个奖项，需要控制奖品 0 ~ 奖品 4 的中奖概率都是 1%，而奖品 5 的中奖概率是 95%，我们应该如何做呢？\n\n控制中奖概率的代码如下所示：\n\n\n\n我们先给出了一个 weights 数组，又获取了一个 100 以内的随机数 random，并对 random 向下取整\n\n * random 为 0 的概率是 1%，因为小于 1 的数都被向下取整为 0；\n * random 为 1 的概率是 1%，因为大于 1 小于 2 的数都被向下取整为 1；\n * random 为 2 的概率是 1%，因为大于 2 小于 3 的数都被向下取整为 2；\n * random 为 3 的概率是 1%，因为大于 3 小于 4 的数都被向下取整为 3；\n * random 为 4 的概率是 1%，因为大于 4 小于 5 的数都被向下取整为 4；\n * random 大于 5 小于 100 的概率则是 95%。\n\n我们把 random 插入到 weights 数组中，再从小到大排序，此时 random 对应的下标就是奖品下标。\n\n\n完整代码#\n\nturntable | codepen\n\n\n总结#\n\n本文说明了 H5 如何实现抽奖转盘：\n\n * 转盘的布局：布局时要将转盘拆分为左、右两部分，最后合并为一个转盘。\n * 转盘的旋转：改变转盘容器的旋转角度，可以实现转盘的旋转。加载锁，旋转速度越变越慢可以改善转盘的使用体验。\n * 中奖的概率：权重数组可以控制中奖概率。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/04/17/","lang":"","toc":[{"text":"CSS 旋转相关的语法","id":"css-旋转相关的语法","depth":2,"charIndex":208},{"text":"转盘的布局","id":"转盘的布局","depth":2,"charIndex":515},{"text":"有问题的思路","id":"有问题的思路","depth":3,"charIndex":524},{"text":"正确的思路","id":"正确的思路","depth":3,"charIndex":685},{"text":"转盘的旋转","id":"转盘的旋转","depth":2,"charIndex":934},{"text":"旋转的原理","id":"旋转的原理","depth":3,"charIndex":1006},{"text":"基础代码","id":"基础代码","depth":3,"charIndex":1239},{"text":"改善体验","id":"改善体验","depth":3,"charIndex":1577},{"text":"旋转时，按钮不能被再次点击","id":"旋转时按钮不能被再次点击","depth":4,"charIndex":1619},{"text":"旋转时，速度需要越来越慢","id":"旋转时速度需要越来越慢","depth":4,"charIndex":1827},{"text":"中奖的概率","id":"中奖的概率","depth":2,"charIndex":2208},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":2813},{"text":"总结","id":"总结","depth":2,"charIndex":2842}],"domain":"","frontmatter":{"tags":["H5"]},"version":""},{"id":15,"title":"仿物美超市，H5 列表滚动回弹效果如何实现？","content":"#\n\n最近有朋友问我，多点 App（物美超市的 App）商品列表的上拉回弹效果，用 H5 怎么实现？他知道 iOS 的 H5 原生滚动有回弹效果，Android 的\nH5 没有，希望 Android 能和 iOS 表现一致。\n\n\n\n思索过后，我发现这已经不是普通的原生滚动了，必须要出重拳，得用 CSS 的 translate 模拟一套滚动。\n\n我实现了下拉/上拉滚动回弹，效果如下：\n\n\n\n本文我会先介绍基础的 translate 模拟滚动，再逐步完善代码，最后做一个总结、并推荐一个工具库。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n基础代码#\n\n我们不准备用原生滚动，那么就需要给能滚动的容器添加 overflow: hidden;，基础布局代码如下：\n\n外层的 box 是容器，它被设置了 overflow: hidden。内层的 content 是需要滚动的内容，包裹着三部分：下拉提示（pulldown\n↓）、列表和上拉提示（pullup ↑）。\n\n\n\n基础逻辑代码如下：\n\n * 我们在用户手指刚触摸屏幕时（touchstart），记住了手指的开始位置 startY；\n * 用户手指移动时（touchmove），我们用手指当前的位置（currentY），减去手指开始的位置，得到手指移动的距离（diffY），并实时赋值给\n   content 的 translateY，这样就实现手指上滑/下滑多少距离，content 就上滑/下滑多少距离；\n * 用户停止触摸屏幕时（touchend），我们记住 content 现在移动的位置（lastY）。用户下次滚动 content 时会在 lastY\n   的基础上继续滚动。\n\n\n\n效果如下：\n\n\n\n可以看到，基础代码有个很明显的缺陷。content 很容易被完全移动到 box 外，box 内部便只能看到一片空白。\n\n\n设置下拉/上拉的最终值#\n\n为了解决 content 可以移动到 box 之外的缺陷，我们可以在用户手指离开屏幕时，对 content 的最终值做一个判断。\n\n改动代码如下：\n\n * 我们计算了 content 能上拉的最大距离（maxTranslateY），它是 content 自身的高度减去 box 的高度。（如果 content\n   的高度小于等于 box 的高度，根本无法上拉滚动）。\n\n * 用户下拉时（diffY > 0），如果最终 content 的位置（lastY + diffY）不是负数，说明 content 顶部已经离开了 box\n   的上边界。\n   \n   \n   \n   用户放手时，我们需要让 content 顶部重新贴着 box 的上边界，于是设置 lastY = 0，并设置了 content 的 translateY\n   为 0px。\n\n * 用户上拉时（diffY < 0 时），如果 content 的位置（lastY + diffY） 超过了上拉的最大距离（lastY + diffY <\n   -maxTranslateY），说明 content 的底部已经离开了 box 的下边界。\n   \n   \n   \n   用户放手时，我们需要让 content 底部重新贴着 box 的下边界，于是设置 lastY = -maxTranslateY，并设置了 content\n   的 translateY 为 ${-maxTranslateY}px。\n\n\n\n效果如下：\n\n\n\n\n设置下拉/上拉的限制#\n\n虽然现在我们下拉、上拉 content 时，最终 content 肯定不会再超出 box\n边界。但这样的效果并不美观，一般来说，下拉、上拉的距离都会有一个限制，现在我们就来添加这个限制。\n\n改动代码如下：\n\n * 我们首先定义了下拉和上拉的限制距离 buffer，这个值可以按照个人喜好定，我这里把它定位 10vh （window.innerHeight /\n   10）只是觉得这个距离比较美观。\n\n * 用户下拉时（diffY > 0），content 的顶部最多只能离开 box 的顶部 buffer 大小的距离，也就是 lastY 最大为\n   buffer，diffY 的值就变为了 buffer - lastY。\n\n * 用户上拉时（diffY < 0），content 的位置最多为 -(maxTranslateY + buffer)，diffY 的值就变了\n   -(maxTranslateY + buffer) - lastY。\n\n\n\n有了限制后，效果美观多了：\n\n\n\n\n完整代码#\n\n完整代码如下，你可以在 codepen 或者码上掘金上查看。需要注意，代码只考虑了移动端场景，如果你是电脑访问，需要 F12 打开手机模拟器查看。\n\n * codepen: https://codepen.io/lijunlin2022/pen/KKYYOdg\n\n * 码上掘金：https://code.juejin.cn/pen/7368096483704307738\n\n\n总结与推荐#\n\n本文我介绍了如何用 css 的 translate 模拟滚动，在基础代码上，我设置了下拉/上拉的最终值，下拉/上拉的限制，得到了一个可以回弹的滚动列表。\n\n不过，自己用 css 的 translate 模拟滚动时，考虑各种距离实在繁琐。如果有朋友想在生产环境使用，推荐 better-scroll\n这个插件，它和本文原理类似，也是利用 translate 模拟了一套滚动。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/05/07/","lang":"","toc":[{"text":"基础代码","id":"基础代码","depth":2,"charIndex":298},{"text":"设置下拉/上拉的最终值","id":"设置下拉上拉的最终值","depth":2,"charIndex":821},{"text":"设置下拉/上拉的限制","id":"设置下拉上拉的限制","depth":2,"charIndex":1484},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":1943},{"text":"总结与推荐","id":"总结与推荐","depth":2,"charIndex":2139}],"domain":"","frontmatter":{},"version":""},{"id":16,"title":"仿微信读书，H5 翻转卡片如何实现？","content":"#\n\n我最近刷微信读书时，留意到它的推荐卡片会翻转，这个效果该怎么做呢？\n\n\n\n本文我会先介绍翻转卡片的布局、动画，再并给出完整代码，最后做一个总结。最终效果如下：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n布局代码#\n\n我们先看布局，实现翻转卡片需要要把两个元素背靠背贴在一起，就像汉堡包的面饼中间不夹蔬菜、肉饼一样。\n\n代码如下，有一个盒子 box 里面装着两个元素 front 的 back，front 用来做卡片的正面，back 用来做卡片的背面。\n\n\n\nbox 是相对定位，而 front，back 则是绝对定位，这意味着 front 和 back 是重叠的。\n\n我们让 back 绕着 Y 轴逆时针旋转了 180 度 —— rotateY(-180deg)，并给 front 和 back 都设置了背面不可见属性 ——\nbackface-visibility: hidden; 属性，便实现了卡片的背靠背效果。\n\n\n逻辑代码#\n\n当点击按钮旋转时，我们每次都让 front 和 back 旋转 180 度。\n\n\n\n此外，我们还需要给 front 和 end 添加过渡效果：\n\n\n\n这样当卡片每次旋转时，都能够有相关动画。\n\n\n完整代码#\n\n完整代码如下，你可以在 codepen 或者码上掘金上查看。\n\ncodepen: https://codepen.io/lijunlin2022/pen/yLrJMZL\n\n码上掘金: https://code.juejin.cn/pen/7370534206583898150\n\n\n总结#\n\n本文首先介绍了翻转卡片的布局：两个元素 front、back 先通过绝对定位重叠，再让 back 绕 Y 轴旋转 180 度，实现 front 和 back\n背对背的效果；\n\n然后介绍了翻转卡片的动画：每次需要旋转时，都让 front 和 back 绕着 Y 轴旋转 180 度。\n\n最终实现了类似微信读书推荐卡片的翻转效果。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/05/17/","lang":"","toc":[{"text":"布局代码","id":"布局代码","depth":2,"charIndex":135},{"text":"逻辑代码","id":"逻辑代码","depth":2,"charIndex":445},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":550},{"text":"总结","id":"总结","depth":2,"charIndex":698}],"domain":"","frontmatter":{},"version":""},{"id":17,"title":"仿今日头条，H5 循环播放的通知栏如何实现？","content":"#\n\n我们在各大 App 活动页面，经常会看到循环播放的通知栏。比如春节期间，我就在今日头条 App\n中看到了如下通知：「春节期间，部分商品受物流影响延迟发货，请耐心等待，祝你新春快乐！」。\n\n\n\n那么，这种循环播放的通知栏如何实现呢？本文我会先介绍它的布局、再介绍它的逻辑，并给出完整的代码。最终我实现的效果如下：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n布局代码#\n\n我们先看布局，如下图所示，循环播放的布局不是普通的左中右布局。可以看到，当文字向左移动时，左边的通知 Icon 和右边的留白会把文字挡住一部分。\n\n\n\n为了实现这样的效果，我们给容器 box 设置一个相对定位，并把 box 中的 HTML 代码分为三部分：\n\n * 第一部分是 content，它包裹着需要循环播放的文字；\n * 第二部分是 left，它是左边的通知 Icon，我们给它设置绝对定位和 left: 0;；\n * 第三部分是 right，它是右边的留白，我们给它设置绝对定位和 right: 0;。\n\n\n\n\n\n现在我们来看包裹文字的 content。content 内部包裹了三段一模一样的文字 notice，每段 notice 之间还有一个 space 元素作为间距。\n\n\n\n为什么要放置三段一模一样的文字呢？这和循环播放的逻辑有关。\n\n\n逻辑代码#\n\n我们并没有实现真正的循环播放，而是欺骗了用户的视觉。如下图所示：\n\n * 播放通知时，content 从 0 开始向左移动。\n\n * 向左移动 2 * noticeWidth + spaceWidth 时，继续向左移动便会露馅。因为第 3 段文字后不会有第 4 段文字。\n   \n   如果我们把 content 向左移动的距离强行从 2 * noticeWidth + spaceWidth 改为 noticeWidth，不难看出，用户在\n   box 可视区域内看到的情况基本一致的。\n   \n   然后 content 继续向左移动，向左移动的距离大于等于 2 * noticeWidth + spaceWidth 时，就把距离重新设为\n   noticeWidth。循环往复，就能欺骗用户视觉，让用户认为 content 能无休无止向左移动。\n\n\n\n欺骗视觉的代码如下：\n\n * 我们通过修改 translateX，让 content 不断地向左移动，每次向左移动 1.5px；\n * 当 translateX >= noticeWidth * 2 + spaceWidth 时，我们又会把 translateX 强制设为\n   noticeWidth；\n * 为了保证移动动画更丝滑，我们并没有采用 setInterval，而是使用 requestAnimationFrame。\n\n\n\n\n完整代码#\n\n完整代码如下，你可以在 codepen 或者码上掘金上查看。\n\n * codepen: https://codepen.io/lijunlin2022/pen/rNgMrwg\n * 码上掘金: https://code.juejin.cn/pen/7373131233506623538\n\n\n总结#\n\n本文我介绍了如何用 H5 实现循环播放的通知栏：\n\n * 布局方面，我们需要用绝对定位的通知 Icon、留白挡住循环文字的左侧和右侧；此外，循环播放的文字我们额外复制 2 份。\n * 逻辑方面，通知栏向左移动 2 * noticeWidth + spaceWidth 后，我们需要强制把通知栏向左移动的距离从 2 *\n   noticeWidth + spaceWidth 变为 noticeWidth，以此来欺骗用户视觉。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/05/26/","lang":"","toc":[{"text":"布局代码","id":"布局代码","depth":2,"charIndex":211},{"text":"逻辑代码","id":"逻辑代码","depth":2,"charIndex":596},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":1202},{"text":"总结","id":"总结","depth":2,"charIndex":1355}],"domain":"","frontmatter":{},"version":""},{"id":18,"title":"从拼多多分享商品说起，canvas 绘图如何实现 contain 和 cover 效果？","content":"#\n\n我们偶尔会在一些 H5、小程序中，看到分享商品的功能。比如拼多多小程序中，用户可以把商品分享给自己的好友。分享图主要由 2 张图片组成，一张商品图，一张背景图。\n\n\n\n商品图通常由商家自己配置，尺寸会变动，一般是 contain 效果；背景图通常由 UI 提供，尺寸固定，一般是 cover 效果。\n\n\n\n如果使用 css，我们可以给 background-size 设置 contain 和 cover，可惜这类分享图基本由 canvas 绘制而成。canvas\n只提供了 drawImage() 绘制图片，无法精准实现 contain 和 cover 效果，于是我实现了 drawContainImage 和\ndrawCoverImage 两个工具函数。\n\n本文我会先分析 contain 效果的图片宽高比和容器宽高比，并给出 drawContainImage 工具函数；再分析 cover\n效果的图片宽高比和容器宽高比，并给出 drawCoverImage 工具函数；最后我会用两个工具函数，绘制如下分享图：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\ncontain 效果#\n\n先来看 contain 效果。contain 效果是「缩放图片以完全装入容器」，它会有两种情况：\n\n * 图片宽高比 < 容器宽高比，缩放后图片宽度 < 容器宽度，图片高度 = 容器高度。\n * 图片宽高比 > 容器宽高比，缩放后图片宽度 = 容器宽度，图片高度 < 容器高度。\n\n\n\n不难看出，contain 效果下，图片总是完整展示的，因此我们不必考虑裁剪图片。drawImage 的 9 个参数中，我们只需要考虑 5 个参数：\n\n>  * image，画布图像源。\n>  * dx，image 的左上角在目标画布上 X 轴坐标。\n>  * dy，image 的左上角在目标画布上 Y 轴坐标。\n>  * dw，image 在目标画布上绘制的宽度。\n>  * dh，image 在目标画布上绘制的高度。\n\n\n图片宽高比 < 容器宽高比#\n\n图片宽高比 < 容器宽高比时，dy，dw 和 dh 可以直观看出来，而 dx 还需要单独计算。如下图所示：\n\n\n\n * dx 是 image 的左上角在目标画布上 X 轴坐标，dx = (width - dw) / 2；\n * dy 是 image 的左上角在目标画布上 Y 轴坐标，dy = 0；\n * dw 是 image 在目标画布上绘制的宽度，dw = imgRatio * width；\n * dh 是 image 在目标画布上绘制的高度，dh = height。\n\n\n图片宽高比 > 容器宽高比#\n\n图片宽高比 > 容器宽高比时，dx，dw 和 dh 可以直观看出来，而 dy 还需要单独计算。如下图所示：\n\n\n\n * dx 是 image 的左上角在目标画布上 X 轴坐标，dx = 0；\n * dy 是 image 的左上角在目标画布上 Y 轴坐标，dy = (height - dh) / 2；\n * dw 是 image 在目标画布上绘制的宽度，dw = width；\n * dh 是 image 在目标画布上绘制的高度，dh = dw / imgRatio。\n\n\ndrawContainImage 代码#\n\n下面是 drawContainImage 的代码，因为 contain 效果一般会留有空白，所以我增加了一个 fillStyle 参数，用来设置空白部分的颜色。\n\n\n\n\ncover 效果#\n\n再看 cover 效果，cover 效果是「缩放图片以完全覆盖容器」。如下示意图所示，缩放后图片（红色部分）比容器（绿色部分）大。它会有两种情况：\n\n * 图片宽高比 > 容器宽高比，缩放后图片宽度 = 容器宽度，图片高度 > 容器高度。\n * 图片宽高比 < 容器宽高比，缩放后图片宽度 < 容器宽度，图片高度 = 容器高度。\n\n\n\n不难看出，contain 效果下，图片总是需要裁剪图片，所以 drawImage 的 9 个参数我们都需要使用：\n\n>  * image，画布图像源。\n>  * sx，image 的矩形（裁剪）选择框的左上角 X 轴坐标。\n>  * sy，image 的矩形（裁剪）选择框的左上角 Y 轴坐标。\n>  * sw，image 的矩形（裁剪）选择框的宽度。\n>  * sh，image的矩形（裁剪）选择框的高度。\n>  * dx，image 的左上角在目标画布上 X 轴坐标。\n>  * dy，image 的左上角在目标画布上 Y 轴坐标。\n>  * dw，image 在目标画布上绘制的宽度。\n>  * dh，image 在目标画布上绘制的高度。\n\n幸运的是，contain 效果下，dx, dy, dw 和 dh 的取值都是固定的，所以我们需要着重考虑的只有 sx, sy, sw 和 sh 这 4 个参数。\n\n\n图片宽高比 > 容器宽高比#\n\n图片宽高比 > 容器宽高比时，sy，sw 和 sh 可以直观看出来，而 sx 还需要单独计算。如下图所示：\n\n\n\n * sx 是 image 裁剪选择框（绿色部分）的左上角 X 轴坐标，sx = (img.width - sw) / 2；\n * sy 是 image 裁剪选择框（绿色部分）的左上角 Y 轴坐标，sy = 0；\n * sw 是 image 裁剪选择框（绿色部分）的宽度，sw = sh * boxRatio；\n * sh 是 image 裁剪选择框（绿色部分）的高度，sh = img.height。\n\n\n图片宽高比 < 容器宽高比#\n\n图片宽高比 < 容器宽高比时，sx, sw 和 sh 可以直观看出来，而 sy 还需要单独计算。如下图所示：\n\n\n\n * sx 是 image 裁剪选择框（绿色部分）的左上角 X 轴坐标，sx = 0；\n * sy 是 image 裁剪选择框（绿色部分）的左上角 Y 轴坐标，sy = (img.height - sh) / 2；\n * sw 是 image 裁剪选择框（绿色部分）的宽度，sw = img.width；\n * sh 是 image 裁剪选择框（绿色部分）的高度，sh = sw / boxRatio。\n\n\ndrawCoverImage 代码#\n\n下面是 drawCoverImage 的代码，因为 cover 效果不会留空白，所以不需要 fillStyle 参数。\n\n\n\n\n完整代码#\n\n完整代码可以在码上掘金上查看：https://code.juejin.cn/pen/7388885726391992371\n\n\n总结#\n\n本文我分析了 contain 效果、cover 效果的图片宽高比和容器宽高比关系，并给出 drawContainImage 和 drawCoverImage\n工具函数，最后用两个工具函数，绘制了一个商品分享图。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n参考文章#\n\n * canvas drawImage 绘图实现 contain 和 cover 的效果\n * 在容器内显示图片的五种方案：contain、cover、fill、none、scale-down","routePath":"/blog/2024/07/11/","lang":"","toc":[{"text":"contain 效果","id":"contain-效果","depth":2,"charIndex":513},{"text":"图片宽高比 < 容器宽高比","id":"图片宽高比--容器宽高比","depth":3,"charIndex":882},{"text":"图片宽高比 > 容器宽高比","id":"图片宽高比--容器宽高比","depth":3,"charIndex":1138},{"text":"drawContainImage 代码","id":"drawcontainimage-代码","depth":3,"charIndex":1391},{"text":"cover 效果","id":"cover-效果","depth":2,"charIndex":1498},{"text":"图片宽高比 > 容器宽高比","id":"图片宽高比--容器宽高比-1","depth":3,"charIndex":2084},{"text":"图片宽高比 < 容器宽高比","id":"图片宽高比--容器宽高比-1","depth":3,"charIndex":2361},{"text":"drawCoverImage 代码","id":"drawcoverimage-代码","depth":3,"charIndex":2639},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":2723},{"text":"总结","id":"总结","depth":2,"charIndex":2794},{"text":"参考文章","id":"参考文章","depth":2,"charIndex":2956}],"domain":"","frontmatter":{},"version":""},{"id":19,"title":"从商品海报说起，canvas 文本如何实现溢出截断、溢出显示省略号和自动换行？","content":"#\n\n几乎所有电商 App 都有分享商品功能，功能包括分享 H5、小程序、朋友圈，还有一些 App 能生成海报。例如盒马、得物和唯品会：\n\n\n\n现在我们有一件新款爆款 T 恤，需要生成带商品名的海报，你会怎么做呢？\n\n前端同学一般会用 canvas 绘制海报图片、文字，但 canvas 处理文本的能力非常弱，没有原生 API 直接实现溢出截断、溢出显示省略号和自动换行。\n\n\n\n本文我会先介绍 canvas 原生处理文本的 API，然后给出函数 fillTruncateText，fillEllipsisText 和\nfillWrapText，分别实现 canvas 文本溢出截断、溢出显示省略号和自动换行。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\nfillText#\n\ncanvas 填充文字的 API 为 fillText，它有 4 个参数：\n\n>  * text，需要渲染的文本字符串。\n>  * x，填充文本的 x 坐标，单位为像素。\n>  * y，填充文本基线的 y 坐标，单位为像素。\n>  * maxWidth，填充文本的最大宽度，如果未指定，则文本宽度没有限制。\n\n其中，maxWidth 基本没啥用处，设置它既不能实现溢出截断，也不能实现溢出显示省略号。它会压缩文字，在指定 maxWidth 显示文本。\n\n举例如下，第一行文本未指定 maxWidth，第二行文本指定了 maxWidth：\n\n\n\n\n\n可以看到 maxWidth 难堪大用。\n\n既然原生的 fillText 作用有限，我们便需要自己编写一些函数，实现文本溢出截断、溢出显示省略号和自动换行。\n\n\nfillTruncateText#\n\n我们先看溢出截断。\n\n要实现溢出截断功能，我们需要用到 canvas 的一个 API measureText，它可以测量文本并返回一个对象（对象中包含了文本宽度）。\n\n我们可以用 measureText 测量要填充的文本，如果文本宽度小于等于 maxWidth，便正常用 fillText 填充文本；如果文本宽度大于\nmaxWidth，我们便从文本后方一点一点往前缩短文本，直到文本宽度小于等于 maxWidth。\n\n按此思路实现的 fillTruncateText 函数如下：\n\n\n\n\nfillEllipsisText#\n\n再看溢出显示省略号。\n\n溢出显示省略号的思路和截断基本一致，如果文本宽度小于等于 maxWidth，便正常用 fillText 填充文本；如果文本宽度大于\nmaxWidth，我们便从文本后方一点一点往前缩短文本，直到文本宽度 + 省略号宽度 <= maxWidth。\n\n按此思路实现的 fillEllipsisText 如下：\n\n\n\n\nfillWrapText#\n\n最后看文本自动换行。\n\n和溢出截断、溢出显示省略号从后往前缩短文本的思路不同，文本自动换行的思路是从前往后慢慢增加文本，如果文本宽度超过 maxWidth，则开始填充下一行文本。\n\n具体来说：\n\n * 初始时，文本自动换行会先把文本拆分为一个数组 arrText，然后从下标 0 开始，逐个取出数组中的文字，慢慢拼接新的字符串。如果到下标 i\n   时字符串的宽度已经大于 maxWidth，则先绘制 i 以前的字符。\n * 然后另起一行，这一行的初始字符为 arrText[i]，基线 y 的坐标则为 y +\n   lineHeight。此后又开始逐个从数组中取出文本。直到发现这一行宽度又大于了 maxWidth。\n * 另起一行，如此循环，直到数组 arrText 中的字符已经全部用光。\n\n按此思路实现的 fillWrapText 代码如下：\n\n\n\n\n示例代码#\n\n光靠文章比较枯燥，我给三个工具写了示例，你可以在 codepen 或者码上掘金上查看：\n\n * codepen: https://codepen.io/lijunlin2022/pen/xxoxVaK\n * 码上掘金: https://code.juejin.cn/pen/7391408282185531419\n\n\n总结#\n\n本文我会先介绍 canvas 原生处理文本的 API，然后给出函数 fillTruncateText，fillEllipsisText 和\nfillWrapText，分别实现 canvas 文本溢出截断、溢出显示省略号和自动换行。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n参考文章#\n\n * canvas文本绘制自动换行、字间距、竖排等实现 | 张鑫旭","routePath":"/blog/2024/07/15/","lang":"","toc":[{"text":"fillText","id":"filltext","depth":2,"charIndex":356},{"text":"fillTruncateText","id":"filltruncatetext","depth":2,"charIndex":721},{"text":"fillEllipsisText","id":"fillellipsistext","depth":2,"charIndex":984},{"text":"fillWrapText","id":"fillwraptext","depth":2,"charIndex":1171},{"text":"示例代码","id":"示例代码","depth":2,"charIndex":1566},{"text":"总结","id":"总结","depth":2,"charIndex":1732},{"text":"参考文章","id":"参考文章","depth":2,"charIndex":1904}],"domain":"","frontmatter":{},"version":""},{"id":20,"title":"仿拼多多领红包、金额数字移动如何实现？","content":"#\n\n拼多多现金大转盘领取红包后，小数部分有一个数字移动的效果，这个效果怎么做呢？\n\n\n\n本文我会告诉你数字移动的原理，并用 React 实现一个 Demo，效果如下：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n滚动原理#\n\n不难想到，数字移动，实质是一串数字列表，在容器内部向上移动。下图就展示了数字从 0 变为 2，又从 2 变为 4 的过程：\n\n\n\n但是，金额数字比较特殊，它是可以进位的。举例来说，39.5 变为 39.9 时，小数部分由 5 到 9 需要向上移动；39.9 变为 40.2 时，小数部分由\n9 变到 2 时也需要向上移动。\n\n为了做到这个效果，我们需要每次滚动结束之后，重新设置一整串数字。\n\n同样是从 0 变为 2，又从 2 变为 4。下图不同的是，数字变为 2 时，它下方的数字变为了 3、4、5、6、7、8、9、0、1；数字变为 4\n时，它下方的数字变为了 5、6、7、8、9、0、1、2、3。\n\n\n\n\n关键布局#\n\n了解原理后，我们开始写元素布局。关键布局有 2 个元素：\n\n * 选择框，它可以确认下一个将要变成的数字，我们用它来模拟领取红包之后、金额变化的情况。\n * 数字盒子，它包括三部分，带 overflow: hidden 的外层盒子，包裹数字并向上滚动的内层盒子，以及一个个数字。\n\n\n关键逻辑#\n\n数字移动的关键逻辑有 3 个：\n\n * 重置数字数组\n * 计算移动距离\n * 开启关闭动画\n\n\n重置数字数组#\n\n你之前已经知道，如果数组首位是 2，它下面的数字就是 3、4、5、6、7、8、9、0、1。要获取完整的数组，我们可以分为两个步骤：\n\n * 首先，数组首位背后的数字依次加 1，这样数字就变为了 3、4、5、6、7、8、9、10、11；\n * 然后，所有大于 9 的数字都减去 10，这样数字就变为了 3、4、5、6、7、8、9、0、1。\n\n\n计算移动距离#\n\n你可以用 current 表示当前的数字，next 表示需要变成的数字。计算移动距离时，需要分两种情况考虑：\n\n * next 大于 current 时，只需要移动 next - current 个数字即可；\n * next 小于 current 时，需要先移动 10 - next 个数字，再移动 current 个数字即可。\n\n\n开启关闭动画#\n\n不难想到，我们数字移动的动画是使用 translateY 和 transition 实现。当数字移动时，我们把 translateY 设置为\ncalculateDistance 的结果；当移动结束、重置数组时，我们需要把 translateY 设置为 0。\n\n整个过程中，如果我们一直开启动画，效果会是数字先向上移动，再向下移动，这并不符合预期。\n\n\n\n因此，我们需要在数字开始移动时开启动画，数字结束移动后、重置数组前关闭动画。\n\n\n完整代码#\n\n * codesandbox: https://codesandbox.io/p/sandbox/basic-scroll-number-4k65c7\n * 码上掘金：https://code.juejin.cn/pen/7430439231253643273\n\n\n总结#\n\n本文介绍了类似拼多多的金额数字滚动如何实现，其中有三个关键点，分别是重置数字数组、计算移动距离和开启关闭动画。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/blog/2024/10/27/","lang":"","toc":[{"text":"滚动原理","id":"滚动原理","depth":2,"charIndex":137},{"text":"关键布局","id":"关键布局","depth":2,"charIndex":449},{"text":"关键逻辑","id":"关键逻辑","depth":2,"charIndex":598},{"text":"重置数字数组","id":"重置数字数组","depth":3,"charIndex":654},{"text":"计算移动距离","id":"计算移动距离","depth":3,"charIndex":834},{"text":"开启关闭动画","id":"开启关闭动画","depth":3,"charIndex":1010},{"text":"完整代码","id":"完整代码","depth":2,"charIndex":1237},{"text":"总结","id":"总结","depth":2,"charIndex":1377}],"domain":"","frontmatter":{},"version":""},{"id":21,"title":"对比静态替换和动态插入标签，Vite 打包 H5 注入版本号哪种方式更优雅？","content":"","routePath":"/blog/2024/10/29/","lang":"","toc":[{"text":"静态替换和动态插入标签","id":"静态替换和动态插入标签","depth":2,"charIndex":-1},{"text":"静态替换的流程","id":"静态替换的流程","depth":2,"charIndex":-1},{"text":"在 .env 文件写入变量","id":"在-env-文件写入变量","depth":3,"charIndex":-1},{"text":"在 js 代码中替换变量","id":"在-js-代码中替换变量","depth":3,"charIndex":-1},{"text":"上报版本号给监控 SDK","id":"上报版本号给监控-sdk","depth":3,"charIndex":-1},{"text":"动态插入标签的流程","id":"动态插入标签的流程","depth":2,"charIndex":-1},{"text":"从命令行读取版本号","id":"从命令行读取版本号","depth":3,"charIndex":-1},{"text":"插入版本号到 HTML","id":"插入版本号到-html","depth":3,"charIndex":-1},{"text":"上报版本号给监控 SDK","id":"上报版本号给监控-sdk-1","depth":3,"charIndex":-1},{"text":"总结","id":"总结","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":22,"title":"H5 套 H5 叫微前端，那么小程序套小程序呢？","content":"#\n\n\n打开另一个小程序#\n\n打开另一个小程序 | 微信官方文档\n\n\n\n\n打开半屏小程序#\n\n打开半屏小程序 | 微信官方文档\n\n\n\n\n打开子包#\n\n\n\n","routePath":"/blog/2024/11/02/","lang":"","toc":[{"text":"打开另一个小程序","id":"打开另一个小程序","depth":2,"charIndex":3},{"text":"打开半屏小程序","id":"打开半屏小程序","depth":2,"charIndex":36},{"text":"打开子包","id":"打开子包","depth":2,"charIndex":67}],"domain":"","frontmatter":{},"version":""},{"id":23,"title":"","content":"","routePath":"/blog/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":24,"title":"","content":"\") response.Write(x) response.Write(\"\n\n请输入学生姓名:\n请输入学生班级:\n请输入学生成绩:\n\n\n\") response.Write(x) response.Write(\"\n\n<% set conn = Server.CreateObject(\"ADODB.Connection\") conn.Provider =\n\"Microsoft.Jet.OLEDB.4.0\" ' 填写你创建的数据库绝对路径 conn.Open(\"f:\\Website\\Database1.mdb\")\n' sql插入数据表的例子如下：insert into score(stu_name, stu_class, stu_score) values('Mike',\n'class1', '100') sql = \"insert into score(stu_name, stu_class, stu_score)\nvalues\" sql = sql & \"(' \" &Request.Form(\"stu_name\")& \"', \" sql = sql & \" ' \"\n&Request.Form(\"stu_class\")& \"', \" sql = sql & \" ' \" &Request.Form(\"stu_score\")&\n\" ')\" conn.Execute sql, recaffected conn.Close() %> Go back to the previous page","routePath":"/docs/bit-life/asp","lang":"","toc":[{"text":"修改 IIS 配置，将错误信息发送到浏览器","id":"修改-iis-配置将错误信息发送到浏览器","depth":2,"charIndex":-1},{"text":"创建数据库","id":"创建数据库","depth":2,"charIndex":-1},{"text":"编写asp文件连接数据库","id":"编写asp文件连接数据库","depth":2,"charIndex":-1},{"text":"解释 asp 连接数据库的代码","id":"解释-asp-连接数据库的代码","depth":2,"charIndex":-1},{"text":"表格展示数据库中的内容","id":"表格展示数据库中的内容","depth":2,"charIndex":-1},{"text":"极限更新，添加数据到数据库：","id":"极限更新添加数据到数据库","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":25,"title":"","content":"成果#\n\n * Wiki 效果：https://2020.igem.org/Team:BIT\n * Poster 效果：https://2020.igem.org/Team:BIT/Poster\n\n\n比赛规则#\n\n * 官方规则：https://2020.igem.org/Competition/Deliverables/Wiki\n * 哔哩哔哩视频，规则讲解：https://www.bilibili.com/video/av968823530\n * 四川大学的一位前辈：http://www.xiaomaidong.com/?p=321\n\n\n比赛过程#\n\n这次队伍由 3 位 18 级计算机学院的同学，和一位 19 级的同学组成。开始时，我安排队员们学习 Vue.js + Element\nUi，因为我查看网页，上一届的队伍就用了 Vue。 但之后了解比赛详情后，我意识到，把 Vue 项目打包再部署到 IGEM 网站的方式是不可行的。要使用\nVue，只能直接引入 js 文件。\n\nIGEM 官网不允许使用 CDN 方式引入外部文件，所以我必须将 Vue.js 和 Element.js，Element.css 上传之后才能使用。而\nElement.css 中又引入了很多字体和图片，所以我也需要把这些字体和图片上传到 IGEM 的官网。这太繁琐了。于是我放弃了使用 Vue。只使用\nHTML、CSS、JavaScript 和 JQuery。\n\n我们队伍没有美工，于是我参照了一些博客的样式来写代码。\n\n\n\n然后经过我的死亡调色，变成了这样。\n\n\n\n这时候我已经觉得蛮可以了，然后自习时遇见了黛玉大佬，他看了看，露出尴尬而不失礼貌的微笑。于是我明白了，黛玉大佬是在嫌弃网页丑陋。\n这我可不能忍啊，劳动的结晶怎么能被如此糟蹋呢!\n\n于是我决定美化页面，在参考了大量博客的设计之后，我发现极简的博客想要好看，关键在于大图。\n\n于是我调 css 调出来了这个页面，效果还不错。于是决定其他页面都按照这个风格来。\n\n\n\n图片都是从北京理工大学的图库平台拿到的：http://www.bit.edu.cn/tkpt/\n\n在主要页面确定之后，我需要考虑首页，首页是一个网站最吸引人的地方，一定不能大意。当然，这些酷炫的效果，单凭我自己是没办法短时间内写出来的，我是用了插件。这是一个\n开源的插件库：jQuery 之家。\n\n我换了三次首页效果，最后效果是：\n\n\n\n选中这个效果之后，就开始了调色之旅。 下面这个效果，其实是一张铺满全部背景的图片，上面再覆盖一张北理工正门的图片。（铺满地面的雪花就是那张铺满全部背景的图片）\n\n\n\n在模板全部确定之后，就是等待文稿然后复制粘贴了，都是重复的工作。\n\n最后是制作海报：\n\n * Wiki 的截至日期是美国东部时间 10.27，这之后还有海报需要制作，我们是使用了官方的海报模板。我们做出的效果如下。\n\n\n\n\n踩坑经验#\n\n * css 的引入\n\njs、css 文件的引入方法参照对应年份的规则，往年学长的引入方法今年不一定适用。\n\n * IGEM 自带 css 样式，会干扰自定义的 css\n\n在比赛规则的视频还有博客里，都提及了这个问题。你需要用代码来 IGEM 原来的样式，这里提供一份基本的覆盖的代码。\n\n\n\n这份代码只实现了基础的覆盖，具体情况还需要具体分析。\n\n如果后续学弟学妹熟悉 Vue 框架，建议还是使用 Vue。因为当网页基本样式调好后，如果使用 Vue，可以把文本都放在 Vue 实例中的 data\n中，而不需要手动复制黏贴，这会节省很多时间。\n\nIGEM 其实看重的还是 CSS 效果，如果 CSS 功底或者审美不好，建议还是多找一些 CSS 插件。","routePath":"/docs/bit-life/igem","lang":"","toc":[{"text":"成果","id":"成果","depth":2,"charIndex":-1},{"text":"比赛规则","id":"比赛规则","depth":2,"charIndex":99},{"text":"比赛过程","id":"比赛过程","depth":2,"charIndex":273},{"text":"踩坑经验","id":"踩坑经验","depth":2,"charIndex":1222}],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"","content":"默认把index.html当作入口 跳转到test.asp <% response.write(\"Hello World\") %>\n\n<%=i%><%=j%>","routePath":"/docs/bit-life/iis","lang":"","toc":[{"text":"配置 IIS","id":"配置-iis","depth":2,"charIndex":-1},{"text":"用什么编辑器写 ASP","id":"用什么编辑器写-asp","depth":2,"charIndex":-1},{"text":"ASP 几个小例子","id":"asp-几个小例子","depth":2,"charIndex":-1},{"text":"ASP 中 for 循环生成表格","id":"asp-中-for-循环生成表格","depth":3,"charIndex":-1},{"text":"踩坑经验","id":"踩坑经验","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":27,"title":"","content":"本节介绍了 cmp 的基本用法，以及 jz/je 和 jnz/jne 两个条件跳转指令，完成了判断用户输入的代码并封装了一个之后会经常用到的清屏函数\nClearScreen()\n\n\ncmp 基本用法#\n\ncmp 可以用来比较源操作数和目的操作数\n\n\n\n> cmp 指令在源操作数和目的操作数之间执行隐含的减法操作\n> \n> 在比较两个无符号操作数的时候，会影响两个 CPU 标志位—— 零标志位 ZF 和 进位标志位 CF\n> \n> CMP 的结果   ZF   CF\n> 目的 < 源    0    1\n> 目的 > 源    0    0\n> 目的 = 源    1    0\n> \n> —— 摘自 《Intel 汇编语言程序设计（第 5 版）》144 页\n\n\njz/je 和 jnz/jne#\n\n于是我们可以通过判断这些标志位来进行条件跳转，下面是两个命令\n\n * jz —— 如果 源操作数 - 目的操作数 = 0，即 ZF = 1 ，则进行跳转\n * jnz —— 如果 源操作数 - 目的操作数 ≠ 0 ，即 ZF = 0，则进行跳转\n\n值得注意的是，命令 jz 和 je 是等价的，而 jnz 和 jne 是等价的\n\n> 对于实现同一功能但指令助记符有两种形式的情况，在程序中究竟选用哪一种，视习惯或用途而定。例如，对于指令 JZ/JE LABEL，当比较两数相等转义时，常使用\n> JE，当比较某数为 0 转移时，常使用 JZ\n> \n> —— 摘自《汇编语言与接口技术（李元章）》104 页\n\n\n判断 scanf 的输入类型#\n\n了解 cmp 和 je/jne 指令之后，我们现在可以判断 scanf 的输入了，在 snake.cpp 中，判断用户输入的代码放到了函数\nenterGame() 中，要看它翻译的汇编结果，你可以查看 snake.asm 的函数 enterGame()\n\n\n\n\n延时和清屏#\n\n在上述代码中，处理非法输入时会调用 handleIllegalSelection() 函数，而在 handleIllegalSelection() 中调用了\nSleep() 函数和 clearScreen() 函数\n\n\n延时函数#\n\n延时调用的是 Windows 提供的函数 Sleep() ，它的头文件是 windows.h ，参数以毫秒为单位\n\n\n\n上述代码的意思就是延时 2s\n\n值得注意的是，Windows 的函数自己会平衡堆栈，所以不需要像我们调用 scanf 或者 printf 那样还要加上 add esp,4\n\n\n清屏函数#\n\n清屏函数调用的是函数 system()，它的头文件是 stdlib.h\n\n\n\nwindows.h 中调用了这个函数，因此我们平时可以再 Windows 的命令提示符窗口下直接输入 cls 清屏\n\n现在我们来封装这个函数，把它作为一个工具供以后使用\n\n","routePath":"/docs/bit-life/snake/cmp-and-jmp","lang":"","toc":[{"text":"cmp 基本用法","id":"cmp-基本用法","depth":2,"charIndex":90},{"text":"jz/je 和 jnz/jne","id":"jzje-和-jnzjne","depth":2,"charIndex":333},{"text":"判断 scanf 的输入类型","id":"判断-scanf-的输入类型","depth":2,"charIndex":656},{"text":"延时和清屏","id":"延时和清屏","depth":2,"charIndex":804},{"text":"延时函数","id":"延时函数","depth":3,"charIndex":922},{"text":"清屏函数","id":"清屏函数","depth":3,"charIndex":1077}],"domain":"","frontmatter":{},"version":""},{"id":28,"title":"","content":"本文是汇编贪吃蛇的最后一篇，简单介绍了如何进行碰撞检测\n\n\n碰撞检测#\n\n碰撞检测其实包含两个部分：\n\n * 检测蛇是否撞到墙壁\n * 检测蛇是否吃到食物\n\n这两部分都比较简单，由于贪吃蛇的特殊性，碰撞检测时只需要检测蛇头和墙壁、食物有没有重叠就好。其中墙壁的值为 0bh，而食物的值为 0ch，\n\n碰撞检测代码如下：\n\n\n\n\n总结#\n\n写到这里，代码的主要难点我已经全部讲解了，至于翻译为纯汇编，并不是困难的事情，相信读者参照着我的代码，很快就能明白究竟是怎么翻译的\n\n今天刚好是我们汇编大作业的展示，看到台上其他人的作品，真的是太强了，甚至有小组用汇编写出了 3D 的游戏，这样一对比说实话挺难受的\n\n但毕竟是我投入了大量心血的作品，不甘心没给它一个结尾，现在不管结尾美不美好，它至少是有一个结局了\n\n如果你是北理工的同学，一定注意，光靠这个汇编贪吃蛇是无法立足的，如果最后大作业要展示，大佬的作品会超出你的想象\n\n想要将这个贪吃蛇做得更加精美的话，可以看看在我队友添加亿点点之后的 super-snake.asm\n\nassembly-snake | GitHub","routePath":"/docs/bit-life/snake/collision-detection","lang":"","toc":[{"text":"碰撞检测","id":"碰撞检测","depth":2,"charIndex":29},{"text":"总结","id":"总结","depth":2,"charIndex":163}],"domain":"","frontmatter":{},"version":""},{"id":29,"title":"","content":"本文介绍了游戏中如何使用双线程，完成获取键盘输入控制贪吃蛇移动，为此我们需要学习两个函数，CreateThread 和 GetAsyncKeyState\n\n\n双线程的作用#\n\n\n\n在我们的设计中，开了两个线程，第一个线程用于获取键盘输入，它将影响一个全局变量 globalMovementDirection\n，当需要移动蛇的时候，第二个线程将读取 globalMovementDirection 作为控制信号\n\n\nCreateThread 的用法#\n\n>  * 语法\n>    \n>    \n> \n>  * 参数\n>    \n>    * lpsa，忽略，必须为 NULL\n>    * cbStack，忽略\n>    * lpStartAddr，线程的起始地址\n>    * lpvThreadParam，指向传递给线程的单个 32 位参数值的长指针\n>    * fdwCreate，执行控制线程创建的标志\n>    * lpIDThread，指向接收线程标识符的 32 位变量的长指针，如果此参数为 NULL，则不反悔线程标识符\n> \n> ——CreateThread | Microsoft Docs\n\n\n实际创建线程的代码#\n\n在 main 函数中，我们有：\n\n\n\n可以知道，第一个线程中就只有函数 judgeMovementDirection 在运行，而 judgeMovementDirection 就是的功能就是修改\nglobalMovementDirection 变量\n\n\nGetAsyncKeyState#\n\n> GetAsyncKeyState 是一个用来判断函数调用时指定虚拟键的状态，确定用户当前是否按下了键盘的一个键的函数。如果按下，则返回值最高位为 1\n> \n>  * 语法\n>    \n>    \n> \n>  * 参数\n>    \n>    * vKey\n>      \n>      有关详细信息，请参阅虚拟键代码\n> \n> 对 GetAsyncKeyState 调用之后，如果按键已经被按下，则返回值位 15 设为 1；如抬起，则为 0\n> \n> —— GetAsyncKeyState 百度百科\n> \n> —— GetAsyncKeyState | Microsoft Docs\n\n\n实际判断状态的代码#\n\n需要注意的时，贪吃蛇不能够直接掉头，所以在给 globalMovementDirection 赋值时，必须首先判断此时蛇的移动方向\n\n * 如果蛇向下移动，则向上的按键不生效\n * 如果蛇向上移动，则向下的按键不生效\n * 如果蛇向左移动，则向右的按键不生效\n * 如果蛇向右移动，则向左的按键不生效\n\n","routePath":"/docs/bit-life/snake/double-thread","lang":"","toc":[{"text":"双线程的作用","id":"双线程的作用","depth":2,"charIndex":78},{"text":"CreateThread 的用法","id":"createthread-的用法","depth":2,"charIndex":206},{"text":"实际创建线程的代码","id":"实际创建线程的代码","depth":2,"charIndex":506},{"text":"GetAsyncKeyState","id":"getasynckeystate","depth":2,"charIndex":645},{"text":"实际判断状态的代码","id":"实际判断状态的代码","depth":2,"charIndex":960}],"domain":"","frontmatter":{},"version":""},{"id":30,"title":"","content":"本节介绍了 ExitProcess() 函数，用以结束游戏\n\n\n回忆游戏流程#\n\n\n\n\nExitProcess#\n\n调用 ExitProcess() 时，需要往函数中传入一个 uExitCode，代表该进程和所有线程的退出代码\n\n直接传入 0，表示没有错误\n\n它的头文件是 windows.h，\n\n","routePath":"/docs/bit-life/snake/exit-process","lang":"","toc":[{"text":"回忆游戏流程","id":"回忆游戏流程","depth":2,"charIndex":31},{"text":"ExitProcess","id":"exitprocess","depth":2,"charIndex":43}],"domain":"","frontmatter":{},"version":""},{"id":31,"title":"","content":"本节介绍了在贪吃蛇游戏中，如何画出墙壁和食物，以及为了在特定位置画出蛇，必须使用一个函数 SetConsoleCursorPosition，并封装了一个函数\ngotoxyUtil\n\n\n画墙壁和食物#\n\n在第 4 章时我们设置地图时同时设置了墙壁，在 globalMapArr[25][25] 中，是墙壁的地方均被设置为 0bh\n\n在第 5 章时我们设置了食物，globalMapArr[globalFoodX][globalFoodY] 被设置为 0ch\n\n画出地图和食物整体还是比较简单的，就是使用双重循环遍历二维数组\n\n * 如果遇到了 0bh，就打印 # 当作墙壁\n * 如果遇到了 0ch，就打印 * 当作食物\n * 剩余情况，就打印空白\n\n\nSetConsoleCursorPosition —— 画蛇#\n\n和画墙壁和食物不同，我们需要根据坐标 (x, y) 来在特定位置打印 O 来充当蛇的身体\n\n为了在特定位置画出蛇，需要使用 Windows 提供的函数，SetConsoleCursorPosition()\n\n>  * 语法\n> \n> \n> \n>  * 参数\n>    * hConsoleOutput 控制台屏幕缓冲区的句柄\n>    * dwCursorPosition 指定新游标位置的 oozie.coord.application.path 结构\n> \n> —— SetConsoleCursorPosition 函数 - Windows Console | Microsoft Docs\n\n至于 dwCursorPosition ，它的结构如下：\n\n>  * 语法\n> \n> \n> \n> —— COORD 结构 - Windows Console | Microsoft Docs\n\n\n封装在特定位置打印的函数#\n\n\n\n其中，-11 代表句柄\n\n\n值得注意的情况#\n\n可以看到 SetConsoleCursorPosition() 中的 COORD 结构中，内部参数 x 和 y 都是 short，也就是 16 字节，而我们在\n32 位汇编下，一般都使用的是 32 字节的变量，为了能调用整个函数，我们需要对变量进行一些处理：\n\n","routePath":"/docs/bit-life/snake/gotoxy-util","lang":"","toc":[{"text":"画墙壁和食物","id":"画墙壁和食物","depth":2,"charIndex":91},{"text":"SetConsoleCursorPosition —— 画蛇","id":"setconsolecursorposition--画蛇","depth":2,"charIndex":325},{"text":"封装在特定位置打印的函数","id":"封装在特定位置打印的函数","depth":2,"charIndex":756},{"text":"值得注意的情况","id":"值得注意的情况","depth":2,"charIndex":787}],"domain":"","frontmatter":{},"version":""},{"id":32,"title":"","content":"本节介绍了如何利用 rand、srand 和 time 生成随机数，以及 idiv 指令和 cdq\n指令的用法，然后通过这些知识，在墙壁范围内随机设置了食物的位置和蛇头的位置\n\n\n食物的位置设计思路#\n\n游戏开始时，食物会随机出现在墙壁内，当蛇吃下食物后，原本的食物消失且新的位置将会生成食物\n\n关键问题在于，如何生成随机的食物，这个问题我们在 (3) 时会谈到\n\n\n蛇头的位置设计思路#\n\n和食物一样，蛇头的位置也应该是随机出现的，但应该和食物随机出现的位置不同。蛇头还要考虑到今后吃下食物之后，蛇会变长\n\n我们使用一个结构体数组来存储蛇的位置\n\n\n\nglobalSnakeArr[0] 用来存储蛇头的坐标，至于吃到食物如何增长，以及蛇如何移动，我们之后再谈\n\n\nrand, srand 和 time#\n\n在 C 语言的头文件 stdlib.h 中有一个函数 rand()，它可以返回一个范围在 0 到 RAND_MAX 的伪随机整数。\n\n在调用 rand() 函数之前，可以使用 srand() 设置随机数种子，如果没有设置随机数种子，rand() 会自动设置随机数种子为 1\n\n> srand(unsigned seed) 通过参数 seed 改变系统提供的种子值，从而可以使每次调用 rand()\n> 函数生成的伪随机数序列不同，通常利用系统时间来改变系统的种子值，即 srand(time(NULL))\n\n\nidiv 指令#\n\n假设墙壁是 20 × 20 的宽度，为了让食物出现在墙壁内，需要对生成的随机数取 20 的余数，这时候我们就需要使用一个指令 idiv\n\n> 该指令只含有一个源操作符，该操作符作为除数使用。注意，它只能是寄存器或存储器操作数，不能是立即数。被除数必须实现放在隐含的寄存器中。可以实现 8 位、16\n> 位、32 位带符号操作数除。\n> \n>  * 若源操作数是 8 位，则被除数放在 AX 中，商在 AL 中，余数在 AH 中\n>  * 若源操作数是 16 位，则被除数在 DX:AX 一对寄存器中，商在 AX 中，余数在 DX 中\n>  * 若源操作数是 32 位，则被除数在 EDX:EAX 一对寄存器中，商在 EAX 中，余数在 EDX 中\n> \n> —— 《汇编语言与接口计数（李元章）》\n\n所以当使用好 idiv 指令之后，我们想要的余数就在 EDX 中\n\n\n实际代码#\n\n这是生成食物的代码：\n\n\n\n这是生成蛇头位置的代码：\n\n\n\n\ncdq 指令#\n\n上面的代码中出现了 cdq 指令\n\n> 双字扩展成四字指令 CDQ (Convert Double to Quad)\n> \n> 格式：CDQ\n> \n> 功能：把 EAX 寄存器中的符号位值扩展到 EDX 中\n> \n> 说明：80386 以上 CPU 支持此指令\n> \n> —— 《汇编语言与接口计数（李元章）》\n\n在很久以前指令集规定除数必须是被除数的一半长，所以需要 CDQ 指令\n\n经过我在 VS 2019 里面测试，不使用 CDQ 运行也是没有问题的","routePath":"/docs/bit-life/snake/idiv","lang":"","toc":[{"text":"食物的位置设计思路","id":"食物的位置设计思路","depth":2,"charIndex":89},{"text":"蛇头的位置设计思路","id":"蛇头的位置设计思路","depth":2,"charIndex":183},{"text":"rand, srand 和 time","id":"rand-srand-和-time","depth":2,"charIndex":332},{"text":"idiv 指令","id":"idiv-指令","depth":2,"charIndex":608},{"text":"实际代码","id":"实际代码","depth":2,"charIndex":1003},{"text":"cdq 指令","id":"cdq-指令","depth":2,"charIndex":1041}],"domain":"","frontmatter":{},"version":""},{"id":33,"title":"","content":"本文介绍了游戏中的地图设计：20 x 20 的数组，其中数组的四边都设置为墙壁。为了更清晰简明地介绍实现方法，采用了先写 C 语言代码，再使用汇编语言实现的办法\n\n\n地图设计#\n\n我们的地图设计为 20 x 20 的数组，其中四面都是墙\n\n\n\n关键问题在于：在汇编中我们如何表示二维数组呢？\n\n\n汇编表示二维数组#\n\n内存是线性排列的，相当于一维数组，我们要做的就是将一维数组加以变化后模拟二维数组\n\n假如我们申请 char arr[400]，要想用它模拟二维数组，则\n\n\n\n而如果我们想要访问 char g_MapDataArr[3][12] 时，我们该如何模拟呢？\n\n我们应该用 char arr[3 * 20 + 12] 来模拟\n\n现在我们来利用汇编，将 char g_MapDataArr[3][12] 设置为 0bh\n\n\n\n\n结合循环#\n\n在上一节中，我们使用了 mov byte ptr ds:[eax + ecx], 1 来完成赋值\n\n如果我们将 ecx 设置为变量，在一个循环里面对 ecx 加 1，不就可以完整地对某一行或者某一列进行赋值了吗？\n\n这正是我们的思路，利用变量结合循环给墙壁赋值\n\n用 C 语言表述如下\n\n\n\n下面我们来学习汇编的 loop 循环\n\n\n\n> loop 指令的执行包含两部，首先，ecx 减 1，接着与 0 相比较，如果 ecx 不等于 0，则跳转到目的地址（表好处）；如果 ecx 等于\n> 0，则不妨生跳转，执行后面的语句。\n\n可以看到，loop 循环和我们之前的 C 语言代码逻辑不太一致，我们可以将 C 代码修改一下，使它符合 loop 循环的逻辑\n\n\n\n与之对应的汇编语句为：\n\n\n\n这也正是我代码中的函数 setWall() 的主要内容，稍有不同的是，在游戏中我设置的地图为 25 x 25\n大小，并且在设置墙壁之前，我先把墙壁所在的内存给清空，清空的函数是 initMapData()","routePath":"/docs/bit-life/snake/loop","lang":"","toc":[{"text":"地图设计","id":"地图设计","depth":2,"charIndex":82},{"text":"汇编表示二维数组","id":"汇编表示二维数组","depth":2,"charIndex":147},{"text":"结合循环","id":"结合循环","depth":2,"charIndex":367}],"domain":"","frontmatter":{},"version":""},{"id":34,"title":"","content":"上一篇我们了解到，蛇身体的每一个点的坐标被存储在结构体中。这篇我们使用图片来演示蛇是如何移动，以及当蛇的长度增长时，又是如何实现增加的。本篇算是整个汇编贪吃蛇的\n重中之重\n\n\n存储蛇的结构体#\n\n在上一篇文章中我们已经知道，蛇的位置是由结构体来存储的：\n\n\n\n其中，globalSnakeArr[i].x 和 globalSnakeArr[i].y 记录了一个蛇的节点，在地图 globalMapArr 的 x\n坐标位置和 y 坐标位置\n\n需要注意的是，游戏中的 x 和 y 坐标系如下所示：\n\n\n\n\n蛇的移动#\n\n我们现在假设一条蛇的长度为 5，蛇头朝上，如果你想要将这条蛇整体往上移动一格，你应该怎么办？\n\n我们的做法是如下图所示：\n\n\n\n现在我们来看蛇头左转和右转的情况，（贪吃蛇不能掉头）\n\n\n\n\n蛇的生长#\n\n蛇的生长和蛇的移动有所不同，如下图所示\n\n\n\n蛇增加一段长度，可以看作将原来的 globalSnakeArr 全部向后挪动一个位置之后，再在蛇头的位置标上坐标\n\n\n实际代码#\n\n这是蛇的移动代码：\n\n\n\n这是蛇长度增加的代码：\n\n","routePath":"/docs/bit-life/snake/movement-and-growth","lang":"","toc":[{"text":"存储蛇的结构体","id":"存储蛇的结构体","depth":2,"charIndex":87},{"text":"蛇的移动","id":"蛇的移动","depth":2,"charIndex":250},{"text":"蛇的生长","id":"蛇的生长","depth":2,"charIndex":352},{"text":"实际代码","id":"实际代码","depth":2,"charIndex":441}],"domain":"","frontmatter":{},"version":""},{"id":35,"title":"","content":"本节以一个 Hello World 介绍了汇编嵌套 C 程序的基本结构，然后介绍了 printf 和 scanf\n在汇编中的基本用法，本节之后，应该能完成显示主菜单的部分代码\n\n\n开发环境#\n\nVisual Studio 2019 创建新项目 → C++ 空项目 → 源文件右键 → 添加新建项 → Test.cpp\n\n\nHello World#\n\n我们先来看一个简单的 Hello World 程序\n\n\n\n下面逐行逐行地解释程序\n\n * 为什么要包含头文件 studio ？\n   \n   \n   \n   C 嵌套汇编时，为了能在控制台打印出结果，我们需要调用标准库的 studio 的 printf 函数\n\n * szHello 前的 sz 是什么意思？\n   \n   \n   \n   此处使用了匈牙利命名法，sz 是 String Terminated with a Zero 的缩写，意为 以 '\\0' 结尾字符串\n   \n   为什么以 '\\0' 结尾呢？\n   \n   C 语言没有专用的字符串变量，要用一个字符数组来存放。为了确定字符串的结束位置，C 语言创建字符串时总是在末尾添加 '\\0' 字符\n\n * __asm {} 是什么意思？\n   \n   \n   \n   代表包含在花括号内部的代码均为汇编代码\n\n * dword ptr\n   \n   如果没有 dword ptr，可以看出汇编代码就是直接寻址的代码\n   \n   \n   \n   事实上，由于段地址总是默认存放在 ds 寄存器中，所以其实可以直接写为\n   \n   \n   \n   如果你尝试将 Test.cpp 中的内容改为上述两种写法，其实也不会报错\n   \n   dword 是意思是 double word，即指令长度是双字(32 bit)，ptr 的意思是 pointer，即指针\n   \n   \n   \n   加上 dword ptr 有助于让 eax 理解传递给它的参数是双字的\n   \n   之后如果我们要传递其他长度，比如单字节(8 bit)，可以这样写\n   \n   \n\n * 调用函数以及保持堆栈平衡\n   \n   \n   \n   要调用一个子程序，且给这个子程序传递参数，有三种方法，我们这里使用的是堆栈传递参数（具体可以看《汇编技术与接口（李元章）》第 5 章）\n   \n   注意点：\n   \n   * 传递子程序参数，我们需要先将参数压栈\n   * C 语言函数，传递参数时是从右往左压栈\n   * 调用函数之后，需要保证堆栈平衡\n   * 子程序的返回结果默认保存在寄存器 EAX 中\n   \n   这里我们首先将保存在 eax 中的参数压栈，然后调用 printf 函数，之后再恢复堆栈平衡\n\n\nlea，结合 scanf#\n\n之前我们已经学会如何使用 printf 函数，解析来我们来学习如何使用 scanf 函数\n\n常见的 scanf 用法有\n\n\n\n其中，&age 和 &ch 表示取地址，而 name 是数组名字，直接代码地址\n\n我们在写汇编代码时，也需要取地址，这时候就需要用到命令 lea ，lea 就表示取内存的地址\n\n例如：\n\n\n\n就代表取 ds:[szOutPut] 的地址，放到寄存器 eax 中\n\n\n完成部分显示主菜单的代码#\n\n现在我们可以完成部分显示主菜单的代码了，下面代码是 snake.cpp 的 showMainMenu() 函数，它翻译的纯汇编具体可以看 snake.asm 的\nshowMainMenu() 函数\n\n\n\n\n碎碎念#\n\n博主不是很喜欢匈牙利命名法，因此在 snake.cpp 和 snake.asm 中几乎都未使用匈牙利命名法\n\n我在 (3) 中给出的 C 语言代码，将 int，char，char 型数组都进行了初始化，事实上你不初始化也不会报错\n\n我这么做主要是提醒自己，初始化很重要\n\n为什么初始化很重要呢？int，char\n和数组即便不初始化，编译器也能够判断出它们应该占用多大的内存空间，但是如果是一个指针，没有初始化，编译器便完全无法确定指针应该分配多少内存，程序便会报错","routePath":"/docs/bit-life/snake/printf-and-scanf","lang":"","toc":[{"text":"开发环境","id":"开发环境","depth":2,"charIndex":89},{"text":"Hello World","id":"hello-world","depth":2,"charIndex":160},{"text":"lea，结合 scanf","id":"lea结合-scanf","depth":2,"charIndex":1155},{"text":"完成部分显示主菜单的代码","id":"完成部分显示主菜单的代码","depth":2,"charIndex":1366},{"text":"碎碎念","id":"碎碎念","depth":2,"charIndex":1484}],"domain":"","frontmatter":{},"version":""},{"id":36,"title":"bfc","content":"#\n\nBFC 全称 Block Format Context，即块级格式化上下文。BFC\n可以看作一种规范，具有这种规范的元素可以看作一块独立的渲染区域，这块区域的元素不会影响边界之外的元素。\n\n它的特性为：\n\n 1. BFC 是独立容器，容器内部元素不会影响容器外部元素\n 2. BFC 内的元素在垂直方向上依次排列\n 3. 同一个 BFC 内部的两个相邻容器的上下 margin 会重叠\n 4. BFC 的区域不会与浮动容器发生重叠\n 5. 计算 BFC 区域高度时, 浮动元素也参与计算\n\n\n触发 BFC 的条件#\n\n 1. 根元素 ()\n 2. 元素的 float 不是 none\n 3. 元素的 position 为 absolute 或 fixed\n 4. overflow 的值不等于 visible\n 5. contain 的值为 layout、content 或 paint 的元素\n 6. display 为 inline-block、table-cell、flex、inline-flex、grid 等\n\n\nBFC 的作用#\n\n * 避免外边距重叠\n\n比如，下面的代码原本的 margin 是要纵向重叠的：\n\n\n\n修改后外边距不再重叠：\n\n\n\n * 经典的清除浮动方法之一\n\n给元素设置浮动，会使元素脱离标准流，造成父元素高度坍塌。BFC 会将浮动的高度计算到父元素高度内，从而达到清除元素的效果。\n\n原本造成浮动的代码如下：\n\n\n\n修改后为：\n\n\n\n清除浮动，bfc 加在父元素部分\n\n * 阻止元素被浮动元素覆盖\n\n假设代码如下：\n\n\n\nfloatDiv 脱离标准流后会遮挡 normalDiv，效果如下\n\n\n\n添加 bfc 之后，效果如下图：\n\n","routePath":"/docs/css/01-bfc","lang":"","toc":[{"text":"触发 BFC 的条件","id":"触发-bfc-的条件","depth":2,"charIndex":248},{"text":"BFC 的作用","id":"bfc-的作用","depth":2,"charIndex":464}],"domain":"","frontmatter":{},"version":""},{"id":37,"title":"清除浮动","content":"#\n\n多个块级元素纵向排列可以用标准流实现，多个块级元素横向排列可以用 float（浮动）实现\n\n它的特性为：\n\n * 浮动元素会脱离标准流\n   * 脱离标准流的控制（浮），移动到指定位置（动）\n   * 浮动的盒子不再保留原先的位置\n * 如果多个盒子都设置了浮动，则它们一行显示并且顶端对齐排列\n * 任何元素都可以浮动，浮动元素具有行内块元素的特点\n   * 如果块级盒子没有设置宽度，默认是和父级元素一样宽，但是添加浮动后，它的宽度根据内容来决定\n   * 浮动的盒子中间是没有间隙的\n\n\n浮动的取值#\n\n值：left | right | none | inherit\n\n\n浮动布局的注意点#\n\n * 一般浮动布局时，需要和父盒子搭配\n   \n   先用父盒子排列上下位置，之后内部子元素采用浮动左右排列\n\n * 一个元素浮动了，理论上其余的兄弟元素也要浮动\n   \n   浮动的盒子只会影响盒子后面的标准流，不会影响前面的标准流\n\n\n清除浮动#\n\n使用浮动可能会导致父盒子高度坍塌，如下面例子所示：\n\n\n\n效果为：\n\n\n\n而我们需要父元素的高度，将子元素包围起来，也就是清除浮动，清除浮动后的效果如下：\n\n\n\n清除浮动的本质\n\n * 清除浮动的本质就是清除浮动元素造成的影响\n * 如果父元素本身有高度，则不需要清除浮动\n * 清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了\n\n清除浮动的办法\n\n清除浮动的中心思想就是——闭合浮动，让浮动只影响父元素内部，不影响父元素外部。\n\n清除浮动一般有四种办法，分别是：\n\n 1. 额外标签法——隔墙法，是 W3C 推荐的做法\n 2. 父级添加 :after 伪元素法\n 3. 父级添加双伪元素法\n 4. 父级添加 overflow 属性\n\n(1) 额外标签法\n\n前三个方法都需要用到一个属性 clear，clear 是专门用来清除浮动的属性。\n\n使用 clear 的语法为：\n\n\n\nclear 拥有的属性值列举如下：\n\n属性值     描述\nleft    不允许左侧有浮动元素（清除左侧浮动的影响）\nright   不允许右侧有浮动元素（清除右侧浮动的影响）\nboth    同时清除左右两侧浮动的影响\n\n实际中，几乎只用到 clear: both;\n\n下面是额外标签法的代码：\n\n\n\n * 优点：通俗移动，书写方便\n * 缺点：添加许多无意义的标签，结构化较差\n\n（2）父级添加 :after 伪元素\n\n:after 方式是额外标签法的升级版，也是给父元素添加标签，只不过使用伪元素添加\n\n\n\n（3）父元素添加双伪元素清除浮动\n\n这种方式和（2）类似\n\n\n\n（4）4.2.4 父级添加 overflow 属性\n\n这是让父级元素符合 BFC 规范，BFC 规范本身就是元素内部形成一块隔离的空间，因此，只需要给父元素田间 overflow: hidden; 就可以了\n\n","routePath":"/docs/css/02-clear-float","lang":"","toc":[{"text":"浮动的取值","id":"浮动的取值","depth":2,"charIndex":249},{"text":"浮动布局的注意点","id":"浮动布局的注意点","depth":2,"charIndex":291},{"text":"清除浮动","id":"清除浮动-1","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":38,"title":"圣杯布局","content":"#\n\n圣杯布局的样式为：\n\n * 三栏布局，中间一栏最先加载和渲染（内容最重要）\n * 两侧内容固定，中间内容随着宽度自适应\n * 一般用于 PC 网页\n\n圣杯布局的技术总结：\n\n * 使用 float 布局\n * 两侧使用 margin 负值，以便和中间内容横向重叠\n * 防止中间内容被两侧覆盖，会使用 padding 为两侧预留位置\n\n下面开始一步步实现圣杯布局\n\n\n最初的 DOM 元素和 CSS 样式#\n\nhtml 结构结构如下，center 在 left 和 right 之上：\n\n\n\ncss 结构如下，body 必须有 min-width\n\n\n\n效果为：\n\n\n\n\n添加浮动#\n\n为 center, left 和 right 添加类 column，在类 column 的 css 中添加浮动：\n\n\n\n\n\n效果为：\n\n\n\n\n清除浮动#\n\n上一节中让 center 之后的子元素全部浮动了起来，而 footer 应该保持在底部，所以要清除浮动：\n\n\n\n效果为：\n\n\n\n\n通过 padding 让 center 留出空位给 left 和 right#\n\n给 container 设置 padding-left 和 padding-right，其中，padding-left 等于 left\n的宽度，padding-right 等于 right 的宽度\n\n\n\n效果为：\n\n\n\n\n给 left 设置 margin-left 负值，让 left 和 center 的左端重叠#\n\n由于是浮动，可以认为 center 的右边直接连接着 left\n\nmargin-left 负值会让元素左移，如果左移 center 的长度，就能够让 left 和 center 的左端重叠\n\n\n\n效果为：\n\n\n\n\n相对定位让 left 到达左边空出的位置#\n\n为了让 left 向左移动，可以使用相对定位，移动的长度就是 left 的长度\n\n\n\n效果为：\n\n\n\n\n给 right 设置 margin-right 负值，让 right 到达右边空出的位置#\n\nmargin-right 负值，会让 right 后面的元素左移，原因时 margin-right 取负值后会影响其他元素对 right 宽度的判断\n\n如果 margin-right 取的负值恰好为 right 的宽度，则在 center 看来，right 已经没有了宽度，因此可以直接跟在自己后面\n\n\n\n效果为：\n\n","routePath":"/docs/css/03-holy-grail-layout","lang":"","toc":[{"text":"最初的 DOM 元素和 CSS 样式","id":"最初的-dom-元素和-css-样式","depth":2,"charIndex":186},{"text":"添加浮动","id":"添加浮动","depth":2,"charIndex":288},{"text":"清除浮动","id":"清除浮动","depth":2,"charIndex":366},{"text":"通过 padding 让 center 留出空位给 left 和 right","id":"通过-padding-让-center-留出空位给-left-和-right","depth":2,"charIndex":438},{"text":"给 left 设置 margin-left 负值，让 left 和 center 的左端重叠","id":"给-left-设置-margin-left-负值让-left-和-center-的左端重叠","depth":2,"charIndex":590},{"text":"相对定位让 left 到达左边空出的位置","id":"相对定位让-left-到达左边空出的位置","depth":2,"charIndex":746},{"text":"给 right 设置 margin-right 负值，让 right 到达右边空出的位置","id":"给-right-设置-margin-right-负值让-right-到达右边空出的位置","depth":2,"charIndex":821}],"domain":"","frontmatter":{},"version":""},{"id":39,"title":"双飞翼布局","content":"#\n\n双飞翼布局与圣杯布局的样式一样，都是：\n\n * 三栏布局，中间一栏最先加载和渲染（内容最重要）\n * 两侧内容固定，中间内容随着宽度自适应\n * 一般用于 PC 网页\n\n双飞翼的技术总结：\n\n * 使用 float 布局\n * 两侧使用 margin 负值，以便和中间内容横向重叠\n * 防止中间内容被两侧覆盖，会使用 margin 为两侧预留位置\n\n下面开始一步步实现双飞翼布局\n\n\n最初的 DOM 元素和 CSS 样式#\n\nhtml 结构如下，main 在 left 和 right 之上，main 中还有 main-wrap：\n\n\n\ncss 结构如下：body 中必须有 min-width：\n\n\n\n效果为：\n\n\n\n\n添加浮动#\n\n为 main，left 和 right 添加类 column，在类 column 的 css 中添加浮动：\n\n\n\n\n\n效果为：\n\n\n\n\n通过 margin 让 main-wrap 留出空位给 left 和 right#\n\n\n\n由于只是留出空位，效果并不明显：\n\n\n\n\n给 left 设置 margin-left 负值，让 left 移动到指定空位#\n\nleft 取的 margin 负值是 -100%:\n\n\n\n效果为：\n\n\n\n\n给 right 设置 margin-left 负值，让 right 移动到指定位置#\n\n\n\n效果为：\n\n","routePath":"/docs/css/04-double-wings-layout","lang":"","toc":[{"text":"最初的 DOM 元素和 CSS 样式","id":"最初的-dom-元素和-css-样式","depth":2,"charIndex":195},{"text":"添加浮动","id":"添加浮动","depth":2,"charIndex":314},{"text":"通过 margin 让 main-wrap 留出空位给 left 和 right","id":"通过-margin-让-main-wrap-留出空位给-left-和-right","depth":2,"charIndex":389},{"text":"给 left 设置 margin-left 负值，让 left 移动到指定空位","id":"给-left-设置-margin-left-负值让-left-移动到指定空位","depth":2,"charIndex":455},{"text":"给 right 设置 margin-left 负值，让 right 移动到指定位置","id":"给-right-设置-margin-left-负值让-right-移动到指定位置","depth":2,"charIndex":535}],"domain":"","frontmatter":{},"version":""},{"id":40,"title":"margin 坍塌/重叠","content":"#\n\nmargin 纵向重叠一般有三种情形：\n\n * 相邻的兄弟元素 margin 重叠\n * 父级和第一个/最后一个子元素重叠\n * 空的 block 元素重叠\n\n其中，相邻的兄弟元素 margin 重叠是典型情况，就不再介绍\n\n\n父级和第一个/最后一个子元素重叠#\n\n请先看一个例子，图中的 margin-left 可以撑开父元素，但是 margin-top 却没有撑开父元素，这就是父元素与子元素的 margin 重叠\n\n\n\n如果给父元素添加 border-top 就可以解决 margin-top 的重叠问题，给父元素添加 border-bottom 就可以解决\nmargin-bottom 的重叠问题\n\n\n\n\n形成 margin-top 重叠的原因#\n\n 1. 父元素非块状格式化上下文（BFC）元素\n 2. 父元素没有 border-top 设置\n 3. 父元素没有 padding-top 设置\n 4. 父元素和第一个子元素之间没有 inline 元素分割\n\n\n形成 margin-bottom 重叠的原因#\n\n 1. 父元素非块状格式化上下文（BFC）元素\n 2. 父元素没有 border-top 设置\n 3. 父元素没有 padding-top 设置\n 4. 父元素和第一个子元素之间没有 inline 元素分割\n 5. 父元素没有 height, min-height 和 max-height 的限制\n\n\n空的 block 元素重叠#\n\n请看一道试题：\n\n\n\n * 相邻元素的 margin-top 和 margin-bottom 会发生重叠\n * 空白内容的\n   \n   \n   \n   也会重叠\n * 答案：15px\n\n这就是空的 block 元素重叠\n\n\n空 block 元素重叠的条件#\n\n 1. 元素没有 border 设置\n 2. 元素没有 padding 设置\n 3. 元素里面没有 inline 元素\n 4. 元素没有 height, 或者 min-height\n\n\nmargin 重叠的计算#\n\n可以用三句口诀总结\n\n * 正正取大值\n * 正负值相加\n * 负负最负值\n\n\nmargin 重叠的应用#\n\n","routePath":"/docs/css/05-margin-collapse","lang":"","toc":[{"text":"父级和第一个/最后一个子元素重叠","id":"父级和第一个最后一个子元素重叠","depth":2,"charIndex":116},{"text":"形成 `margin-top` 重叠的原因","id":"形成-margin-top-重叠的原因","depth":2,"charIndex":-1},{"text":"形成 `margin-bottom` 重叠的原因","id":"形成-margin-bottom-重叠的原因","depth":2,"charIndex":-1},{"text":"空的 block 元素重叠","id":"空的-block-元素重叠","depth":2,"charIndex":614},{"text":"空 block 元素重叠的条件","id":"空-block-元素重叠的条件","depth":2,"charIndex":743},{"text":"margin 重叠的计算","id":"margin-重叠的计算","depth":2,"charIndex":854},{"text":"margin 重叠的应用","id":"margin-重叠的应用","depth":2,"charIndex":909}],"domain":"","frontmatter":{},"version":""},{"id":41,"title":"margin 负值","content":"#\n\n\n规律总结#\n\n\n元素有自身宽度时#\n\n * margin-top 负值，元素向上移动\n * margin-bottom 负值，元素自身不受影响，下方元素向上移动\n * margin-left 负值，元素向左移动\n * marginright 负值，元素自身不受影响，右侧元素向左移动\n\n表现如下方的四幅图：\n\n * margin-top 负值\n   \n   \n\n * margin-bottom 负值\n   \n   \n\n * margin-left 负值\n   \n   \n\n * margin-right 负值\n   \n   \n\n\n元素没有自身宽度, 即 width:auto; 时#\n\n * margin-top 负值，元素向上移动\n * margin-bottom 负值，元素自身不受影响，下方元素向上移动\n * margin-left 负值，元素宽度向左变宽\n * margin-right 负值，元素宽度向右变宽\n\n> 这是因为设置元素宽度为 auto 后\n> \n> 左右 margin + 左右 border + 左右 padding + width = 父元素 width\n> \n> 当 margin-left 或 margin-right 取负值后，为了完成等式，width 会相应地向 left 或 right 方向增加\n\nmargin-top 和 margin-bottom 的表现和 1.1 一致，所以下面仅展示 margin-left 和 margin-right 的值\n\n * margin-left 负值\n   \n   \n\n * margin-right 负值\n   \n   \n\n\nmargin 负值的应用#\n\n * 子绝父相 + margin 负值实现水平垂直居中\n\n子绝父相 即子元素用绝对定位，父元素用相对定位。\n\n如下图所示：\n\n","routePath":"/docs/css/06-negative-margin","lang":"","toc":[{"text":"规律总结","id":"规律总结","depth":2,"charIndex":3},{"text":"元素有自身宽度时","id":"元素有自身宽度时","depth":3,"charIndex":11},{"text":"元素没有自身宽度, 即 `width:auto;` 时","id":"元素没有自身宽度-即-widthauto-时","depth":3,"charIndex":-1},{"text":"margin 负值的应用","id":"margin-负值的应用","depth":2,"charIndex":707}],"domain":"","frontmatter":{},"version":""},{"id":42,"title":"git","content":"#\n\n\n本地分支和远程分支关联#\n\n\n\n","routePath":"/docs/git/","lang":"","toc":[{"text":"本地分支和远程分支关联","id":"本地分支和远程分支关联","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":43,"title":"配置环境","content":"#\n\n\n\n\n\n\n\n\n\n","routePath":"/docs/go/01-env","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":44,"title":"变量和常量","content":"#\n\n\n变量#\n\n和其他语言不同，go 语言声明变量时，跟随在 var 后面的首先是变量名，然后是变量类型。\n\n\n\n\n\ngo 变量如果没有初始化，那么默认会设置一些值。\n\n * 数值类型（包括 complex64/128）为 0\n * 布尔类型为 false\n * 字符串为 \"\"（空字符串）\n * 以下几种类型为 nil\n\n\n\ngo 语言可以根据值自信判断变量类型。\n\n\n\n声明和变量都可以缩写\n\n\n\n上述代码和下方写法等价：\n\n\n\n还有一种写法，通常适用于定义全局变量。\n\n\n\n\n常量#\n\n常量的语法和上述变量的语法基本一致。但是有一些特殊的地方。\n\n 1. 和其他语言不同，go 的常量一般不会全大写。\n 2. go 没有单独的枚举类型，一般会直接使用常量来做枚举。\n\n\n\n 3. 有一个 iota 的特殊常量，能够赋值给常量。他可以作为是 const 语句块的自增下标。\n\n\n\n上述代码等价于：\n\n","routePath":"/docs/go/02-variables-and-constants","lang":"","toc":[{"text":"变量","id":"变量","depth":2,"charIndex":3},{"text":"常量","id":"常量","depth":2,"charIndex":241}],"domain":"","frontmatter":{},"version":""},{"id":45,"title":"数据类型","content":"#\n\n * 布尔类型\n * 字符串类型\n * 数字类型\n   * 整型\n     * uint8\n     * uint16\n     * uint35\n     * uint64\n     * int8\n     * int16\n     * int32\n     * int64\n   * 浮点型\n     * float32\n     * float64\n     * complex64\n     * complex128\n   * 其他\n * 派生类型\n   * 指针类型\n   * 数组类型\n   * 结构化类型\n   * Channle 类型\n   * 函数类型\n   * 切片类型\n   * 接口类型\n   * Map 类型","routePath":"/docs/go/03-data-types","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":46,"title":"字符串占位符","content":"#\n\n本文所提到的占位符，均可以到 go 官网查看: https://pkg.go.dev/fmt\n\n\n普通占位符#\n\n占位符   说明\n%v    相应值的默认格式。\n%+v   打印结构体时，会添加字段名\n%#v   相应值的 go 语法表示\n%T    相应值的类型的 go 语法表示\n%%    字面上的百分号，并非值的占位符\n\n\n\n\n布尔占位符#\n\n占位符   说明\n%t    true 或者 false\n\n\n\n\n整数占位符#\n\n占位符   说明\n%b    二进制表示\n%o    八进制表示\n%d    十进制表示\n%x    十六进制表示，字母形式为小写 a-f\n%X    十六进制表示，字母形式为大写 A-F\n%c    相应 Unicode 码点所表示的字符\n%q    单引号围绕的字符字面值，由 go 语法安全地转义\n%U    Unicode 格式：U+1234，等同于 “U+%04X”\n\n\n\n\n\n占位符    说明\n%2d    将整数格式化为十进制的形式，如果整数的位数不足 4 位，则在前面补空格，直到整数的位数为 2 位。\n%02d   将整数格式化为十进制的形式，如果整数的位数不足 2位 ，则在前面补 0，直到整数的位数为 2 位。\n\n\n\n\n浮点数和复数的组成部分（实部和虚部）#\n\n占位符   说明\n%b    无小数部分，指数为二的幂的科学计数法，与 strconv.FormatFloat 的 'b' 转换格式一致。\n%e    科学计数法，例如 -1234.456e+78\n%E    科学计数法，例如 -1234.456E+78\n%f    有小数点而无指数，例如 123.456\n%g    根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出\n%G    根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出\n\n\n\n\n字符串和字符切片#\n\n占位符   说明\n%s    输出字符串 (string 类型或 []byte)\n%q    双引号围绕的字符串，由 go 语法安全地转义\n%x    十六进制，小写字母，每字节两个字符\n%X    十六进制，大写字母，每字节两个字符\n\n","routePath":"/docs/go/03-placeholder","lang":"","toc":[{"text":"普通占位符","id":"普通占位符","depth":2,"charIndex":51},{"text":"布尔占位符","id":"布尔占位符","depth":2,"charIndex":171},{"text":"整数占位符","id":"整数占位符","depth":2,"charIndex":212},{"text":"浮点数和复数的组成部分（实部和虚部）","id":"浮点数和复数的组成部分实部和虚部","depth":2,"charIndex":542},{"text":"字符串和字符切片","id":"字符串和字符切片","depth":2,"charIndex":797}],"domain":"","frontmatter":{},"version":""},{"id":47,"title":"rune","content":"#\n\n在介绍 rune 之前，我们先看一段运行的结果。\n\n\n\n这是为什么呢？我们知道，字符底层是由字节序列构成的，在 go 语言底层，英文只占了 1 字节，而中文则占了 3 字节，所以长度就是 1 * 2 + 3 * 2\n= 8。\n\n\n定义#\n\ngo 语言中有两种定义方式，一种是「类型定义声明」，比如 int string 等；另外一种是「类型别名声明」，rune 和 byte 就是 go\n语言原生的两个类型别名，专门用来处理字符。\n\ngo 语言把字符分为 byte 和 rune 两种类型处理。byte 是类型 uint8 的别名，用于存放占 1 字节的 ASCII 码。rune 是类型\nint32 的别名，用于存放多字节的字符，比如 3 字节的中文符号。\n\n\n\n\n\n现在我们再回看文章开始时的问题，我们可以这样解决？\n\n","routePath":"/docs/go/03-rune","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":117}],"domain":"","frontmatter":{},"version":""},{"id":48,"title":"条件、循环语句","content":"#\n\n\n条件语句#\n\n * if 不需要用括号包围\n * switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用\n   fallthrough\n\n\n循环语句#\n\n * for 不需要用括号包围\n * go 语言没有 while 和 do while，全部都是用 for 来解释\n * go 语言可以利用 for 循环遍历数组、Map 等\n\n\n\n\n\n\n\n\n\n\ngoto 语句#\n\n","routePath":"/docs/go/04-if-switch","lang":"","toc":[{"text":"条件语句","id":"条件语句","depth":2,"charIndex":3},{"text":"循环语句","id":"循环语句","depth":2,"charIndex":117},{"text":"goto 语句","id":"goto-语句","depth":2,"charIndex":222}],"domain":"","frontmatter":{},"version":""},{"id":49,"title":"函数","content":"#\n\n\n\n函数定义解析：\n\n * func：函数声明\n * function_name：函数名称\n * parameter_list：参数列表，数列表指定的是参数类型、顺序、及参数个数。函数也可以不包含参数。\n * return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下\n   return_types 不是必须的。\n * 函数体：函数定义的代码集合。\n\ngo\n语言的函数参数传递方式是值传递。这意味着当你将一个变量传递给函数时，函数会接收到这个变量的一个副本，而不是原始变量的引用。因此，如果你在函数内部改变了这个副本的\n值，原始变量的值不会改变。\n\n然而，go\n语言的切片（slice）、映射（map）和通道（channel）等类型的变量，虽然在传递给函数时也是值传递，但是它们的值其实是一个指向底层数据结构的指针。因此，\n如果你在函数内部改变了这些类型的变量，那么原始变量所指向的底层数据结构的值也会改变。这种情况下，虽然严格来说仍然是值传递，但是它的行为看起来更像是引用传递。\n\n\n\n\n\n\n函数作为参数#\n\n\n\n\n函数作为返回值#\n\n函数作为返回值时，有一种特殊情况称之为「闭包」。如果一个函数返回另一个函数，并且这个返回的函数引用了外部函数的变量，那么这个函数就可以被认为是一个闭包。\n\n\n\n\n匿名函数#\n\ngo 的匿名函数类似于 js 的箭头函数，可以直接在函数体里定义，并赋值给一个变量。\n\n","routePath":"/docs/go/05-func","lang":"","toc":[{"text":"函数作为参数","id":"函数作为参数","depth":2,"charIndex":486},{"text":"函数作为返回值","id":"函数作为返回值","depth":2,"charIndex":498},{"text":"匿名函数","id":"匿名函数","depth":2,"charIndex":589}],"domain":"","frontmatter":{},"version":""},{"id":50,"title":"数组","content":"#\n\n\n声明数组#\n\n\n\n数组定义解析：\n\n * arrName 是数组的名称\n * size 是数组的大小\n * dataType 是数组中元素的数据类型\n\n\n初始化数组#\n\n默认初始化\n\n\n\n利用初始化列表初始化数组\n\n\n\n数组长度不确定\n\n如果数组长度不确定，可以使用 ... 代替数组的长度，编译器会根据元素个数自行推断数组的长度：\n\n\n\n\n多维数组（以二维数组为例）#\n\n初始化数组\n\n\n\n利用 append 添加数组项\n\n\n\n\n向函数传递数组#\n\ngo 语言中的数组是值类型，因此在将数组传递给函数时，实际上是传递数组的副本。\n\n","routePath":"/docs/go/06-arr","lang":"","toc":[{"text":"声明数组","id":"声明数组","depth":2,"charIndex":3},{"text":"初始化数组","id":"初始化数组","depth":2,"charIndex":80},{"text":"多维数组（以二维数组为例）","id":"多维数组以二维数组为例","depth":2,"charIndex":174},{"text":"向函数传递数组","id":"向函数传递数组","depth":2,"charIndex":219}],"domain":"","frontmatter":{},"version":""},{"id":51,"title":"切片","content":"#\n\ngo 语言中数组是不可变的，切片是对数组的抽象。与数组相比，切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。\n\n\n定义#\n\n切片有两种定义方式：\n\n * 声明一个未指定长度的数组\n   \n   \n\n * 使用 make 创建切片\n   \n   \n\n\nlen() 和 cap()#\n\ngo 语言中，切片由三部分组成：指针、长度和容量。指针指向切片的首个元素，长度表示切片中元素的数量，容量表示切片的最大长度。\n\n用 len() 可以获取长度，用 cap() 可以获取容量。\n\n\n\n\n截取#\n\n可以通过设置下限、上限，来将数组截取成切片。\n\n\n\n切片还可以再次截取成为新的切片。\n\n\n\ngo 语言中，切片、切片的切片、还有数组是共享内存空间的。因此切片的容量常常大于它的长度。\n\ngo 语言有个特性，当从一个切片创建另一个切片时，我们可以指定一个大于原始切片长度但是小于等于原始切片容量的结束索引。\n\n\n\n\n和数组的内存关系#\n\n一般来说，切片和数组的内存是共享的，因此修改切片的元素，数组的元素也会被改变。\n\n\n\n但是，如果你添加的元素数量超过了切片的容量，那么 Go\n语言会创建一个新的数组，并将所有的元素（包括原始的元素和新添加的元素）复制到新的数组中。在这种情况下，切片不再共享原始数组的内存空间，而是指向新的数组。\n\n","routePath":"/docs/go/06-slice","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":68},{"text":"len() 和 cap()","id":"len-和-cap","depth":2,"charIndex":136},{"text":"截取","id":"截取","depth":2,"charIndex":251},{"text":"和数组的内存关系","id":"和数组的内存关系","depth":2,"charIndex":413}],"domain":"","frontmatter":{},"version":""},{"id":52,"title":"指针","content":"#\n\n\n取地址符 &#\n\n变量是一种使用方便的占位符，用于引用计算机内存地址。go 语言的取地址符是 &，放到一个变量前使用就会返回相应变量的内存地址。\n\n\n\n\n指针定义和使用#\n\n指针使用流程：\n\n * 定义指针变量。\n * 为指针变量赋值。\n * 访问指针变量中指向地址的值。\n\n一个指针变量指向了一个值的内存地址。在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。\n\n\n\n\n空指针#\n\n当一个指针被定义后没有分配到任何变量时，它的值为 nil。nil 指针也称为空指针。\n\n\n\n\n指针数组#\n\n案例：指针数组，每个指针都指向一个变量。\n\n\n\n案例：指针数组，每个指针都指向一个数组。\n\n\n\n\n指针作为函数的参数#\n\n\n\n","routePath":"/docs/go/07-pointer","lang":"","toc":[{"text":"取地址符 &","id":"取地址符-","depth":2,"charIndex":3},{"text":"指针定义和使用","id":"指针定义和使用","depth":2,"charIndex":80},{"text":"空指针","id":"空指针","depth":2,"charIndex":193},{"text":"指针数组","id":"指针数组","depth":2,"charIndex":246},{"text":"指针作为函数的参数","id":"指针作为函数的参数","depth":2,"charIndex":302}],"domain":"","frontmatter":{},"version":""},{"id":53,"title":"结构体","content":"#\n\n结构体是由一系列数据构成的数据集合。\n\n\n\n结构体作为参数传递给函数，go 语言中的结构体是值类型，因此在将结构体传递给函数时，实际上是传递结构体的副本。\n\n\n\n\n\n\n方法和接收者#\n\ngo 语言中的方法 (Method) 是一种作用于特定变量类型的函数。这种特定类型变量叫做接收者（Receiver），接收者的概念就类似于其他语言中的 this\n或者 self。\n\n方法定义格式如下：\n\n\n\n方法的定义方式和函数的定义方法，只是将 (vname vtype) 和 func_name(parameter_list) 做一个调换。其中:\n\n * vname 是接收者变量，他在命名时官方建议使用 vtype 的第一个小写字母，而不是 self 和 this 之类的变量名。例如，Person\n   类型的接收者变量应该命名为 p，Connector 类型的接收者变量应该命名为 c 等。\n * vtpe 是接收者类型，可以是指针类型和非指针类型。\n * func_name, paramter_list 和 return_types 具体格式与函数相同。\n\n\n\n\n其余的初始化方法#\n\n\nnew 操作符#\n\n可以使用 new 来初始化结构体，此时结构体内部属性的值默认为该属性的零值。\n\n\n\n\n& 取结构体的地址实例化#\n\n使用 & 对结构体取地址，相当于对该结构体类型进行了一次 new 实例化操作。\n\n\n\n\n不同初始化方法的区别#\n\n我们看到，Person{}、new(Person) 和 &Person{} 都可以初始化结构体，那么它们有什么区别呢？\n\nman = Person{} 这种方式，man 是一个变量，它是 Person 的实例。当你修改 man 的字段时，你是在修改实例的字段，和 Person\n本身无关。\n\nman = new(Person) 和 &Person{} 这种方式，man 是一个指针。它是 Person 的指针。当你修改 man 的字段时，所有指向\nPerson 的指针的字段都会改变。\n\n\n\n\n方法参数用变量还是指针？#\n\n在 go 语言中，如果一个方法不会修改结构体内部的值，那么从结果上看，无论参数是变量还是指针，都不会有影响。\n\n\n\n但是从性能、内存分配和可读性考虑，一般我们还是会注意区分参数是变量还是指针。一般以下情况我们会考虑使用指针：\n\n 1. 需要修改接收器中的值。\n 2. 结构体比较大的时候。如果结构体非常大，那么将其作为值类型传递会消耗更多的内存和 CPU，因为 go\n    需要复制整个结构体。在这种情况下，使用指针类型可以提高性能，因为指针只需要存储一个内存地址。\n 3. 希望保持一致性的时候。如果你的某些方法需要修改结构体的值（因此需要使用指针），那么为了保持一致性，你可能会希望所有的方法都使用指针，即使有些方法并不需要\n    修改结构体的值\n\n\n构造函数#\n\ngo 语言中没有原生的构造函数，我们可以自己写一个。这里考虑到性能，我们使用的是指针。\n\n\n\n\n私有变量、公有变量、私有方法和公有方法#\n\n在 go 语言中，变量的公有或私有取决于其名称的首字母是否大写。\n\n * 如果变量、函数、类型等名称首字母大写，那么它就是公有的，也就是说，它可以被其他包访问。\n * 如果名称首字母小写，那么它就是私有的，只能在当前包内部访问，不能被其他包访问。\n\n\n匿名字段和内嵌结构体#\n\n\n匿名字段#\n\n结构体内部可以包含一个或多个匿名字段，这些字段可以没有名字，只有类型，此时类型就是字段的名字。\n\n\n\n\n内嵌结构体#\n\n匿名字段本身可以是一个结构体类型，也就是说结构体可以内嵌结构体。\n\n\n\n\n重载#\n\n当内层结构体和外层结构体拥有相同的名字时，外层名字会覆盖内层名字（但是二者的内存空间均存在），这提供了一种重载字段、方法的方式。\n\n\n\n\n自建 String() 方法#\n\n如果类型定义了 String() 方法，它就会在 fmt.Println() 和 fmt.Printf() 时自动使用 String() 方法。\n\n","routePath":"/docs/go/08-struct","lang":"","toc":[{"text":"方法和接收者","id":"方法和接收者","depth":2,"charIndex":86},{"text":"其余的初始化方法","id":"其余的初始化方法","depth":2,"charIndex":484},{"text":"new 操作符","id":"new-操作符","depth":3,"charIndex":496},{"text":"& 取结构体的地址实例化","id":"-取结构体的地址实例化","depth":3,"charIndex":549},{"text":"不同初始化方法的区别","id":"不同初始化方法的区别","depth":2,"charIndex":608},{"text":"方法参数用变量还是指针？","id":"方法参数用变量还是指针","depth":2,"charIndex":868},{"text":"构造函数","id":"构造函数","depth":2,"charIndex":1213},{"text":"私有变量、公有变量、私有方法和公有方法","id":"私有变量公有变量私有方法和公有方法","depth":2,"charIndex":1268},{"text":"匿名字段和内嵌结构体","id":"匿名字段和内嵌结构体","depth":2,"charIndex":1416},{"text":"匿名字段","id":"匿名字段","depth":3,"charIndex":1430},{"text":"内嵌结构体","id":"内嵌结构体","depth":3,"charIndex":1489},{"text":"重载","id":"重载","depth":2,"charIndex":1534},{"text":"自建 String() 方法","id":"自建-string-方法","depth":3,"charIndex":1608}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"map","content":"#\n\n\n定义#\n\n\n\n\n增、删、查、改#\n\n\n\n\n遍历#\n\n","routePath":"/docs/go/09-map","lang":"","toc":[{"text":"定义","id":"定义","depth":2,"charIndex":3},{"text":"增、删、查、改","id":"增删查改","depth":2,"charIndex":11},{"text":"遍历","id":"遍历","depth":2,"charIndex":24}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"时间","content":"#\n\n","routePath":"/docs/go/10-time","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":56,"title":"defer","content":"#\n\ndefer 是 go 语言的延迟执行语句。添加 defer 的语句，会被放到函数返回前处理。\n\n\n\n同样被 defer 的语句，先被 defer 的语句最后执行，最后被 defer 的语句最先执行，类似栈的执行顺序。\n\n\n\ndefer 常用来处理业务逻辑中成对的操作，比如打开文件和关闭文件，接收请求和回复请求，加锁和解锁等等。\n\n","routePath":"/docs/go/11-defer","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":57,"title":"错误","content":"#\n\n\n错误处理#\n\n一般如果 go 语言的函数可能发生错误，那么它会有两个返回值，第一个返回值是正常返回值，第二个返回值就是错误。\n\n如果发生错误时，第二个返回值不再时 nil，而是一个错误类型的数据，需要我们加以处理。\n\n比如打开文件时，文件可能打开失败。\n\n\n\n\n自定义错误#\n\n如果编写一个函数，函数内部可能发生错误，你最好让函数的返回值中也包含错误。为此，你需要用到 errors.New() 来创建错误。\n\n比如创建一个除法函数，你需要考虑除数为 0 时发生错误的情况。\n\n\n\n\n自定义信息更丰富的错误#\n\n使用 errors.New() 创建的字符串信息，无法携带更多信息。但很多时候，为了方便排查报错，你可以自定义结构体实现错误接口。\n\n比如创建一个解析文件错误，你需要告诉用户出错的文件名和行号。\n\n","routePath":"/docs/go/12-error","lang":"","toc":[{"text":"错误处理","id":"错误处理","depth":2,"charIndex":3},{"text":"自定义错误","id":"自定义错误","depth":2,"charIndex":134},{"text":"自定义信息更丰富的错误","id":"自定义信息更丰富的错误","depth":2,"charIndex":245}],"domain":"","frontmatter":{},"version":""},{"id":58,"title":"宕机","content":"#\n\n宕机就是程序停止运行，服务中断，通常来说是严重的错误。\n\n一般 go 语言宕机时，会立刻执行在 goroutine（可以先理解为线程）中被延迟的函数（defer 机制），随后程序会立刻输出日志信息，包括 panic\nvalue 和函数调用的堆栈跟踪信息。\n\n\n手动触发宕机#\n\ngo 语言中，我们可以直接用 panic() 触发宕机。\n\n\n\ngo 语言会输出如下报错信息：\n\n\n\n\n在宕机时触发延迟执行语句#\n\n\n\ncarsh 之前的 defer 语句会在宕机之前执行，crash 之后的 defer 语句不会执行。","routePath":"/docs/go/13-panic","lang":"","toc":[{"text":"手动触发宕机","id":"手动触发宕机","depth":2,"charIndex":132},{"text":"在宕机时触发延迟执行语句","id":"在宕机时触发延迟执行语句","depth":2,"charIndex":193}],"domain":"","frontmatter":{},"version":""},{"id":59,"title":"宕机恢复","content":"#\n\nrecover 可以让进入宕机状态的 goruntine 恢复执行。\n\n它仅在 defer 语句中有效，其他情况下调用 recover 返回 nil 并且没有其他影响。\n\n通常来说，不应该对进入 panic 宕机的程序做任何处理，但有时，需要我们可以从宕机中恢复，至少我们可以在程序崩溃前，做一些操作，举个例子，当 web\n服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭，如果不做任何处理，会使得客户端一直处于等待状态，如果 web\n服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试\n\npanic 和 recover 的组合有如下特性：\n\n * 有 panic 没 recover，程序宕机。\n * 有 panic 也有 recover，程序不会宕机，执行完对应的 defer 后，从宕机点退出当前函数后继续执行。\n\n\n\n上述函数打印结果为：\n\n\n\n也就是说，go 函数宕机后，退出了 ProtectRun() 并继续执行。","routePath":"/docs/go/14-recover","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":60,"title":"布局视口、视觉视口和理想视口","content":"#\n\nvscode 默认生成的 HTML 中，会看到下面这段代码。这段代码和移动端的适配有关。\n\n\n\n首先，我们需要知道一个概念，视口（viewport），也就是我们在浏览器中看到的区域。1\n\n在移动端，布局的视口和可见的视口并不一样，我们可以将视口分为三种情况：2\n\n * 布局视口（layout viewport）\n * 视觉视口（visual viewport）\n * 理想视口（ideal viewport）\n\n\n布局视口#\n\n默认情况下，一个 PC 端的网页，在移动端会如何显示呢？\n\n 1. 它会按照宽度为 980px 来布局一个页面的内容。\n 2. 为了可以完整地显示在页面中，对整个页面进行缩小。\n\n这个 980px 的视口，就是布局视口（layout viewport）。\n\n\n视觉视口#\n\n如果默认情况下，我们按照 980px 显示内容，那么右侧有一部分区域就会无法显示。所以手机端浏览器会默认对页面进行缩放，以显示到用户的可见区域中。\n\n显示在这个可见区域中的，就是视觉视口（visual viewport）。\n\n\n理想视口#\n\n默认情况下的 layout view 并不适合我们进行布局，我们可以对 layout viewport 进行宽度和缩放的设置，以满足一个移动端窗口的布局。\n\n值               可能的附加值                      描述\nwidth           一个正整数，或者字符串 device-width    定义 viewport 的宽度\nheight          一个正整数，或者字符串 device-height   定义 viewport 的高度, 一般不会设置\ninitial-scale   一个 0.0 和 10.0 之间的正数         定义设备宽度和 viewport 的缩放比例\nmaximum-scale   一个 0.0 和 10.0 之间的正数         定义缩放的最大值\nminimum-scale   一个 0.0 和 10.0 之间的正数         定义缩放的最小值\nuser-scalable   yes, 1 或者 no, 0             默认为 yes，如果设置为 no，将无法缩放当前页面，部分浏览器可能忽略此规则\n\n下面给出一段比较可靠的设置理想视口的代码：\n\n\n\n\nFootnotes\n\n 1. HTML+CSS 《移动端适配方案》 ↩\n\n 2. layout viewport, visual viewport 和 ideal viewport 的概念来源于\n    ppk，他是一个在移动端浏览器贡献较大的程序员 ↩","routePath":"/docs/html/01-layout-visual-and-ideal-viewport","lang":"","toc":[{"text":"布局视口","id":"布局视口","depth":2,"charIndex":210},{"text":"视觉视口","id":"视觉视口","depth":2,"charIndex":347},{"text":"理想视口","id":"理想视口","depth":2,"charIndex":468}],"domain":"","frontmatter":{},"version":""},{"id":61,"title":"","content":"","routePath":"/docs/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":62,"title":"String 类型","content":"#\n\n\n转换数值#\n\n有 3 个函数可以将非数值转换为数值，Number(), parseInt() 和 parseFloat()。\n\n * Number() 是转型函数，可用于任何数据类型\n * 后两个函数主要用于将字符串转换为数值\n * 对于同样的参数, 这 3 个函数执行的操作也不同\n\n\nNumber() 函数#\n\nNumber() 函数基于如下规则执行转换：\n\n * 布尔值，true 转换为 1，false 转换为 0\n\n * 数值，直接返回\n\n * null，返回 0\n\n * undefined，返回 NaN\n\n * 字符串，应用以下规则：\n   \n   * 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值（忽略前面的 0）\n   \n   \n   \n   * 如果字符串包含有效的浮点值格式为 \"1.1\"，则会转换为相应的浮点数（忽略前面的 0）\n   \n   \n   \n   * 如果字符串包含有效的十六进制，则会转换为与十六进制数值对应的十进制数值\n   \n   \n   \n   * 如果是空字符串以及空白字符串\n   \n   \n   \n   * 如果字符串包含除上述情况之上其他字符串，则返回 NaN\n\n\nparseInt() 函数#\n\n考虑了用 Number() 函数转换字符串时相对复杂且有点反常规，通常再需要得到整数时可以有限使用 parseInt() 函数\n\n下面是三条与 Number 不一样的规则：\n\n\n\n而 parseInt() 中可以有第二个参数：第二个参数代表进制：\n\n\n\n\nparseFloat() 函数#\n\n * 16 进制数值始终会返回 0\n\n\n\n\n转换字符串#\n\n有 3 种方法可以将非字符串转换为字符串\n\n * toString() 函数\n * String() 函数\n * + 操作符\n\n\ntoString() 方法#\n\n数值，布尔值，对象和字符串都有 toString() 方法，null 的 undefined 没有：\n\n\n\n多数情况下，toString() 不接受任何参数，但在对数值调用时可以接收一个底数参数：\n\n\n\n\nString() 方法#\n\nString() 方法遵循如下规则：\n\n * 如果值有 toString() 方法，则调用该方法（不传参数）并返回结果\n * 如果值是 null，返回 ”null\"\n * 如果值是 undefined，返回 “undefined\"\n\n\n\n\n加法运算符#\n\n执行加法运算时，只要有一个是字符串，就要运用如下规则：\n\n * 如果两个操作符都是字符串，则第二个字符串拼接到第一个字符串后面\n * 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再进行拼接\n   * 有 toString() 方法就用 toString() 方法转换\n   * 没有 toString() 方法就用 String() 方法转换\n\n\n\n> 用加号操作符给一个值加上一个空字符串 \"\" 可以将其转换为字符串","routePath":"/docs/js/03-语言基础/04-数据类型/06-String","lang":"","toc":[{"text":"转换数值","id":"转换数值","depth":2,"charIndex":3},{"text":"`Number()` 函数","id":"number-函数","depth":3,"charIndex":-1},{"text":"parseInt() 函数","id":"parseint-函数","depth":3,"charIndex":530},{"text":"parseFloat() 函数","id":"parsefloat-函数","depth":3,"charIndex":674},{"text":"转换字符串","id":"转换字符串","depth":2,"charIndex":714},{"text":"`toString()` 方法","id":"tostring-方法","depth":3,"charIndex":-1},{"text":"`String()` 方法","id":"string-方法","depth":3,"charIndex":-1},{"text":"加法运算符","id":"加法运算符","depth":3,"charIndex":1040}],"domain":"","frontmatter":{},"version":""},{"id":63,"title":"布尔操作符","content":"#\n\n\n逻辑与#\n\n逻辑与操作遵循如下真值表：\n\n第一个操作数   第二个操作数   结果\ntrue     true     true\ntrue     false    false\nfalse    true     false\nfalse    false    false\n\n逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：\n\n * 如果第一个操作数是对象，则返回第二个操作数\n * 如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象\n * 如果两个操作数都是对象，则返回第二个操作数\n * 如果有一个操作数是 null，则返回 null\n * 如果有一个操作数是 NaN，则返回 NaN\n * 如果有一个操作数是 undefined，则返回 undefined\n\n逻辑与操作符是一种短路运算符，意思就是如果第一个操作数决定了结果，那么就永远不会对第二个操作数求值。\n\n对于逻辑与来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。\n\n举例如下：\n\n\n\n\n\n\n逻辑或#\n\n逻辑或遵循如下真值表：\n\n第一个操作符   第二个操作符   结果\ntrue     true     true\ntrue     false    true\nfalse    true     true\nfalse    false    false\n\n与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或也不一定返回布尔值。它遵循如下规则：\n\n * 如果第一个操作数是对象，则返回第一个操作数\n * 如果第一个操作数求值为 false，则返回第二个操作数\n * 如果两个操作数都是对象，则返回第一个操作数\n * 如果两个操作数都是 null，则返回 null\n * 如果两个操作数都是 NaN，则返回 NaN\n * 如果两个操作数都是 undefined，则返回 undefined\n\n同样与逻辑与类似，逻辑或操作数也具有短路的性质。只不过对于逻辑或而言，第一个操作数求值为 true，第二个操作数就不会被求值了。\n\n\n\n\n\n利用逻辑或的性质，可以避免给变量赋值 null 或 undefined，例如：\n\n\n\n * preferedObject 包含首选的值\n * backupObject 包含备用的值\n * 如果 preferedObject 的值不是 null 或者 undefined，则它的值回赋给 myObject\n * 如果 preferedObject 的值是 null 或者 undefined，则 backupObject 的值会赋给 myObject\n\n\n参考资料#\n\n本节内容根据 《JavaScript 高级程序设计（第 4 版）》整理。","routePath":"/docs/js/03-语言基础/05-操作符/03-布尔操作符","lang":"","toc":[{"text":"逻辑与","id":"逻辑与","depth":2,"charIndex":3},{"text":"逻辑或","id":"逻辑或","depth":2,"charIndex":504},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":1152}],"domain":"","frontmatter":{},"version":""},{"id":64,"title":"原始值与引用值","content":"#\n\n * 值类型（原始值）：按值访问，操作的就是存储在变量中的实际值\n * 引用类型（引用值）：在操作对象时，实际操作的是该对象的引用（reference）\n\n对比：\n\n 1. 原始值不能有属性，引用值可以随时添加、修改和删除其属性和方法\n 2. 通过变量把一个原始值复制给另一个变量时，复制的是原始值；通过变量把一个引用值复制给另一个变量时，复制的实际上是一个指针\n 3. 函数传递参数时，都是值传递的，只是引用值传递的值是一个指针\n\n下面用代码和堆栈图来解释原理：\n\n\n值类型原理#\n\n\n\n值类型保存在栈中，可以直接取到变量的值，堆栈图为：\n\n\n\n\n引用类型原理#\n\n\n\n引用类型保存在堆中，栈中取到的只是堆的地址，堆栈图为：\n\n\n\n\n深拷贝#\n\n普通的引用类型赋值只是浅拷贝，想要深拷贝需要我们自己手写深拷贝的代码：\n\n\n\n\n使用深拷贝的原理#\n\n\n\n深拷贝的引用类型在堆中新分配了空间，堆栈图如下：\n\n\n\n\n常见的值类型与引用类型#\n\n * 常见的值类型\n   * Undefined\n   * Boolean (它有包装的引用类型)\n   * Number (它有包装的引用类型)\n   * String (他有包装的引用类型)\n   * Symbol\n * 常见的引用类型\n   * Date\n   * RegExp\n   * 包装的引用类型\n   * Object\n   * Array\n   * Function (可以看作特殊的没有数据的引用类型)\n   * Null\n\n> Null 比较特殊，《JavaScript 高级程序设计》将它作为值类型，也有人将它作为引用类型\n\n\ntypeof 操作符#\n\ntypeof 操作符能识别的类型有：\n\n * 所有的值类型\n * 识别函数\n * 判断是否是引用类型（不可再细分）\n\n其中，所有的值类型为：\n\n * \"undefined\"\n * \"boolean\"\n * \"number\"\n * \"string\"\n * \"symbol\" (ES6 新增)\n * \"bigint\" (ES10 新增)\n\n函数类型为：\n\n * “function\"\n\n> 严格来说，函数再 ES 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象\n\n引用类型为\n\n * \"object\"\n\n其中，typeof null === \"object\"，typeof 与 js 中的基本变量类型并不是一一对应的","routePath":"/docs/js/04-变量、作用域与内存/01-原始值与引用值","lang":"","toc":[{"text":"值类型原理","id":"值类型原理","depth":2,"charIndex":237},{"text":"引用类型原理","id":"引用类型原理","depth":2,"charIndex":277},{"text":"深拷贝","id":"深拷贝","depth":2,"charIndex":320},{"text":"使用深拷贝的原理","id":"使用深拷贝的原理","depth":2,"charIndex":366},{"text":"常见的值类型与引用类型","id":"常见的值类型与引用类型","depth":2,"charIndex":408},{"text":"typeof 操作符","id":"typeof-操作符","depth":2,"charIndex":698}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"垃圾回收","content":"#\n\nJavaScript\n通过自动内存管理实现内存分配和限制资源回收，它的基本思路是：确定哪个变量不会再使用，然后释放它的内存。整个过程是周期性的，即垃圾回收程序每隔一定时间就会自动运行\n。\n\n\n标记策略#\n\n为了跟踪哪个变量不会再使用，浏览器发展历史上用到过两种主要的标记策略：\n\n * 标记清理\n * 引用计数\n\n\n标记清理#\n\n标记清理（mark-and-sweep）是 JavaScript 最常用的垃圾回收策略。\n\n当变量进入上下文，比如在函数内部声明一个变量时，整个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的\n代码还在运行，就有可能用到它们。\n\n当变量离开山下问时，也会被加上离开的标记。\n\n垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会去除掉所有在上下文中的变量，以及被在上下文中的变量引用的变量，留下待删除的变量。随后垃圾回收程序做\n一次内存清理，销毁带标记的所有值并回收它们的内存。\n\n\n引用计数#\n\n引用计数（reference-counting）则相对不常用。\n\n它的思路是：对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。\n\n * 如果同一个值又被赋给另一个变量，那么引用数加 1\n * 如果保存该值的引用的变量被其他值给覆盖了，那么引用数减 1\n\n当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地回收内存。\n\n垃圾回收机制下次运行时会自动释放引用数为 0 的值的内存。\n\n引用计数的问题\n\n引用计数可能出现循环引用的问题，如下所示：\n\n\n\n * 如果使用标记清理策略，函数结束后，objA 和 objB 都会被回收\n * 使用引用计数，它们的引用数都是 2，函数结束后不会被回收\n\n由于引用计数的缺陷，Netscape 4.0 放弃引用计数而采用标记清理。\n\nIE8 和 IE 以前的问题\n\nIE8 以前，DOM 和 BOM 都是 C++ 实现的组件对象模型，它们还是使用引用计数来实现垃圾清理的。为此，当出现 JavaScript 原生对象和 DOM\n或者 BOM 循环引用时，就会出现问题，如下所示\n\n\n\n为此，我们需要讲变量设置为 null 切断原生 JavaScript 对象和 DOM 元素之间的连接\n\n\n\n值得高兴的是，IE9 讲 DOM 和 BOM 改为了 JavaScript 对象，避免了这个问题\n\n\n性能#\n\n垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失。尤其在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。\n\n由于开发者并不知道什么时候会运行垃圾回收机制，因此最好的办法就是在写代码的时候要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作。\n\n和其他使用垃圾回收的编程环境不同，JavaScript\n运行在一个内存管理和垃圾回收都很特殊的环境——分配给浏览器的内存通常要比分配给大型桌面软件的要少很多，分配给移动浏览器的就更少了。这更多出于安全的考虑，目的是避\n免大量 JavaScript 网页耗尽系统内存而导致操作系统崩溃。\n\n\n性能优化#\n\n\n解除引用#\n\n如果数据不再必要，那么把它设置为 null，从而释放其引用，就叫解除引用。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用。\n\n如下所示：globalPerson 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的\n\n\n\n\n通过 const 和 let 声明提升性能#\n\n这两个关键字不仅可以改善代码风格，还可以改进垃圾回收。\n\n因为 const 和 let 都以块（而非函数）作为作用域，所以使用这两个关键字可能会更早地让垃圾回收程序介入。\n\n\n隐藏类和删除操作#\n\nV8 引擎在将解释后的 JavaScript 代码变为为实际的机器码时会利用 “隐藏类”。如果代码非常注重性能，这一点非常重要。\n\n下述代码会让 a1 和 a2 共享隐藏类：\n\n\n\n但如果添加：\n\n\n\n就会让两个 Article 对应不同的隐藏类。根据这种操作的频率和隐藏类的大小，这可能对性能产生明显的影响。\n\n解决方案是：避免动态添加属性\n\n\n\n此外：使用 delete 关键字会导致无法共享隐藏类\n\n\n\n解决方案是：避免动态删除属性\n\n\n\n总结，为了性能更好，我们应该：\n\n * 避免动态添加属性、避免动态删除属性\n\n\n内存泄漏#\n\n在内存有限的设备上，内存泄漏是一个大问题，JavaScript 中的内存写偶偶大部分是由不合理的引用导致的。\n\n * 意外声明全局变量——最常见也最容易修复的问题\n   \n   \n   \n   此时会把 name 当作 window 的属性创建，这种情况下只需要使用 var、const 和 let 即可\n\n * 定时器也可能悄悄地造成内存泄漏\n   \n   \n   \n   只要定时器一直运行，回调函数中的 name 就会一直占用内存。所以定时器我们需要及时清除\n\n * 使用 JavaScript 闭包很可能会在不知不觉间造成内存泄漏\n   \n   \n   \n   调用 outer 就会导致分配给 name 的内存被泄漏\n   \n   因为只要返回的函数还存在，没有被调用，就会导致垃圾清理程序一直不能清理 name，假如 name 的内容很大，那可能就是大问题\n\n\n静态分配与对象池#\n\n浏览器决定何时运行垃圾回收程序的一个标准是对象更替的速度。如果有很多对象被初始化，然后又都超出了作用域，俺么浏览器就会采用更激进的办法调度垃圾回收程序。\n\n因此，一个办法就是不要动态创建对象，而使用已有的对象。这种办法中的一个策略就是对象池。\n\n在初始化的某一刻，创建一个对象池，用来管理一组可回收的对象，应用程序可以次昂这个对象池请求一个对象、设置器属性、使用它，然后在操作完成后再把它还给对象池。由于没\n发生对象的初始化，垃圾回收探测就不会发现有对象更替。\n\n> 注意：静态分配时优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但是这种情况并不多见。大多数情况下，这都属于过早优化，因此\n> 不用考虑。","routePath":"/docs/js/04-变量、作用域与内存/03-垃圾回收","lang":"","toc":[{"text":"标记策略","id":"标记策略","depth":2,"charIndex":98},{"text":"标记清理","id":"标记清理","depth":3,"charIndex":160},{"text":"引用计数","id":"引用计数","depth":3,"charIndex":444},{"text":"性能","id":"性能","depth":2,"charIndex":1043},{"text":"性能优化","id":"性能优化","depth":2,"charIndex":1336},{"text":"解除引用","id":"解除引用","depth":3,"charIndex":1344},{"text":"通过 const 和 let 声明提升性能","id":"通过-const-和-let-声明提升性能","depth":3,"charIndex":1487},{"text":"隐藏类和删除操作","id":"隐藏类和删除操作","depth":3,"charIndex":1599},{"text":"内存泄漏","id":"内存泄漏","depth":3,"charIndex":1873},{"text":"静态分配与对象池","id":"静态分配与对象池","depth":3,"charIndex":2267}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"变量、作用域与内存","content":"#","routePath":"/docs/js/04-变量、作用域与内存/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"函数和 this 指向","content":"#\n\n\n创建函数的四种方式#\n\n 1. 命名函数\n\n\n\n 2. 匿名函数\n\n\n\n 3. 利用 Function 关键字\n\n\n\n举例而言：\n\n\n\n 4. 箭头函数\n\n\n\n\n函数的类别#\n\n 1. 普通函数\n\n\n\n 2. 对象的方法\n\n\n\n 3. 构造函数\n\n\n\n 4. 绑定事件函数\n\n\n\n 5. 定时器函数\n\n\n\n 6. 立即执行函数\n\n\n\n 7. 箭头函数\n\n\n\n\n不同函数内 this 的指向#\n\n这些 this 的指向，是当我们调用函数时决定的，调用方式的不同决定了 this 的指向不同，一般指向函数的调用者\n\n调用方式     THIS 指向\n普通函数调用   window\n对象方法调用   该方法所属对象\n构造函数调用   实例对象, 原型对象里面的方法也指向实例对象\n绑定事件函数   绑定事件对象\n定时器函数    window\n立即执行函数   window\n箭头函数     (静态的) 函数声明时所在的作用域\n\n\n改变 this 指向的三种方法#\n\nJavaScript 为我们提供了一些函数方法帮助我们改变函数的指向，常用的有 bind()、call() 和 apply() 三种方法\n\n * call()\n\ncall 可以调用函数，可以改变函数内的 this 指向，之前用来实现继承\n\n\n\n * apply()\n\napply() 方法调用一个函数，也可以改变函数内部 this 的指向，不过它传递的参数是数组形式\n\n语法：\n\n\n\n参数：\n\n * thisArg: this 将要指定的对象\n * argsArray: 传递的值，必须包含在数组里面\n\n\n\n它常见的功能就是借助数学内置对象求最大值和最小值:\n\n\n\n * bind()\n\nbind() 方法不会调用函数，但是能改变函数内部 this 指向\n\n语法：\n\n\n\n参数：\n\n * thisArg: this 将要指定的对象\n * arg1, arg2, ...: 将要传递的参数\n\n返回值：\n\n返回改变后的函数拷贝\n\n举例：\n\n\n\nbind() 非常常用，下面举一个例子：\n\n假设有一个按钮，当我们点击按钮之后，需要禁用按钮 3 秒之后，按钮才能继续使用，应该如何实现呢？\n\n\n\n有时 A 对象调用 B 函数，B 函数需要有自己的 this，也需要 A 对象的 this，可以好好利用 bind() 传参：\n\n\n\n\ncall() apply() bind() 总结#\n\n相同点:\n\n都可以改变函数内部的 this 指向\n\n区别点:\n\n 1. call() 和 apply() 会调用函数，而 bind() 不会\n 2. call() 和 bind() 传递的是参数 arg1, arg2, ...，而 apply() 传递的参数是数组\n\n主要应用场景:\n\n 1. call() 经常用作继承\n 2. apply() 经常和数组有关，比如借助数学对象实现找到数组的最大值和最小值\n 3. bind() 常常用来改变 this 指向，比如改变定时器内部 this 的指向\n\n\n严格模式#\n\nJavaScript 除了正常模式之外，还提供严格模式，严格模式在 IE10+ 浏览器中才会被支持\n\n严格模式对正常的 JavaScipt 做了一些更改：\n\n变量规定\n\n 1. 在正常模式下，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先声明后使用\n 2. 严禁删除已经声明的变量\n\nthis 指向\n\n 1. 严格模式下全局作用域中的函数中的 this 是 undefined\n 2. 严格模式下，构造函数不加 new 调用会报错\n 3. 其余 this 和普通模式一样\n\n函数变化\n\n 1. 函数不能有重名的参数\n 2. 函数必须声明在顶层，不允许在非函数的代码块内声明函数\n\n用法：\n\n\n\n\n\n\n\n\n不同绑定规则和优先级#\n\n * 默认绑定规则：也就是全局的属性和对象默认绑定到 window\n\n * 隐式绑定规则：谁调用谁就绑定谁\n\n * 显示绑定规则：call()、bind() 和 apply()\n\n * new 绑定：谁 new 的 this 指向就指向谁\n   \n   \n\n这四种绑定规则的优先级从低到高为：\n\n默认绑定 < 隐式绑定 < 显示绑定 ＜ new 绑定\n\n美团有一道面试题目，重点就是不同绑定方式：\n\n","routePath":"/docs/js/10-函数/09-函数内部","lang":"","toc":[{"text":"创建函数的四种方式","id":"创建函数的四种方式","depth":2,"charIndex":3},{"text":"函数的类别","id":"函数的类别","depth":2,"charIndex":84},{"text":"不同函数内 this 的指向","id":"不同函数内-this-的指向","depth":2,"charIndex":183},{"text":"改变 this 指向的三种方法","id":"改变-this-指向的三种方法","depth":2,"charIndex":418},{"text":"call() apply() bind() 总结","id":"call-apply-bind-总结","depth":2,"charIndex":998},{"text":"严格模式","id":"严格模式","depth":2,"charIndex":1276},{"text":"不同绑定规则和优先级","id":"不同绑定规则和优先级","depth":2,"charIndex":1601}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"执行顺序","content":"#\n\nJavaScript 这门语言是单线程的，所有的任务需要排队，前一个任务结束，才会执行后一个任务。 JavaScript 和 DOM 渲染共用同一个线程。（因为\nJS 可修改 DOM 结构），如果 Javascript 的一个任务执行时间过长，就会造成 DOM 渲染被阻塞\n\n\n同步和异步#\n\n为了让 JS 在遇到等待（网络请求、定时任务）不能卡住，就出现了异步。\n\n * 同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的，会阻塞代码执行\n * 异步：不会阻塞代码执行，会将任务先放到一个任务队列中排队，当同步任务完成之后再执行\n\n\n任务执行机制#\n\n同步任务都在主线程上执行，形成一个执行栈，JS 执行时\n\n 1. 先执行执行栈中的同步任务\n 2. 异步任务放入任务队列\n 3. 一旦执行栈中的所有同步任务执行完毕，系统会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈并开始执行\n\n由于主线程不断的重复获得任务、执行任务、再获取任务再执行，所以这种机制称为事件循环\n\n\n\n> JS 的异步一般都是用回调函数实现, 这并不意味着回调函数就是异步\n\n\n异步的典型代码#\n\n\n\n\n\n\n\n\n异步应用场景#\n\n前端：\n\n * 网咯请求，比如 ajax 图片加载\n * 定时任务，比如 setTimeout\n\n后端：\n\n * 文件读取\n * 数据库读取\n\n\nevent loop (事件循环/事件轮询)#\n\nJavaScript 是单线程执行的，它的异步要基于回调来实现，event loop 就是异步回调的实现原理\n\n如下图所示：\n\n\n\n 1. 同步代码，一行一行放在 Call Stack 执行\n 2. 遇到异步，会先记录下，等待时机（定时、网络请求等）\n 3. 时机到了，异步任务就移动到 Callback Queue 中\n 4. 如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作\n 5. 轮询查找 Callback Queue，如果有任务则移动到 Call Stack 中执行\n 6. 然后继续轮询查找\n\n\nDOM 渲染和 event loop#\n\n先看一段代码：\n\n\n\n执行效果为：\n\n\n\n这是因为，JavaScript 是单线程的，而且和 DOM 渲染共用一个线程。\n\n * 每次 Call Stack 清空（即每次轮询结束），即同步任务执行完\n * 都是 DOM 重新渲染的机会，DOM 结构如有改变则会重新渲染\n * 然后再去触发下一次 event loop\n\n\n宏任务与微任务的执行时间#\n\n * 宏任务: DOM 渲染后触发，如 setTimeout\n * 微任务: DOM 渲染前触发，如 Promise\n\n当微任务执行时，它不会经过 Web APIs，而是处于另外一个队列中，即 微队列，这也是我们之前就看过的图：\n\n\n\n这是因为：\n\n * 微任务是 ES6 语法规定的\n * 宏任务是浏览器规定的","routePath":"/docs/js/11-期约与异步函数/01-异步编程","lang":"","toc":[{"text":"同步和异步","id":"同步和异步","depth":2,"charIndex":141},{"text":"任务执行机制","id":"任务执行机制","depth":2,"charIndex":284},{"text":"异步的典型代码","id":"异步的典型代码","depth":2,"charIndex":507},{"text":"异步应用场景","id":"异步应用场景","depth":2,"charIndex":524},{"text":"event loop (事件循环/事件轮询)","id":"event-loop-事件循环事件轮询","depth":2,"charIndex":606},{"text":"DOM 渲染和 event loop","id":"dom-渲染和-event-loop","depth":2,"charIndex":903},{"text":"宏任务与微任务的执行时间","id":"宏任务与微任务的执行时间","depth":2,"charIndex":1085}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"期约（Promise）","content":"#\n\nPromise 是 JavaScript 中进行异步编程的新的解决方法，从语法上看，Promise 是一个构造函数，从功能上看，Promise\n用来封装一个异步操作并可以获取其结果\n\n\nPromise 的状态改变#\n\n * pending 变为 resolved\n * pending 变为 rejected\n\n说明：只有这两种改变方式，且一个 Promise 对象只能够改变一次\n\n无论成功还是失败，都会有一个结果数据，成功的结果数据称为 value，失败的结果数据称为 reason。\n\n\nPromise 的基本流程#\n\n\n\n\nPromise 的基本使用#\n\n\n以 nodejs 读取文件为例：#\n\n\n以连续读取三个文件为例#\n\n\n为什么使用 Promise#\n\n * Promise 支持链式调用，能够解决回调地狱问题\n   \n   传统的异步编程，会将函数嵌套调用，外部回调函数异步执行的结果是嵌套的回调函数的执行条件，这被称之为回调地狱。\n   \n   回调地狱倒置代码难以阅读和维护。\n   \n   Promise 支持链式调用，让代码能更加方便阅读和维护。\n\n\n什么时候用 Promise.then() 的第二个函数，什么时候用 catch#\n\n * 适合使用 Promise.then() 第二个函数的情况\n   * 成功和失败逻辑上非常紧密、比如读取文件成功、失败\n   * 需要避免过多 catch 嵌套的场景\n * 适合用 catch 的情况\n   * Promise 链路全局错误捕获，类似于「兜底」\n   * 统一处理所以错误信息，比如给用户显示错误信息\n   * Promise.all、Promise.race 操作的情况\n\n\nPromise 的常见 API#\n\nAPI                       类型                                              说明\nPromise(excutor)          excutor 类型为 (resolve, reject) => {}             Promise 的构造函数\nPromise.prototype.then    (onResolved, onRejected) => {}                  onResolved 是成功时的回调函数, onRejected 是失败时的回调函数，它们能指定之后返回的新\n                                                                          Promise 对象\nPromise.prototype.catch   (onRejected) => {}                              失败时的回调函数\nPromise.resolve           (value) => {}                                   返回一个成功的 Promise 对象\nPromise.reject            (reason) => {}                                  返回一个失败的 Promise 对象\nPromise.all               (promises) => {}，promises 是包含 n 个 Promise 的数组   返回一个新的 Promise, 只有所有的 Promise 都成功才成功, 只要有一个失败就直接失败\nPromise.race              (promises) => {}                                返回一个新的 Promise, 最先完成的 Promise 的状态就是最终的结果状态\n\n\n举例学习 Promise 的细节#\n\n\n如何改变 Promise 的状态#\n\n 1. resolve(value): 如果当前是 pending 状态就变为 resolved\n 2. reject(value): 如果当前是 pending 状态就变为 rejected\n 3. 抛出异常: 如果当前是 pending 状态就变为 rejected\n\n\n\n\n一个 Promise 指定多个成功/失败回调函数, 都会调用吗#\n\n一个 Promise 指定多个成功/失败回调函数, 都会调用\n\n\nPromise.prototype.then 返回的新 Promise 状态有什么决定#\n\n * 简单表达: 由 then() 指定的回调函数的执行结果决定\n * 详细表达:\n   * 如果抛出异常, 则新 Promise 状态为 rejected, reason 为抛出的异常\n   * 如果返回的是非 Promise 的任意值, 则新 Promise 状态为 resolved, value 为返回的值\n   * 如果返回的是 Promise, 则由 Promise 决定\n   * 没有返回则相当于 return undefined;, 则新 Promise 状态为 resolved\n\n\nPromise 可以串联多个同步和异步任务#\n\n\nPromise 异常穿透/传透#\n\n 1. 当使用 then 链式调用时, 可以在最后指定失败的回调\n 2. 前面的任何操作出了异常, 都会传到最后失败的回调处理中\n\n没写 reason 相当于 reason => { throw reason; }\n\n\n中断 Promise 链#\n\n在 then 的回调函数中, 返回:\n\n","routePath":"/docs/js/11-期约与异步函数/02-期约","lang":"","toc":[{"text":"Promise 的状态改变","id":"promise-的状态改变","depth":2,"charIndex":95},{"text":"Promise 的基本流程","id":"promise-的基本流程","depth":2,"charIndex":249},{"text":"Promise 的基本使用","id":"promise-的基本使用","depth":2,"charIndex":268},{"text":"以 nodejs 读取文件为例：","id":"以-nodejs-读取文件为例","depth":3,"charIndex":285},{"text":"以连续读取三个文件为例","id":"以连续读取三个文件为例","depth":3,"charIndex":305},{"text":"为什么使用 Promise","id":"为什么使用-promise","depth":2,"charIndex":320},{"text":"什么时候用 Promise.then() 的第二个函数，什么时候用 catch","id":"什么时候用-promisethen-的第二个函数什么时候用-catch","depth":2,"charIndex":490},{"text":"Promise 的常见 API","id":"promise-的常见-api","depth":2,"charIndex":731},{"text":"举例学习 Promise 的细节","id":"举例学习-promise-的细节","depth":2,"charIndex":1641},{"text":"如何改变 Promise 的状态","id":"如何改变-promise-的状态","depth":3,"charIndex":1661},{"text":"一个 Promise 指定多个成功/失败回调函数, 都会调用吗","id":"一个-promise-指定多个成功失败回调函数-都会调用吗","depth":3,"charIndex":1820},{"text":"Promise.prototype.then 返回的新 Promise 状态有什么决定","id":"promiseprototypethen-返回的新-promise-状态有什么决定","depth":3,"charIndex":1887},{"text":"Promise 可以串联多个同步和异步任务","id":"promise-可以串联多个同步和异步任务","depth":3,"charIndex":2185},{"text":"Promise 异常穿透/传透","id":"promise-异常穿透传透","depth":3,"charIndex":2210},{"text":"中断 Promise 链","id":"中断-promise-链","depth":3,"charIndex":2338}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"异步函数","content":"#\n\n\nasync 函数#\n\nasync 函数的返回值为 Promise 对象，且该对象的结果由 async 函数执行的结果来决定\n\n\n\n\n\n其余的，例如：return Promise.resolve(3); 或者 return Promise.reject(4); 等看结果就可以直接决定。\n\n\nawait 表达式#\n\nawait 右侧的表达式一般为 Promise 对象，但也可以是其他值\n\n * 如果表达式是 Promise 对象，await 返回的是 Promise 成功的值\n * 如果表达式是其他值，直接将此值作为 await 的返回值\n\n注意:\n\n * await 必须写在 async 函数中，但 async 中可以没有 await\n * 如果 await 的 Promise 对象失败了，就会抛出异常，需要通过 try ... catch 来捕获处理，且捕获到的异常为 Promise\n   对象失败的值\n\n\n\n\nasync/await 和 Promise 的关系#\n\nasync/await 是消灭异步回调的终极武器，但是和 Promise 并不互斥，通常会将 async/await 和 Promise 结合使用。\n\n * 执行 async 函数，返回的是 Promise 对象\n * await 相当于 Promise 的 then\n * try ... catch 可捕获异常，代替了 Promise 的 catch\n\n不过，js 还是单线程的，还是有一部，还是得基于 event loop，async/await 只是一个语法糖。\n\n\nasync/await 的执行顺序#\n\n看一道题目：\n\n\n\nawait 后面，都可以看作是 callback 里的内容，类似：\n\n\n\n这道题目再增加一点难度：\n\n\n\n最后一道题目：\n\n","routePath":"/docs/js/11-期约与异步函数/03-异步函数","lang":"","toc":[{"text":"async 函数","id":"async-函数","depth":2,"charIndex":3},{"text":"await 表达式","id":"await-表达式","depth":2,"charIndex":148},{"text":"`async/await` 和 `Promise` 的关系","id":"asyncawait-和-promise-的关系","depth":2,"charIndex":-1},{"text":"`async/await` 的执行顺序","id":"asyncawait-的执行顺序","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"ajax","content":"#\n\nAjax 是浏览器提供的一套方法,可以实现页面无刷新更新数据,提高用户浏览网站应用的体验。\n\nAjax 的应用场景举例:\n\n 1. 页面上拉加载更多数据\n 2. 列表数据无刷新分页\n 3. 表单项离开焦点数据验证\n 4. 搜索框提示文字下拉列表\n\n\nAjax的实现步骤#\n\n1.创建Ajax对象\n\n\n\n2.告诉 Ajax 请求地址以及请求方式\n\n\n\n3.发送请求\n\n\n\n4.获取服务器端给与客户端的响应数据\n\n\n\n在真实的项目中,服务器端大多数情况下会以 JSON 对象作为响应数据的格式。当客户端拿到响应数据时 要将 JSON 数据转变为对象\n\n于是代码可能为:\n\n\n\n\nAjax 请求参数传递#\n\n\nGET 请求方式#\n\nGET 请求方式, 需要在路径后面拼接参数, 类似\n\n\n\n因此一般会创建一个 params 作为拼接的请求参数\n\n\n\n\nPOST 请求方式#\n\nPOST 请求参数的格式有两种\n\n * application/x-www-form-urlencoded\n\n\n\n * application/json\n\n\n\n因此, POST 请求方式有两个注意点\n\n * POST 请求方式需要设置 header\n * POST 请求方式的 send() 有参数\n\n下面分别举例看看 POST 两种请求方式的代码:\n\n\n\n\n\n\nAjax 获取服务端的响应#\n\n之前我们已经用过 xhr 的 onload 事件来判定服务端已经响应, 其实还有另外一种方法, 用 xhr 的 onreadystatechange 事件来判定\n\n在创建 ajax 对象,配置 ajax 对象, 发送请求, 以及接收完服务器端响应数据, 这个过程中的毎一个步骤都会对应一个数值, 这个数值就是 ajax\n状态码\n\n * 0: 请求未初始化 (还没有调用 open())\n * 1: 请求已经建立,但是还没有发送 (还没殳有调用 send())\n * 2: 请求已经发送\n * 3: 请求正在处理中, 通常响应中已经有部分数据可以用了\n * 4: 响应已经完成, 可以获取并使用服务器的响应了\n\n\n\nonreadystatechange 事件: 当Ajax状态码发生变化时将自动触发该事件\n\n\n\n\nonload 和 onreadystatechange 对比#\n\n区别描述              ONLOAD   ONREADYSTATECHANGE\n是否兼容 IE 低版本       不兼容      兼容\n是否需要判断 Ajax 状态码   不需要      需要\n被调用次数             一次       多次\n\n\nAjax 状态码和 HTTP 状态码的区别#\n\n * Ajax 状态码: 表示 Ajax 请求的过程状态, 是 ajax 对象返回的\n * Http状态码: 表示请求的处理结果, 是服务器端返回的\n\n\nAjax 错误处理#\n\n 1. 网络畅通, 服务器端能接收到求, 但服务器端返回的结果不是预期结果\n\n用 xhr.status 获取 http 状态码, 分别进行处理\n\n\n\n 2. 网络畅通, 服务器端殳有接收到请求, 返回 404 状态码\n\n检查请求地址是否错误\n\n 3. 网络畅通, 服努器端能接收到求, 脶务器端返回 500 状态码\n\n服务器端错误, 找后端程序员进行沟通\n\n 4. 网络中断, 请求无法发送到服务器端\n\n会触发 xhr 对象下面的 onerror 事件, 在 onerror 事件处理函数中对错误进行处理\n\n\n\n\n低版本浏览器的缓存问题#\n\n问题: 在低版本的 IE 浏览器中, Ajax 请求有严重的缓存问题, 即在请求地址不发生变化的情兄下, 只有第一次请求会真正发送到服务器端,\n后续的请求都会从浏览器的缓存中获取结果。 即使服务器端的数据更新了, 客户端依然拿到的是缓存中的旧的数据\n\n解决方案: 在请求地址的后面加请求参数, 保证每一次请求中的请求参数的值不相同\n\n","routePath":"/docs/js/24-网络请求与远程资源/01-XMLHttpRequest 对象","lang":"","toc":[{"text":"Ajax的实现步骤","id":"ajax的实现步骤","depth":2,"charIndex":127},{"text":"Ajax 请求参数传递","id":"ajax-请求参数传递","depth":2,"charIndex":289},{"text":"GET 请求方式","id":"get-请求方式","depth":3,"charIndex":304},{"text":"POST 请求方式","id":"post-请求方式","depth":3,"charIndex":375},{"text":"Ajax 获取服务端的响应","id":"ajax-获取服务端的响应","depth":2,"charIndex":569},{"text":"`onload` 和 `onreadystatechange` 对比","id":"onload-和-onreadystatechange-对比","depth":2,"charIndex":-1},{"text":"Ajax 状态码和 HTTP 状态码的区别","id":"ajax-状态码和-http-状态码的区别","depth":2,"charIndex":1112},{"text":"Ajax 错误处理","id":"ajax-错误处理","depth":2,"charIndex":1213},{"text":"低版本浏览器的缓存问题","id":"低版本浏览器的缓存问题","depth":2,"charIndex":1482}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"跨域资源共享","content":"#\n\nAjax 请求有限制, 只能向自己的服务器发送请求. Ajax 的限制属于同源政策的一部分\n\n\n什么是同源#\n\n如果两个页面拥有相同的协议、域名和端口, 那么这两个页面就属于同一个源, 其中只要有一个不相同, 就是不同源\n\n\n同源政策的目的#\n\n同源政策是为了保证用户信息的安全, 防止恶意的网站窃取数据。最初的同源政策是指 A 网站在客户端设置的 Cookie, B 网站是不能访问的\n\n随着互联网的发展, 同源政策也越来越严格, 在不同源的情况下, 其中有一项规定就是无法向非同源地址发送 Ajax 请求, 如果请求, 浏览器就会报错\n\n\n解决同源限制问题 (跨域问题) 办法#\n\n * JSONP\n * CORS\n * 代理服务器\n\n所有的跨域, 都必须经过 server 端允许和配合\n\n\n使用 JSONP 解决同源限制问题#\n\nJSONP 是 json with padding (带填充的 JSON) 的缩写, 它不属于 Ajax 请求, 但它可以模拟 Ajax 请求。\n\n它的原理是加载图片 css js 可以无视同源策略\n\n比如:\n\n * 可用于统计打点, 可使用第三方统计服务\n * link/> < script> 可使用 CDN, CDN 一般都是外域\n\n * script 标签请求地址不一定必须以.js 结尾, 但是必须返回合法的 JavaScript 代码\n   \n   2. 服务器端响应数据必须是一个函数的调用, 真正要发送给客户端的数据需要作为函数调用的参数\n   \n   \n   \n   3. 在客户端全局作用域下定义函数 fn\n   \n   \n   \n   定义 fn 函数必须在获得 jsonp 的 script 标签之前\n   \n   4. 在 fn 函数内部对服务端返回的数据进行处理\n   \n   \n   \n   以上只是简单地介绍了 jsonp 的用法。\n   \n   \n   CORS 跨域资源共享#\n   \n   > CORS 是一个 W3C 标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。\n   \n   > 它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。\n   \n   对于简单请求, 浏览器会给跨域的 AJAX 请求添加一个 Origin 字段\n   \n   > Origin 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n   \n   > 如果 Origin 指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含\n   > Access-Control-Allow-Origin 字段（详见下文），就知道出错了，从而抛出一个错误，被 XMLHttpRequest 的\n   > onerror 回调函数捕获\n   \n   总的来说, 就是浏览器代码不用改 (origin 由浏览器自动添加), 服务器代码的响应头部多出 Access-Control-Allow-Origin\n   方法\n   \n   \n   \n   \n   \n   withCredentials 属性\n   \n   在使用 Ajax 技术发送跨域请求时, 默认情兄下不会在请求中携带 cookie 信息\n   \n   withCredentials: 指定在涉及到跨域请求时, 是否携带 cookie 信息, 默认值为 false\n   \n   Access-Control-Allow-Credentials: true 允许客户端发送请求时携带 cookie\n   \n   \n   \n   \n   \n   \n   代理服务器#\n   \n   \n   \n   能使用代理服务器的原因, 是服务器和服务器之间没有同源政策。","routePath":"/docs/js/24-网络请求与远程资源/03-跨域资源共享","lang":"","toc":[{"text":"什么是同源","id":"什么是同源","depth":2,"charIndex":50},{"text":"同源政策的目的","id":"同源政策的目的","depth":2,"charIndex":115},{"text":"解决同源限制问题 (跨域问题) 办法","id":"解决同源限制问题-跨域问题-办法","depth":2,"charIndex":274},{"text":"使用 JSONP 解决同源限制问题","id":"使用-jsonp-解决同源限制问题","depth":3,"charIndex":351},{"text":"CORS 跨域资源共享","id":"cors-跨域资源共享","depth":3,"charIndex":-1},{"text":"代理服务器","id":"代理服务器","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"cookie，local storage 和 session storage","content":"#\n\n\nCookie#\n\ncookie 本身用于浏览器和 server 通讯, 被 “借用” 到本地存储来\n\ncookie 的特点:\n\n * 存储大小: 最大 4KB\n * http 请求时需要发送到服务端, 增加请求数据量\n * 只能使用 document.cookie = '...' 来修改\n\n\n\n对于 cookie 来说, 用 document.cookie 来设置时, 同一个 key 设置值会导致值被覆盖, 不同的 key 设置值则将 key 和\nvalue 追加到 cookie 中\n\n\nLocalStorage 和 SessionStorage#\n\nlocalStorage 和 sessionStorage 是 HTML5 为存储设计的, 它们的特点为:\n\n * 存储大小: 最大可存 5MB\n * 不会随着 http 请求被发送出去\n * API 简单易用 setitem(\"key\", \"value\") 和 getitem(\"key\")\n\n不过 localStorage 个 session 有些区别:\n\n * localStorage 数据会永久存储, 除非代码或手动删除\n * sessionStorage 数据只存在于当前会话, 浏览器关闭则清空\n\n一般我们用 sessionStorage 要多一些\n\n\nCookie LocalStorage 和 SessionStorage 对比#\n\n           COOKIE   LOCALSTORAGE   SESSIONSTORAGE\n存储大小       4KB      5MB            5MB\n是否随请求头提交   是        否              否\n是否可以跨页     是        是              否\nAPI        粗陋       精细             精细","routePath":"/docs/js/25-客户端存储/01-Cookie","lang":"","toc":[{"text":"Cookie","id":"cookie","depth":2,"charIndex":3},{"text":"LocalStorage 和 SessionStorage","id":"localstorage-和-sessionstorage","depth":2,"charIndex":250},{"text":"Cookie LocalStorage 和 SessionStorage 对比","id":"cookie-localstorage-和-sessionstorage-对比","depth":2,"charIndex":566}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"JavaScript","content":"#\n\n笔记参考《JavaScript 高级程序设计（第 4 版）》\n\n思维导图：https://www.mubu.com/doc/pu2ozlNVga","routePath":"/docs/js/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"mdbook","content":"#\n\n\nGitHub Pages#\n\n通过使用 GitHub Actions 的 workflow（工作流）的模板，我们可以快速部署网站到 github.io 域名下。\n\n 1. GitHub 仓库中，选择 Settings -> Pages -> GitHub Actions -> browse all workflows\n\n\n\n 2. 点击 Pages 右侧的 View all 按钮\n\n\n\n 3. 选择 mdBook，点击 Configure 按钮\n\n\n\n 4. 之后 GitHub 会自动创建一个 yml 文件\n\n\n\n 5. 我们可以将整个仓库克隆到本地，按照 mdBook 官方指南 的指导书写 Markdown 文件。当我们提交后，会自动触发 GitHub Actions\n    将网站部署到 GitHub Pages 下。\n\n\nGitHub Issues#\n\nmdBook 本身并不支持评论，但我们可以使用 utterances 这个评论插件，很方便快捷地添加评论功能。\n\n 1. 在 GitHub 新建一个用于评论的仓库。比如我单独新建了一个 blog-issues\n 2. 访问 utterances 的配置界面 ，点击 Configure，然后选择用于评论的仓库。\n 3. 在 mdBook 的 Markdown 文件底部，加入一段 script 代码。我们只需要填写 repo（仓库名）和 issue-term（issue\n    分组，可以直接写文章名）。\n\n\n\n\n中文搜索#\n\nmdBook 生成的文档和书记，默认只支持英文搜索，其实我们只需要几个简单的配置，就可以让 mdBook 生成的 HTML 支持中文搜索。\n\n 1. 新建一个和 src 同级的文件夹 assets。\n 2. 将 fzf.umd.js 和 elasticlunr.js 文件放到 assets 目录下。\n 3. 在 book.toml 的配置中添加配置\n\n\n\n\nmermaid#\n\nmdbook 默认并不支持使用 mermaid 画图。我们可以通过安装插件的方式，让 mdbook 支持这个功能。\n\n（1）安装 mdbook-mermaid\n\n\n\n（2）在 book.toml 中可以添加如下配置。\n\n\n\nmdbook-mermaid 是一个开源插件。\n\n（3）拷贝 mermaid 到与 src 同级的 assets 文件夹中。\n\nmermaid-init.js 用来初始化 mermaid，内容为：\n\n\n\n至于 mermaid.min.js，可以去 mermaid 官网，找到它的 CDN 地址 拷贝。\n\n之后重新运行 mdbook serve 命令，就可以看到 mdbook 已经支持 mermaid 画图功能了。\n\n(4) 更新部署脚本\n\n如果你和我一样，使用的是 GitHub Pages 部署博客，那么你需要更改 yml。\n\n\n\n\n404#\n\n我们可以给网站设置 404 页面，这样当用户访问到网站不存在的链接时，会跳转到 404 页面，提高用户的体验。\n\n默认情况下，mdBook 只需要在 src 目录下添加 404.md，404 页面便会显示 404.md 的内容。\n\n我们也可以通过修改 book.toml 中的配置，改变 404 页面的路径：\n\n\n\n除此之外，我们还需要设置 site-url，site-url 一般设置为网站的根路径，确保 404 页面也能正常获取脚本和样式文件。\n\n\n\n\nsitemap#\n\n如果我们能够给搜索引擎提供 sitemap.xml，那么它抓取 mdbook 生成的网站就会更加快速。\n\n目前 mdbook 没有提供生成 sitemap.xml 的插件，但是我们可以使用 node.js 的插件。\n\n这里我选中了一款插件，名叫 static-sitemap-cli。\n\n我们只需要简单的两个步骤，就可以生成自己的 sitemap.xml。\n\n（1）安装 static-sitemap-cli\n\n\n\n（2）生成站点地图到 book 文件夹下\n\n\n\n这样便完成了。\n\n不过，我的最终目的是，每当我有新博客提交时，都会自动更新 sitemap.xml 并部署，因此我需要改造一下原有的 yml 文件。\n\n具体可以参考\nhttps://github.com/lijunlin2022/blog/blob/main/.github/workflows/mdbook.yml。\n\n以我的博客为例，访问 https://lijunlin2022.github.io/blog/sitemap.xml 便可以看到 sitemap.xml\n文件了。","routePath":"/docs/mdbook/","lang":"","toc":[{"text":"GitHub Pages","id":"github-pages","depth":2,"charIndex":3},{"text":"GitHub Issues","id":"github-issues","depth":2,"charIndex":372},{"text":"中文搜索","id":"中文搜索","depth":2,"charIndex":646},{"text":"mermaid","id":"mermaid","depth":2,"charIndex":833},{"text":"404","id":"404","depth":2,"charIndex":1224},{"text":"sitemap","id":"sitemap","depth":2,"charIndex":1459}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"异步分包","content":"#\n\n截止 2022 年 3 月 3 日，小程序的体积限制如下：1\n\n> 整个小程序所有分包大小不超过 20M 单个分包/主包大小不能超过 2M\n\n因此，作为小程序开发者，总有一天会面临小程序的体积问题。\n\n开发者一般会将核心页面放在主包中，将非核心的页面放在分包中。但是随着业务的迭代，主包总会有超过 2M 的时候，这个时候就需要用到「分包异步化」了。\n\n微信官方文档将「分包异步化」分为：「跨分包自定义组件引用」 和 「跨分包 JS 代码引用」\n2。根据我实际的开发经验，「跨分包自定义组件引用」更加常见实用，下面我将介绍简单介绍这种方法。\n\n为了行文方便，我后文将使用了「跨分包自定义组件引用」这种方式的组件，称为「异步组件」。\n\n\n给「异步组件」单独建一个分包#\n\n我创建了一个分包 sub-async-components-package，之后所有的异步组件，都存放到这个分包中。\n\n * app.json\n\n\n\nsub-async-components-package 的目录结构如下：\n\n\n\n\n在主包页面中引入异步组件#\n\n完成第一步之后，我们可以在主包的页面中，以如下方式引入异步组件。异步组件的传参，和普通组件一致。\n\n\n\n\n\n现在我们简单一下上述配置的意思。componentPlaceholder 顾名思义就是组件占位符的意思。在分包还没有加载完成之前，页面会用 view\n标签暂时替代 async-component-x 标签，等到分包加载完成之后，再将 view 标签占据的位置还给 async-component-x。\n\n\nFootnotes\n\n 1. 分包加载 | 微信开放文档 ↩\n\n 2. 分包异步化 | 微信开放文档 ↩","routePath":"/docs/miniprogram/01-async-subpackage","lang":"","toc":[{"text":"给「异步组件」单独建一个分包","id":"给异步组件单独建一个分包","depth":2,"charIndex":319},{"text":"在主包页面中引入异步组件","id":"在主包页面中引入异步组件","depth":2,"charIndex":453}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"graphql","content":"#\n\n安装\n\n\n\n引入 gql 方法，定义 Query 和 Mutation 两个字符串。\n\n\n\n使用 @apollo/client 提供的两个 hooks, useQuery 和 useMutation\n\n\n\n定义一个用于发送网络请求的 client\n\n\n\n利用提供的 ApolloProvider 包裹 React 的根组件。\n\n\n\n至此，大功告成。","routePath":"/docs/nestjs/01-graphql","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"oss","content":"#\n\n首先需要到阿里云的身份管理/用户中创建一个用户账号，\n\n\n\n创建好用户后，我们可以给这个用户账号创建 AccessKey，这样就可以拿用户账号访问阿里云的 API 了。\n\n\n\n有两种 API 上传图片到阿里云的方式。\n\n * 服务端转发\n   * 用服务端转发的话，请求我们自己的服务器会被收取一次费用，上传图片又会再收取一次费用\n * Web 直传\n   * 服务端会生成一个签名，然后将签名传递给客户端\n   * 客户端通过签名，上传图片到阿里云 OSS\n\n我们这里选择 Web 直传的方式，文档可以参考服务端签名后直传\n\n之后需要给用户组设置权限。\n\n\n\n然后需要设置跨域\n\n\n\n之后读和写都需要权限，我们这里需要设置公共读\n\nhttps://help.aliyun.com/document_detail/177701.html?spm=a2c4g.149373.0.0.318f195\n5bLrLYc\n\n\n服务端获取签名#\n\n\n\n\n客户端上传图片#\n\n客户端上传图片时，会发送两个网络请求：\n\n * 第一个请求的目的是获取签名，这一步骤我我使用 graphql 完成，由客户端发送给开发者服务器。\n * 第二个请求的目标是上传图片，这一步骤我使用原生 fetch 完成，由客户端发送给 OSS 服务器。\n\n我将两个网络请求封装成一个名叫 useOSSUpload 的 hooks。\n\n\n\n\n\n通过使用 uploadHandler，我们可以上传图片。我们这里以 Antd 为例：\n\n","routePath":"/docs/nestjs/02-oss","lang":"","toc":[{"text":"服务端获取签名","id":"服务端获取签名","depth":2,"charIndex":410},{"text":"客户端上传图片","id":"客户端上传图片","depth":2,"charIndex":423}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"sms","content":"#\n\n我们开发一个产品时，往往需要用到短信验证码功能，为此我们可以选择「阿里云短信服务」。\n\n可以访问 阿里云短信服务。\n\n\n使用测试模板#\n\n选择「通过 API 发短信」->「免签名/模板审核的 API 发送测试」\n\n\n\n为了快速上手阿里云短信服务，我们在绑定测试手机号后，可以先不选择申请模板，而是先使用「【专用】测试签名/模板」。\n\n\n\n之后我们可以直接点击调用，看看是否有验证码发送到我们的手机上。\n\n\n\n\n编写调用的 API 的代码#\n\n我们可以选择「SDK 示例」，查看相关语言的例子，因为我使用的是 Nest.js，所以选择 TypeScript。\n\n\n\n\n\n\n访问控制#\n\n之后我们需要到阿里云访问控制，为我们的身份添加权限。\n\n\n\n调用代码后，我们就可以直接收到短信了。","routePath":"/docs/nestjs/03-sms","lang":"","toc":[{"text":"使用测试模板","id":"使用测试模板","depth":2,"charIndex":62},{"text":"编写调用的 API 的代码","id":"编写调用的-api-的代码","depth":2,"charIndex":207},{"text":"访问控制","id":"访问控制","depth":2,"charIndex":287}],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"文件","content":"#\n\n\n管道流#\n\nNode 本身有一个文件的管道流概念，文件就是装水的桶，文件就是水，然后用一个管道连接两个桶，从而实现大文件的复制过程。\n\n\n\n\n\n在 Gulp 中，不仅文件支持管道流的概念，文件夹也支持管道流的概念。\n\n\n\n\nNode 的四种流类型#\n\nNode.js 中有四种基本的流类型 1：\n\n * Readable，可读的流，例如 fs.createReadStream()\n * Writable，可写的流，例如 fs.createWriteStream()\n * Duplex，可读写的流，例如 net.Socket\n * Transform，在读写过程中可以修改和变换数据的 Duplex 流\n\n如果我们需要自己实现某一种流，那么需要重写一些方法：2\n\n类           需要重写的方法\nReadable    _read\nWritable    _write\nDuplex      _read, _write\nTransform   _transform, _flush\n\n举一个自定义 Transform 的例子：\n\n\n\n这个流可以将控制台的输入流，转换为全大写的字母，然后输出。\n\n\nNode.js 文件操作#\n\npath.parse() 函数，返回的对象有如下属性：root, dir, base, name, ext。3\n\n\n流操作是异步的#\n\nNode.js\n中的流是异步操作。使用流进行数据的读取和写入时，会异步地进行数据传输，即读取和写入过程会在后台异步完成，不会阻塞代码的执行。当读取或写入操作完成时，会触发相应的\n事件（例如 data，end，error 事件等），执行这些事件对应的回调函数。\n\n因为流是异步的，所以为了避免数据丢失问题，我们一般会使用回调函数或者 Promise 等方式来处理数据。\n\n\n判断是文件还是文件夹#\n\nNode.js 中，我们可以用 fs.statSync() 获取文件信息，然后利用 stat.isFile() 和 stat.isDirectory()\n来判断是文件还是文件夹。\n\n\n创建文件夹#\n\n在 Node.js 中，fs.mkdir 和 fs.mkdirSync\n方法用于创建文件夹。在调用这些方法时，需要指定需要创建的文件夹路径。如果在该路径中的某些目录不存在时，则会抛出一个错误。例如，如果我们要创建目录\n./a/b/c/d，但是 ./a/b 这个目录不存在，就会出现错误。\n\n为了解决这个问题，Node.js 从 10.x 版本开始增加了 recursive 配置参数，它用于控制是否按需创建父文件夹。当该配置参数为 true\n时，如果目标路径中的某些目录不存在，则会自动递归创建这些目录。如果设置为 false 或者不设置这个参数，则会抛出一个错误。\n\n\n复制文件#\n\n\n\n使用 Promise 的方式改写：\n\n\n\n\nNode.js 相对路径变为绝对路径#\n\n\n\n\nFootnotes\n\n 1. 流（Stream）| Node.js 中文文档 ↩\n\n 2. Node.js 中的 Stream（流） ↩\n\n 3. path.parse(path) | Node.js API ↩","routePath":"/docs/nodejs/01-file","lang":"","toc":[{"text":"管道流","id":"管道流","depth":2,"charIndex":3},{"text":"Node 的四种流类型","id":"node-的四种流类型","depth":2,"charIndex":115},{"text":"Node.js 文件操作","id":"nodejs-文件操作","depth":2,"charIndex":508},{"text":"流操作是异步的","id":"流操作是异步的","depth":2,"charIndex":581},{"text":"判断是文件还是文件夹","id":"判断是文件还是文件夹","depth":2,"charIndex":777},{"text":"创建文件夹","id":"创建文件夹","depth":2,"charIndex":882},{"text":"复制文件","id":"复制文件","depth":2,"charIndex":1176},{"text":"Node.js 相对路径变为绝对路径","id":"nodejs-相对路径变为绝对路径","depth":2,"charIndex":1207}],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"读取目录","content":"#\n\n现在的 Node.js 提供了三种读取目录的方法：\n\n * fsPromises.readdir(path[, options])，异步读取，返回值为 Promise 类型\n\n\n\n * fs.readdir(path[, options], callback)，异步读取，利用回调函数来处理成功和失败的情况\n\n\n\n * fs.readdirSync(path[, options])，同步读取\n\n\n\n同步读取目录的巧妙用法\n\n通常来说，我们在读取文件时，常常使用异步的方法，但是有时使用同步方法有妙用，比如 Koa 注册路由的时候：\n\n\n\n我们需要为每一个文件注册一个路由，但一行一行地写很麻烦，因此我们可以使用同步读取文件的方法：\n\n\n\n类似代码有，gulp 批量注册任务：\n\n","routePath":"/docs/nodejs/02-readdir","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"Nuxt 及其开发环境","content":"#\n\n命令                 解释\nnuxt dev -p 5431   在 5431 端口运行 nuxt","routePath":"/docs/nuxtjs/01-Nuxt 及其开发环境","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"Nuxt","content":"#\n\n笔记参考 Nuxt 官方文档\n\n思维导图：https://www.mubu.com/doc/1XFVXjTEKha","routePath":"/docs/nuxtjs/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"创建 Button","content":"#\n\n","routePath":"/docs/objective-c/01-button","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"创建 Webview","content":"#\n\n\n\n","routePath":"/docs/objective-c/02-webview","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"Native 向 Webview 发送消息","content":"我是本地的 HTML\n","routePath":"/docs/objective-c/03-native-send-msg","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"Webview 向 Native 发送消息","content":"我是本地的 HTML\n\n给 native 发送消息","routePath":"/docs/objective-c/04-webview-send-msg","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"prettier","content":"#\n\n提交代码时自动格式化更改过的文件。\n\n\n\n","routePath":"/docs/prettier/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"数据结构和控制结构","content":"#\n\n\n字符串、列表和元组#\n\n\n元组#\n\n\n\n元组和列表的区别：列表生成以后还可以往里面继续添加数据，也可以从里面删除数据；元组一旦生成就不能修改。\n\n如果一个元组里面只有整数、浮点数、字符串、另一个元组，这个元组既不能添加数据，也不能删除数据，还不能修改里面数据的值；如果一个元组里面包含了一个列表，这个元组里\n面的列表依旧可以变化。\n\n\n数据读取#\n\n之所以要把字符串、列表和元组放在一起介绍，是因为可以使用完全一样的方式从这3个数据结构中读取数据。\n\n\n指定下标#\n\n在大多数编程语言里面，下标都是从 0 开始的，Python 也不例外。第 0 个元素就是指最左边的元素。\n\n有所不同的是，Python 下标还有负数。-1 表示最后一个元素，-2 表示倒数第 2 个元素，-3 表示倒数第 3 个元素，以此类推。\n\n\n\n\n切片#\n\n字符串切片以后的结果还是字符串，列表切片以后的结果还是列表，元组切片以后的结果还是元组。切片的格式为：\n\n\n\n\n\n这 3\n个参数对应的都是数字。切片的结果包括开始位置下标所对应的元素，但是不包括结束位置下标所对应的元素。其中开始位置下标，结束位置下标，步长可以部分省略，但是不能全部\n省略。\n\n * 省略开始位置下标，表示从下标为 0 的元素开始计算。\n\n\n\n * 省略结束位置下标，表示直到最后一个元素且包含最后一个元素。\n\n\n\n * 省略开始位置下标和结束位置下标，步长取 -1，表示倒序输出。\n\n\n\n\n拼接与修改#\n\n字符串与字符串之间（列表与列表之间、元组和元组之间）可以相加，相加表示两个字符串（列表、元组）拼接起来。\n\n列表可以通过下标修改里面的值，字符串和元组则不可以。\n\n列表可以通过 append() 在末尾添加元素，字符串和元组也不可以。\n\n\n字典与集合#\n\n\n字典#\n\n字典就是使用大括号括起来的键（Key）值（Value）对（Key-Value对）。每个键值对之间使用英文逗号分隔，每个 Key 与 Value\n之间使用英文冒号分隔。\n\nKey 可以使用中文、英文或者数字，但是不能重复。Value 可以是任意字符串、数字、列表、元组或者另一个字典，Value 可以重复。\n\n\n\n可以通过 Key 来从字典中读取对应的 Value，有 3 种主要的格式：\n\n\n\n使用方括号的方式来读取字典的 Value 时，一定要保证字典里面有这个 Key 和它对应的 Value，否则程序会报错。使用 get 来读取，如果 get\n只有一个参数，那么在找不到 Key 的情况下会得到 None；如果 get 有两个参数，那么在找不到 Key 的情况下，会返回第 2 个参数。\n\n如果要修改一个已经存在的字典的 Key 对应的 Value，或者要往里面增加新的 Key-Value 对，可以使用以下格式：\n\n\n\n需要特别注意的是，字典的 Key 的顺序是乱的，所以不能认为先添加到字典里面的数据就排在前面。\n\n\n集合#\n\n集合是使用大括号括起来的各种数据，可以看作没有 Value 的字典。集合里面的元素不能重复。集合也是无序的。\n\n集合最大的应用之一就是去重。例如，把一个带有重复元素的列表先转换为集合，再转换回列表，那么重复元素就只会保留一个。\n\n把列表转换为集合需要使用 set() 函数，把集合转换为列表使用 list() 函数：\n\n\n\n由于集合与字典一样，里面的值没有顺序，因此使用集合来去重是有代价的，代价就是原来列表的顺序也会被改变。","routePath":"/docs/python/01-data-structure-and-control-structure","lang":"","toc":[{"text":"字符串、列表和元组","id":"字符串列表和元组","depth":2,"charIndex":3},{"text":"元组","id":"元组","depth":3,"charIndex":16},{"text":"数据读取","id":"数据读取","depth":2,"charIndex":171},{"text":"指定下标","id":"指定下标","depth":3,"charIndex":230},{"text":"切片","id":"切片","depth":3,"charIndex":364},{"text":"拼接与修改","id":"拼接与修改","depth":3,"charIndex":623},{"text":"字典与集合","id":"字典与集合","depth":2,"charIndex":751},{"text":"字典","id":"字典","depth":3,"charIndex":760},{"text":"集合","id":"集合","depth":3,"charIndex":1229}],"domain":"","frontmatter":{},"version":""},{"id":90,"title":"函数与类","content":"#\n\n\n函数与默认参数#\n\n在 Python 里面，函数的参数可以有默认值。当调用函数的时候不写参数时，函数就会使用默认参数。请看下面的代码：\n\n\n\n函数也可以有多个默认参数，例如如下的代码：\n\n\n\n\n类与面向对象#\n\n在 Python 中使用关键字 class 来定义一个类。类一般由以下元素构成：\n\n * 类名\n * 父类\n * 初始化方法（在有些编程语言中叫作构造函数）\n * 属性\n * 方法\n\n","routePath":"/docs/python/02-function-and-class","lang":"","toc":[{"text":"函数与默认参数","id":"函数与默认参数","depth":2,"charIndex":3},{"text":"类与面向对象","id":"类与面向对象","depth":2,"charIndex":100}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"读写文件","content":"#\n\n使用 Python 来读/写文本需要用到 \"open\" 这个关键字。它的作用是打开一个文件，并创建一个文件对象。使用 Python 打开文件，有两种写法。第 1\n种方式如下：\n\n\n\n第 2 种方式，使用 Python 的上下文管理器：\n\n\n\n第 1 种方式需要手动关闭文件，但是在程序开发中经常会出现忘记关闭文件的情况。第 2 种方法不需要手动关闭文件，只要代码退出了缩进，Python\n就会自动关闭文件。\n\n推荐第 2 种方式。\n\n\n读写文本文件#\n\n\n读#\n\n用 Python 打开一个文本文件时，首先要保证这个文件是存在的。在读文件的时候，\"文件操作方式\"这个参数可以省略，也可以写成 \"r\"，也就是 read\n的首字母。文件路径可以是绝对路径，也可以是相对路径。如果是绝对路径，Linux 和 Mac OS 不能直接使用\"～\"表示 \"home目录\"，因为 Python\n不认识 \"～\" 这个符号。如果非要使用这个符号，需要使用 Python 的 \"os\" 模块，代码如下：\n\n\n\n这样，Python 就会将这种风格的路径转化为 Python 能认识的绝对路径。\n\n文本文件可以按行读取，也可以直接读取里面的所有内容。读取所有行，并以列表的形式返回结果，代码如下：\n\n\n\n直接把文件里面的全部内容用一个字符串返回，代码如下：\n\n\n\n\n写#\n\n使用 Python 写文件也需要先打开文件，使用如下代码来打开文件：\n\n\n\n这里多出来一个参数 \"w\", w 是英文 write 的首字母，意思是以写的方式打开文件。这个参数除了为 \"w\" 外，还可以为\n\"a\"。它们的区别在于，如果原来已经有一个 new.txt 文件了，使用 \"w\" 会覆盖原来的文件，导致原来的内容丢失；而使用\n\"a\"，则会把新的内容写到原来的文件末尾。写文件时可以直接写一大段文本，也可以写一个列表。\n\n直接将一大段字符串写入到文本中，可以使用下面这段代码：\n\n\n\n把列表里面的所有字符串写入到文本中，可以使用下面这段代码：\n\n\n\n需要特别注意，写列表的时候，Python 写到文本中的文字是不会自动换行的，需要人工输入换行符才可以。\n\n\n读写 CSV 文件#\n\n\n读#\n\nCSV 文件可以用 Excel 或者 Numbers 打开，得到可读性很高的表格。\n\nCSV 文件本质上就是文本文件，但是如果直接用文本编辑器打开，可读性并不高。\n\nPython 自带操作 CSV 的模块。使用这个模块，可以将 CSV 文件的内容转换为 Python 的字典，从而方便使用。\n\n\n\n代码中，for 循环得到的 row 是 OrderedDict（有序字典），可以直接像普通字典那样使用：\n\n\n\n\n写#\n\nPython 可以把一个字典写成 CSV 文件，或者把一个包含字典的列表写成 CSV 文件。Python 写 CSV 文件比读 CSV\n文件稍微复杂一点，因为要指定列名。列名要和字典的 Key 一一对应。Python 写 CSV 文件时需要用到 csv.DictWriter()\n这个类。它接收两个参数：第 1 个参数是文件对象 f；第 2 个参数名为 fieldnames，值为字典的 Key 列表。写入 CSV 文件的列名行：\n\n","routePath":"/docs/python/03-read-and-write-file","lang":"","toc":[{"text":"读写文本文件","id":"读写文本文件","depth":2,"charIndex":220},{"text":"读","id":"读","depth":3,"charIndex":230},{"text":"写","id":"写","depth":3,"charIndex":572},{"text":"读写 CSV 文件","id":"读写-csv-文件","depth":2,"charIndex":907},{"text":"读","id":"读-1","depth":3,"charIndex":920},{"text":"写","id":"写-1","depth":3,"charIndex":1130}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"正则表达式的基本符号","content":"#\n\n在爬虫的开发中，需要把有用的信息从一大段文本中提取出来。正则表达式是提取信息的方法之一。正则表达式虽然不是最简单的也不是最高效的数据提取方法，但它是最直接的。而\n且在某些情况下，只有使用正则表达式才能达到目的。学好正则表达式，是开发爬虫的第一步。\n\n正则表达式（Regular Expression）是一段字符串，它可以表示一段有规律的信息。\n\n\n点号 \".\"#\n\n一个点号可以代替除了换行符以外的任何一个字符，包括但不限于英文字母、数字、汉字、英文标点符号和中文标点符号。例如，有如下几个不同的字符串：\n\n\n\n这些字符串的前3个字符都是 kin，后两个字符都是 me，只有中间的3个字符不同。如果使用点号来表示，那么全部都可以变成 kin...me\n的形式，中间有多少个字就用多少个点。\n\n\n星号 \"*\"#\n\n一个星号可以表示它前面的一个子表达式（普通字符、另一个或几个正则表达式符号）0 次到无限次。\n\n例如，有如下几个不同的字符串：\n\n\n\n这些字符串里面，\"哈\"字重复出现，所以如果用星号来表示，那么就可以全部变成：\n\n\n\n由于星号可以表示它前面的字符 0 次，没有\"哈\"字，这个正则表达式也是匹配给出的几个不同的字符串的。\n\n\n\n既然星号可以表示它前面的字符，那么如果它前面的字符是一个点号呢？例如下面这个正则表达式：\n\n\n\n它表示在\"如\"和\"哈\"中间出现\"任意多个除了换行符以外的任意字符\"。这句话看起来有点绕，用下面几个字符串来说明，它们全部都可以用上面的这个正则表达式来表示：\n\n\n\n\n问号 \"?\"#\n\n问号表示它前面的子表达式 0 次或者 1 次。注意，这里的问号是英文问号。例如下面这两个不同的字符串：\n\n\n\n在汉字\"来\"和中文句号之间有 0 个或者 1 个\"哈\"字，都可以使用下面这个正则表达式来表示：\n\n\n\n问号最大的用处是与点号和星号配合起来使用，构成\".*?\"。通过正则表达式来提取信息的时候，用到最多的也是这个组合。下面的所有字符串：\n\n\n\n都可以用下面这个正则表达式来表示：\n\n\n\n\n反斜杠 \"\"#\n\n在正则表达式里面，很多符号都是有特殊意义的，例如问号、星号、大括号、中括号和小括号。那么如果要匹配的内容里面本身就有这些符号怎么办呢？如何告诉正则表达式现在只想\n把星号当作普通的星号来使用呢？\n\n这个时候反斜杠就要登场了。反斜杠放在星号的前面，写成 \"*\" 可以把星号变成普通的字符，不再具有正则表达式的意义。\n\n\n数字 \"\\d\"#\n\n正则表达式里面使用 \"\\d\" 来表示一位数字。为什么要用字母 d 呢？因为 d 是英文 \"digital（数字）\" 的首字母。再次强调一下，\"\\d\"\n虽然是由反斜杠和字母 d 构成的，但是要把 \"\\d\" 看成一个正则表达式符号整体。如果要提取 2 个数字，可以使用 \\d\\d；如果要提取 3 个数字，可以使用\n\\d\\d\\d。但是如果不知道这个数有多少位怎么办呢？就需要用 * 号来表示一个任意位数的数字。\n\n\n小括号 \"()\"#\n\n小括号可以把括号里面的内容提取出来。前面讲到的符号仅仅能让正则表达式\"表示\"一串字符串。但是如果要从一段字符串中\"提取\"出一部分的内容应该怎么办呢？这个时候就需\n要使用小括号了。有如下一个字符串：\n\n\n\n可以看出，这里的密码左边有一个英文冒号，右边有一个汉字\"你\"。当构造一个正则表达式：.*?你 时，得到的结果将会是：\n\n\n\n然而，冒号和汉字\"你\"并不是密码的一部分，如果只想要 \"12345abcde\"，就需要使用括号：\n\n\n\n得到的结果就是：\n\n\n\n\n\".*?\" 和 \".?\" 的区别#\n\n下面通过一个实际的例子来进行说明。请看下面这一段话：\n\n\n\n这段话有一个显著的规律，是在\"密码是\"这 3 个汉字的后面跟一个中文的冒号，冒号后面是密码，密码后面是中文的逗号。\n\n * 密码是(.*),，能够提取到的信息是 1234567, QQ 密码是: 33445566, 银行卡密码是: 888888, GitHub 密码是:\n   999abc999\n * 密码是(.*?),，能够提取到的信息是 1234567，33445566，888888，999abc999\n\n举一个例子，10 个人肩并肩并排站着，使用 (.*) 取到了第 1 个人左手到第 10 个人右手之间的所有东西，而使用 (.*?)\n取到的是每个人的左手和右手之间的东西。\n\n一句话总结如下:\n\n * .*：贪婪模式，获取最长的满足条件的字符串。\n * .*?：非贪婪模式，获取最短的能满足条件的字符串。","routePath":"/docs/python/04-basic-symbols-of-regular-expressions","lang":"","toc":[{"text":"点号 \".\"","id":"点号-","depth":2,"charIndex":176},{"text":"星号 \"*\"","id":"星号-","depth":2,"charIndex":349},{"text":"问号 \"?\"","id":"问号-","depth":2,"charIndex":652},{"text":"反斜杠 \"\"","id":"反斜杠-","depth":2,"charIndex":859},{"text":"数字 \"\\d\"","id":"数字-d","depth":2,"charIndex":1026},{"text":"小括号 \"()\"","id":"小括号-","depth":2,"charIndex":1241},{"text":"\".*?\" 和 \".?\" 的区别","id":"-和--的区别","depth":2,"charIndex":1481}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"使用正则表达式","content":"#\n\nPython 的正则表达式模块名字为 \"re\"，也就是 \"regular expression\" 的首字母缩写。在 Python\n中需要首先导入这个模块再进行使用。导入的语句为：\n\n\n\n\nfindall()#\n\nPython 的正则表达式模块包含一个 findall 方法，它能够以列表的形式返回所有满足要求的字符串。findall 的函数原型为：\n\n\n\npattern 表示正则表达式，string 表示原来的字符串，flags 表示一些特殊功能的标志。\n\nfindall 的结果是一个列表，包含了所有的匹配到的结果。如果没有匹配到结果，就会返回空列表。\n\n\n\n当需要提取某些内容的时候，使用小括号将这些内容括起来，这样才不会得到不相干的信息。如果包含多个 \"(.*? )\"\n怎么返回呢？返回的仍然是一个列表，但是列表里面的元素变为了元组。比如下面这个例子，元组里面的第 1 个元素是账号，第 2 个元素为密码。\n\n\n\n函数原型中有一个 flags 参数。这个参数是可以省略的。当不省略的时候，具有一些辅助功能，例如忽略大小写、忽略换行符等。这里以忽略换行符为例来进行说明:\n\n\n\n在爬虫的开发过程中非常容易出现这样的情况，要匹配的内容存在换行符 \"\\n\"。要忽略换行符，就需要使用到 \"re.S\" 这个 flag。虽然说匹配到的结果中出现了\n\"\\n\" 这个符号，不过总比什么都得不到强。内容里面的换行符在后期清洗数据的时候把它替换掉即可。\n\n\nsearch()#\n\nsearch() 的用法和 findall() 的用法一样，但是 search() 只会返回第 1\n个满足要求的字符串。一旦找到符合要求的内容，它就会停止查找。对于从超级大的文本里面只找第 1 个数据特别有用，可以大大提高程序的运行效率。\n\nsearch() 的函数原型为：\n\n\n\n对于结果，如果匹配成功，则是一个正则表达式的对象；如果没有匹配到任何数据，就是 None。如果需要得到匹配到的结果，则需要通过. group()\n这个方法来获取里面的值。\n\n\n\n只有在 .group() 里面的参数为1的时候，才会把正则表达式里面的括号中的结果打印出来。.group() 的参数最大不能超过正则表达式里面括号的个数。参数为\n1 表示读取第1个括号中的内容，参数为 2 表示读取第 2 个括号中的内容，以此类推。\n\n\n\n\n使用技巧#\n\n\n不需要 compile#\n\n网上很多人的文章中，正则表达式使用re.compile()这个方法，导致代码变成下面这样：\n\n\n\n这种写法虽然结果正确，但纯粹是画蛇添足。如果阅读 Python 的正则表达式模块的源代码，就可以看出 re.compile() 是完全没有必要的。\n\nre.findall() 自带 re.compile() 的功能，所以没有必要使用 re.compile()。\n\n\n先抓大后抓小#\n\n一些无效内容和有效内容可能具有相同的规则。这种情况下很容易把有效内容和无效内容混在一起，如下面这段文字：\n\n\n\n有效用户和无效用户的名字前面都以 \"姓名: \" 开头，如果使用 \"姓名: (.*?)\\n\" 来进行匹配，就会把有效信息和无效信息混在一起，难以区分。\n\n要解决这个问题，就需要使用先抓大再抓小的技巧。先把有效用户这个整体匹配出来，再从有效用户里面匹配出人名。\n\n先抓大再抓小的思想会贯穿整个爬虫开发过程，一定要重点掌握。\n\n\n括号内和括号外#\n\n在上面的例子中，括号和 \".*?\" 都是一起使用的，因此可能会有读者认为括号内只能有这 3 种字符，不能有其他普通的字符。但实际上，括号内也可以有其他字符。\n\n\n\n如果括号里面有其他普通字符，那么这些普通字符就会出现在获取的结果里面。举一个例子，如果说\"左手和右手之间\"，一般指的是躯干这一部分。但如果说\"左手和右手之间，包\n括左手和右手\"，那么就是指的整个人。而把普通的字符放在括号里面，就表示结果中需要包含它们。","routePath":"/docs/python/05-use-regular-expressions","lang":"","toc":[{"text":"findall()","id":"findall","depth":2,"charIndex":96},{"text":"search()","id":"search","depth":2,"charIndex":626},{"text":"使用技巧","id":"使用技巧","depth":2,"charIndex":996},{"text":"不需要 compile","id":"不需要-compile","depth":3,"charIndex":1004},{"text":"先抓大后抓小","id":"先抓大后抓小","depth":3,"charIndex":1200},{"text":"括号内和括号外","id":"括号内和括号外","depth":3,"charIndex":1427}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"简单网页爬虫","content":"#\n\n爬虫的数据爬取量非常大，显然不可能对每个页面都手动复制源代码，因此就有必要使用自动化的方式来获取网页源代码。requests 是 Python 的一个第三方\nHTTP（Hypertext Transfer Protocol，超文本传输协议）库，它比 Python 自带的网络库 urllib\n更加简单、方便和人性化。使用 requests 可以让Python实现访问网页并获取源代码的功能。\n\n\n\n如果系统同时有 Python 2 和 Python 3，并且 Python 3 是后安装的，那么要为 Python 3安装第三方库，就需要使用如下命令:\n\n\n\n\n使用 requests 获取网页源代码#\n\n\n\n有时需要使用 requests 的 post() 方法来获取源代码。post() 方法的格式如下：\n\n\n\n其中，data 这个字典的内容和项数需要根据实际情况修改，Key 和\nValue在不同的网站是不一样的。而做爬虫，构造这个字典是任务之一。还有一些网址，提交的内容需要是 JSON 格式的，因此 post()\n方法的参数需要进行一些修改：\n\n\n\n\n多线程爬虫#\n\n在掌握了 requests\n与正则表达式以后，就可以开始实战爬取一些简单的网址了。但是，此时的爬虫只有一个进程、一个线程，因此称为单线程爬虫。单线程爬虫每次只访问一个页面，不能充分利用计算\n机的网络带宽。一个页面最多也就几百KB，所以爬虫在爬取一个页面的时候，多出来的网速和从发起请求到得到源代码中间的时间都被浪费了。\n\n如果可以让爬虫同时访问 10 个页面，就相当于爬取速度提高了 10 倍。为了达到这个目的，就需要使用多线程技术了。这里有一点要强调，Python\n这门语言在设计的时候，有一个全局解释器锁（Global Interpreter Lock, GIL）。这导致 Python\n的多线程都是伪多线程，即本质上还是一个线程，但是这个线程每个事情只做几毫秒，几毫秒以后就保存现场，换做其他事情，几毫秒后再做其他事情，一轮之后回到第一件事上，恢\n复现场再做几毫秒，继续换……微观上的单线程，在宏观上就像同时在做几件事。\n\n这种机制在 I/O（Input/Output，输入/输出）密集型的操作上影响不大，但是在 CPU 计算密集型的操作上面，由于只能使用 CPU\n的一个核，就会对性能产生非常大的影响。所以涉及计算密集型的程序，就需要使用多进程，Python 的多进程不受 GIL 的影响。\n\n爬虫属于 I/O 密集型的程序，所以使用多线程可以大大提高爬取效率。\n\n\n多进程库#\n\nmultiprocessing 本身是 Python\n的多进程库，用来处理与多进程相关的操作。但是由于进程与进程之间不能直接共享内存和堆栈资源，而且启动新的进程开销也比线程大得多，因此使用多线程来爬取比使用多进程有\n更多的优势。multiprocessing 下面有一个 dummy 模块，它可以让 Python 的线程使用multiprocessing 的各种方法。\n\ndummy 下面有一个 Pool 类，它用来实现线程池。这个线程池有一个 map() 方法，可以让线程池里面的所有线程都“同时”执行一个函数。\n\n例如计算 0～9的每个数的平方。在学习了 for 循环之后，代码可能会写成这样：\n\n\n\n这种写法当然可以得到结果，但是代码是一个数一个数地计算，效率并不高。而如果使用多线程的技术，让代码同时计算很多个数的平方，就需要使用\nmultiprocessing.dummy 来实现：\n\n\n\n在上面的代码中，先定义了一个函数用来计算平方，然后初始化了一个有 3 个线程的线程池。这 3 个线程负责计算 10\n个数字的平方，谁先计算完手上的这个数，谁就先取下一个数继续计算，直到把所有的数字都计算完成为止。\n\n在这个例子中，线程池的 map() 方法接收两个参数，第 1 个参数是函数名，第 2 个参数是一个列表。注意：第 1 个参数仅仅是函数的名字，是不能带括号的。第\n2 个参数是一个可迭代的对象，这个可迭代对象里面的每一个元素都会被函数 clac_power2() 接收来作为参数。除了列表以外，元组、集合或者字典都可以作为\nmap() 的第 2 个参数。\n\n需要注意的是，这个例子仅仅用来演示多线程的使用方法。由于这个例子不涉及 I/O 操作，所以在 Python GIL 的影响下，使用 3\n个线程并不会使代码的运行时间小于单线程的运行时间。\n\n\n开发多线程爬虫#\n\n由于爬虫是 I/O\n密集型的操作，特别是在请求网页源代码的时候，如果使用单线程来开发，会浪费大量的时间来等待网页返回，所以把多线程技术应用到爬虫中，可以大大提高爬虫的运行效率。\n\n举一个例子。洗衣机洗完衣服要 50min，水壶烧水要 15min，背单词要\n1h。如果先等着洗衣机洗衣服，衣服洗完了再烧水，水烧开了再背单词，一共需要125min。但是如果换一种方式，从整体上看，3\n件事情是可以同时运行的，假设你突然分身出另外两个人，其中一个人负责把衣服放进洗衣机并等待洗衣机洗完，另一个人负责烧水并等待水烧开，而你自己只需要背单词就可以了。\n等到水烧开，负责烧水的分身先消失。等到洗衣机洗完衣服，负责洗衣服的分身再消失。最后你自己本体背完单词。只需要 60min 就可以同时完成 3 件事。\n\n当然，聪明的读者肯定会发现上面的例子并不是生活中的实际情况。现实中没有人会分身。真实生活中的情况是，人背单词的时候就专心背单词；水烧开后，水壶会发出响声提醒；衣\n服洗完了，洗衣机会发出“滴滴”的声音。所以到提醒的时候再去做相应的动作就好，没有必要每分钟都去检查。\n\n上面的两种差异，其实就是多线程和事件驱动的异步模型的差异。本小节讲到的是多线程操作，后面的章节会讲到使用异步操作的爬虫框架。现在，读者只需要记住，在需要操作的动\n作数量不大的时候，这两种方式的性能没有什么区别，但是一旦动作的数量大量增长，多线程的效率提升就会下降，甚至比单线程还差。而到那个时候，只有异步操作才是解决问题的\n办法。\n\n下面通过两段代码来对比单线程爬虫和多线程爬虫爬取百度首页的性能差异。\n\n\n\n从运行结果可以看到，一个线程用时约 16.2s, 5 个线程用时约 3.5s，时间 5 线程大于是单线程的五分之一。可以看到 5 个线程“同时运行”的效果。\n\n但并不是说线程池设置得越大越好。从上面的结果也可以看到，5\n个线程运行的时间其实比一个线程运行时间的五分之一要多一点。这多出来的一点其实就是线程切换的时间。这也从侧面反映了 Python\n的多线程在微观上还是串行的。因此，如果线程池设置得过大，线程切换导致的开销可能会抵消多线程带来的性能提升。线程池的大小需要根据实际情况来确定，并没有确切的数据。","routePath":"/docs/python/06-simple-web-crawler","lang":"","toc":[{"text":"使用 requests 获取网页源代码","id":"使用-requests-获取网页源代码","depth":2,"charIndex":282},{"text":"多线程爬虫","id":"多线程爬虫","depth":2,"charIndex":482},{"text":"多进程库","id":"多进程库","depth":3,"charIndex":1078},{"text":"开发多线程爬虫","id":"开发多线程爬虫","depth":3,"charIndex":1867}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"父组件调用子组件方法","content":"#\n\nReact 使用 Function Components 时，如果父组件要调用子组件的方法，则需要用到三个 Hooks:\n\n * useRef\n * forwardRef\n * useImperativeHandle\n\n用法如下：\n\n\n\n下面是一个实时演示：\n\n","routePath":"/docs/react/01-父组件调用子组件方法","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"添加依赖和移除依赖","content":"#\n\n命令                    解释\ncargo new             新建项目\ncargo run             运行项目\ncargo check           检查项目是否可用\ncargo build           编译但不运行项目\ncargo clean           删除 target 目录\ncargo run --release   发布模式下编译并运行\ncargo fmt             修改项目格式\ncargo clippy          得到修改建议\ncargo add             添加依赖\ncargo remove          移除依赖\n\n添加依赖后，Cargo.toml 的 [dependencies] 下方，会出现你安装的依赖名称和版本号。\n\n","routePath":"/docs/rust/01-Rust 及其开发环境/03-用 Cargo 管理项目","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"整型","content":"#\n\n整数类型简称 整型，rust 中的整型分为有符号整型和无符号整型。\n\n位长度       有符号     无符号\n8-bit     i8      u8\n16-bit    i16     u16\n32-bit    i32     u32\n64-bit    i64     u64\n128-bit   i128    u128\narch      isize   usize\n\n\n整型互相转换#\n\nas 操作符可以将让整型互相转换。\n\n\n数字转字符串#\n\n我们可以直接使用 to_string() 方法将数字转换为字符串。\n\n","routePath":"/docs/rust/02-Rust 的第一步/01-integer","lang":"","toc":[{"text":"整型互相转换","id":"整型互相转换","depth":2,"charIndex":195},{"text":"数字转字符串","id":"数字转字符串","depth":2,"charIndex":224}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"字符串 String 和 &str","content":"#\n\nRust 有 String 和 &str 两种字符串类型，其中，&str 是 String 的切片类型。也就是说，&str 是 String 的一部分。\n\nString 是可变的（mutable），而 &str 是不可变的（immutable）\n\n\nString 和 &str 互相转换#\n\n * String 转 &str\n\n我们可以使用 & 操作符，将 String 类型转换为 &str 类型。\n\n\n\n * &str 转 String\n\n我们可以使用 to_string() 方法将 &str 类型转换为 String 类型。\n\n\n\n\nString 和 char 互相转换#\n\n * String 转 char\n\n我们可以使用 chars() 将 String 转换为 char 类型的数组。\n\n\n\n如果我们想获得字符串中特定的字符，我们可以往 nth() 方法中传入索引。\n\n其中，unwrap_or('\\0') 的作用是，如果 nth() 没有查找到特定索引的字符，会返回一个 None，而使用 unwrap_or('\\0')\n时则会提供一个默认值 '\\0'; [^1]\n\n\n\n * char 转 String\n\n我们可以使用 to_string() 方法，将单个字符转换为字符串。\n\n\n\n当出现多个字符时，我们可以将字符一个接一个 push() 到字符串中，这样便自动实现了字符到字符串的转换。\n\n\n\n我们也可以先使用 collect() 方法，实现字符到字符串的转换。\n\n\n\n\n比较 String 是否相等#\n\n在 Rust 中，我们可以直接使用 == 运算符，判断两个字符串是否相等。\n\n\n\n\nsplit_whitespace() 去除空白符号#\n\n在 Rust 中，我们可以通过 split_whitespace() 去除字符串中的 space，tab 和 newlines 等符号。\n\n\n\n\n拼接 &str 成为 String#\n\nrust 提供了很多方法来拼接字符串，每一种方法都有特定的使用情况。\n\n * format!()，最简单直接的方法\n\n\n\n * push_str()，追加字符串时，更适合使用的方法\n\n\n\n * concat()，将字符串数组连接成一个字符串\n\n\n\n * join()，将字符串数组连接成一个字符串，连接符可以自己设置\n\n\n\n * +，运算符，需要两侧的字符串类型分别为 &str 和 String\n\n\n\n\n标准字符串和原始字符串#\n\n在 Rust 中，字符串字面量（string iteral）有两种表示方式，标准字符串字面量（standard string\niteral）和原始字符串字面量（raw string iteral）。\n\n * 标准字符串\n\n标准字符串使用 \"\" 包含。在标准字符串中，\\ 有特殊含义，用于表示转义字符串。比如 \"hello\\\\world\" 打印后是 hello\\world。\n\n\n\n * 原始字符串\n\n原始字符串使用 r#\"...\"# 格式包含，其中 # 可以被替换为任何字符。原始字符串不支持转义字符。比如 r#\"hello\\\\world\"# 打印后是\nhello\\\\world。\n\n\n\n原始字符串可以避免繁琐的反斜杠，让代码更清晰易懂。因此在表示正则表达式、文件路径时，我们通常会选择原始字符串字面量。\n\n\n字符串和所有权#\n\n 1. Rust 中的每一个值都有一个变量，称为其所有者；\n 2. 值在任一时刻有且只有一个所有者；\n 3. 当所有者（变量）离开作用域，这个值将被丢弃。\n\n举例来说：下述代码将会报错，因为变量 your_name 离开作用域后，变量就销毁了。\n\n如果把 print_name_2 和 print_name_1 调换位置，则能够正常运行，因为 print_name_2 借用了 your_name\n的所有权，your_name 变量还存在。\n\n","routePath":"/docs/rust/02-Rust 的第一步/02-string-&str","lang":"","toc":[{"text":"String 和 &str 互相转换","id":"string-和-str-互相转换","depth":2,"charIndex":127},{"text":"String 和 char 互相转换","id":"string-和-char-互相转换","depth":2,"charIndex":273},{"text":"比较 String 是否相等","id":"比较-string-是否相等","depth":2,"charIndex":648},{"text":"split_whitespace() 去除空白符号","id":"split_whitespace-去除空白符号","depth":2,"charIndex":707},{"text":"拼接 &str 成为 String","id":"拼接-str-成为-string","depth":2,"charIndex":808},{"text":"标准字符串和原始字符串","id":"标准字符串和原始字符串","depth":2,"charIndex":1031},{"text":"字符串和所有权","id":"字符串和所有权","depth":2,"charIndex":1400}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"正则表达式","content":"#\n\n * replace_all() 可以替换掉所有正则表达式匹配到的字符。\n\n","routePath":"/docs/rust/02-Rust 的第一步/03-regex","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":100,"title":"动态数组 Vector","content":"#\n\n\n翻转数组 reverse#\n\nRust 中，我们可以使用 reverse() 直接翻转数组。\n\n","routePath":"/docs/rust/02-Rust 的第一步/04-vector","lang":"","toc":[{"text":"翻转数组 reverse","id":"翻转数组-reverse","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":101,"title":"","content":"assert_eq!#\n\nRust 有一个 assert_eq! 1 的辅助宏，可以辅助我们测试。\n\n以 LeetCode 中的 Defanging an IP Address 2 题目为例，我们给需要提交的代码编写两个测试用例：\n\n\n\n\n参考资料#\n\n\nFootnotes\n\n 1. Unit testing | Rust ↩\n\n 2. Defanging an IP Address | LeetCode ↩","routePath":"/docs/rust/02-Rust 的第一步/05-test","lang":"","toc":[{"text":"assert_eq!","id":"assert_eq","depth":2,"charIndex":-1},{"text":"参考资料","id":"参考资料","depth":2,"charIndex":119}],"domain":"","frontmatter":{},"version":""},{"id":102,"title":"Rust","content":"#\n\n笔记参考《Rust 游戏开发实战》\n\n思维导图：https://www.mubu.com/doc/6CB5Ftq2D5a","routePath":"/docs/rust/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":103,"title":"顶点着色器和片元着色器","content":"#\n\n着色器，就是让开发者自己去编写一段程序，用来代替固定渲染管线，来处理图片的渲染。\n\n顶点着色器，三维的坐标；片元着色器，可以理解为一个像素。JavaScript 读取相关着色器信息，传递给 webgl 并进行使用。\n\n最基础的，绘制一个点的 webgl 程序：\n\n\n\n\n\n其中，顶点着色器和片元着色器程序中，必须有分号。\n\n上述 js 代码中，可以封装一个初始化着色器的函数：\n\n","routePath":"/docs/webgl/01-vertex-and-fragment","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":104,"title":"坐标系","content":"#\n\nwebgl 的坐标系：\n\n\n\n当 webgl 点的坐标是 (0.0, 0.0, 0.0, 1.0) 时，从二维来看，它位于中心。\n\n\n\n为了可以随意地改变中心，我们可以使用顶点着色器中的 attribute 变量：\n\n","routePath":"/docs/webgl/02-xyz","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":105,"title":"鼠标绘制","content":"#\n\nwebgl 的 x, y, z 坐标轴，取值是从 -1 到 1。\n\n\n\n\n\n","routePath":"/docs/webgl/03-mouse-drawing","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":106,"title":"uniform","content":"#\n\nattribute 变量只能在顶点着色器里面使用。如果想在片元着色器里面使用，只能使用 uniform 变量。\n\nuniform 变量需要设置精度，分为低精度 lowp、中精度 mediump 和高精度 highp。如果需要改变颜色，可以使用 precision\nmediump float; 设置精度。\n\n\n\n\nuniform4f() 同族函数介绍#\n\n * gl.uniform1f(location, v0)\n * gl.uniform2f(location, v0, v1)\n * gl.uniform3f(location, v0, v1, v2)\n * gl.uniform4f(location, v0, v1, v2, v3)\n\n其中，location 指定 uniform 变量的存储位置，而 v0, v1, v2 和 v3 则是传入的四个分量的值。\n\n使用 uniform3f() 时，有 1 个分量被省略，我们可以用如下方法给 uniform 变量赋值：\n\n\n\n使用 uniform2f() 时，有 2 个分量被省略，我们可以用如下方法给 uniform 变量赋值：\n\n\n\n使用 uniform1f() 时，有 3 个分量被省略，我们可以用如下方法给 uniform 变量赋值：\n\n","routePath":"/docs/webgl/04-uniform","lang":"","toc":[{"text":"uniform4f() 同族函数介绍","id":"uniform4f-同族函数介绍","depth":2,"charIndex":159}],"domain":"","frontmatter":{},"version":""},{"id":107,"title":"使用缓冲区对象绘制多个点","content":"#\n\n\n什么是缓冲区对象#\n\n缓冲区对象是 WebGL 系统中的一块内存区域，可以一次性向缓冲区对象内填充大量的顶点数据，然后将这些数据保存其中，给顶点着色器使用。\n\n\n\n创建顶点数据：\n\n\n\n\n类型化数组#\n\n在 WebGL 中，需要处理大量的相同类型的数据，所以引入类型化数组，这样程序就可以与预知到数组中的数据类型，提高性能。\n\n类型             说明\nInt32Array     32 位整型\nUInt32Array    32 位无符号整型\nFloat32Array   单精度 32 位浮点型\nFloat64Array   双精度 64 位浮点型\n\n\n创建缓冲区对象#\n\n\n\n\n绑定缓冲区对象#\n\n\n\n * target，可以是如下两种\n   * gl.ARRAY_BUFFER，表示缓冲区存储的是顶点的数据\n   * gl.ELEMENT_ARRAY_BUFFER，表示缓冲区存储的是顶点的索引值\n * buffer，已经创建好的缓冲区对象\n\n\n将数据写入缓冲区对象#\n\n\n\n * target，类型同 gl.bindBuffer 中的 target\n * data，写入缓冲区的顶点数据\n * type，表示如何使用缓冲区对象中的数据，分为以下几类\n   * gl.STATIC_DRAW，写入一次，多次绘制\n   * gl.STREAM_DRAW，写入一次，绘制若干次\n   * gl.DYNAMIC_DRAW，写入多次，绘制多次\n\n\n将缓冲区对象分配给一个 attribute 变量#\n\n\n\n * location，attribute 变量的存储地址\n * size，没绘制一个顶点需要几个数据\n * type，指定数据格式\n   * gl.FLOAT，浮点型\n   * gl.UNSIGNED_BYTE，无符号字节\n   * gl.SHORT，短整型\n   * gl.UNSIGNED_SHORT，无符号短整型\n   * gl.INT，整型\n   * gl.UNSIGNED_INT，无符号整型\n * normalized，表示是否将数据归一化到 [0, 1] [-1, 1] 这个区间\n * stride，两个相邻顶点之间的字节数\n * offset，数据偏移量\n\n\n开启 attribute 变量#\n\n\n\n有个对应的关闭 attribute 的方法 gl.disableVertexAttribArray(aPosition)。\n\n\n\n效果如下：\n\n","routePath":"/docs/webgl/05-buffer","lang":"","toc":[{"text":"什么是缓冲区对象","id":"什么是缓冲区对象","depth":2,"charIndex":3},{"text":"类型化数组","id":"类型化数组","depth":2,"charIndex":97},{"text":"创建缓冲区对象","id":"创建缓冲区对象","depth":2,"charIndex":288},{"text":"绑定缓冲区对象","id":"绑定缓冲区对象","depth":2,"charIndex":301},{"text":"将数据写入缓冲区对象","id":"将数据写入缓冲区对象","depth":2,"charIndex":436},{"text":"将缓冲区对象分配给一个 attribute 变量","id":"将缓冲区对象分配给一个-attribute-变量","depth":2,"charIndex":633},{"text":"开启 attribute 变量","id":"开启-attribute-变量","depth":2,"charIndex":952}],"domain":"","frontmatter":{},"version":""},{"id":108,"title":"多缓冲区和数据偏移","content":"#\n\n上一节介绍了如何利用缓冲区绘制多个点，这节介绍如何创建多缓冲区。\n\n比如同样要画三个点，三个点的位置不一样，大小也不一样，我们可以这样写：\n\n\n\n\n\n不难看出，两段代码的相似程度很高，有什么办法可以降低代码重复度吗？\n\n这时候就需要用到代码偏移，代码如下：\n\n\n\n我们可以复习一下 vertexAttribPointer 的使用方法：\n\n\n\n * location，attribute 变量的存储地址\n * size，没绘制一个顶点需要几个数据\n * type，指定数据格式\n   * gl.FLOAT，浮点型\n   * gl.UNSIGNED_BYTE，无符号字节\n   * gl.SHORT，短整型\n   * gl.UNSIGNED_SHORT，无符号短整型\n   * gl.INT，整型\n   * gl.UNSIGNED_INT，无符号整型\n * normalized，表示是否将数据归一化到 [0, 1] [-1, 1] 这个区间\n * stride，两个相邻顶点之间的字节数\n * offset，数据偏移量\n\n","routePath":"/docs/webgl/06-multi-buffer","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":109,"title":"实现多种图形的绘制","content":"#\n\n\n\n值                   作用    说明\ngl.POINTS           点     一系列点\ngl.LINES            线段    一系列单独的线段，如果顶点是奇数，最后一个点会被忽略\ngl.LINE_LOOP        闭合线   一系列连接的线段，结束时，会闭合终点和起点\ngl.LINE_STRIP       线条    一系列连接的线条，不会闭合终点和起点\ngl.TRIANGLES        三角形   一系列单独的三角形\ngl.TRIANGLE_STRIP   三角带   一系列条带状的三角形\ngl.TRIANGLE_FAN     三角形   飘带状三角形","routePath":"/docs/webgl/07-multi-shape","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":110,"title":"着色器实现图形动画","content":"#\n\n\n图形平移#\n\n\n\n关键代码如下：\n\n\n\n\n图形缩放#\n\n\n\n关键代码如下：\n\n\n\n\n旋转#\n\n\n\n关键代码如下：\n\n","routePath":"/docs/webgl/08-animation","lang":"","toc":[{"text":"图形平移","id":"图形平移","depth":2,"charIndex":3},{"text":"图形缩放","id":"图形缩放","depth":2,"charIndex":24},{"text":"旋转","id":"旋转","depth":2,"charIndex":45}],"domain":"","frontmatter":{},"version":""},{"id":111,"title":"矩阵实现平移、旋转、缩放","content":"#\n\n\n平移矩阵#\n\n\n\n\n\n\n\n\n缩放矩阵#\n\n\n\n\n\n\n\n\n旋转矩阵#\n\n\n\n\n\n\n\n\n复合变化#\n\n如果同时存在平移、旋转、缩放的动画，那么可以三个矩阵相乘。\n\n\n\n\n\n不过这样就需要赋值三个变量，比较复杂，我们可以封装一个矩阵乘法的函数：\n\n","routePath":"/docs/webgl/09-animation-matrix","lang":"","toc":[{"text":"平移矩阵","id":"平移矩阵","depth":2,"charIndex":3},{"text":"缩放矩阵","id":"缩放矩阵","depth":2,"charIndex":17},{"text":"旋转矩阵","id":"旋转矩阵","depth":2,"charIndex":31},{"text":"复合变化","id":"复合变化","depth":2,"charIndex":45}],"domain":"","frontmatter":{},"version":""},{"id":112,"title":"片元着色器动画","content":"#\n\n\n渐入渐出#\n\n\n\n关键代码如下：\n\n\n\n\n卷入卷出#\n\n\n\n关键代码如下：\n\n\n\n\n百叶窗#\n\n\n\n关键代码如下：\n\n\n\n加入循环后代码如下：\n\n","routePath":"/docs/webgl/10-fragment-shader-animation/","lang":"","toc":[{"text":"渐入渐出","id":"渐入渐出","depth":2,"charIndex":3},{"text":"卷入卷出","id":"卷入卷出","depth":2,"charIndex":24},{"text":"百叶窗","id":"百叶窗","depth":2,"charIndex":45}],"domain":"","frontmatter":{},"version":""},{"id":113,"title":"varying 变量","content":"#\n\n\n\n关键 js 代码如下：\n\n\n\nvarying 变量需要再顶点着色器和片元着色器同时设置。","routePath":"/docs/webgl/11-varying/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":114,"title":"渲染流程","content":"#\n\n\n\n * 图元装配流程：\n\n将独立的顶点坐标装配成几何图形，图形的类别由 gl.drawArrays() 第一个参数确定\n\n * 光栅化\n\n这一步是将装配好的图形转换为片元。\n\n * 剔除\n\n如果是不透明物体，背面对于观察者来说是不可见的。那么在渲染过程中，就会将不可见的部分剔除，不参与绘制。节省渲染开销。\n\n * 裁剪\n\n在可视范围外的事物，是看不到的。图形生成后，有的部分可能位于可视范围之外，这一部分会被剪裁掉，不参与绘制。","routePath":"/docs/webgl/12-render-process/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":115,"title":"登录注册","content":"#\n\n\nJSON Web Token 流程#\n\n一般流程：\n\n 1. 用户在客户端提供身份信息（一般是用户名和密码）\n 2. 服务器认证后，生成一个 JSON 对象，加密（防止用户篡改）后生成 Token 发给用户\n 3. 客户端将 Token 保存到本地\n 4. 客户端每次请求时将 Token 附加在请求头部\n 5. 服务器接到请求后，验证 Token 的有效性，并根据 Token 的信息进行授权\n\n\nJSON Web Token 优缺点#\n\n优点                         缺点\n有效使用 JWT，可以降低服务器查询数据库的次数   服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token\n                           的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n                           JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限","routePath":"/docs/个人开发/01-登录注册/","lang":"","toc":[{"text":"JSON Web Token 流程","id":"json-web-token-流程","depth":2,"charIndex":3},{"text":"JSON Web Token 优缺点","id":"json-web-token-优缺点","depth":2,"charIndex":203}],"domain":"","frontmatter":{},"version":""},{"id":116,"title":"","content":"用户数据库设计#\n\n字段名             类型        解释\nusername        String    用户名\npassword        String    密码\nemail           String    邮箱\nemailVerified   Boolean   邮箱是否验证\n\n\n会员资格数据库设计#\n\n字段名            类型        解释\nemail          String    邮箱\nexpirationAt   Date      会员过期时间\nlevel          String    等级，类似 B 站等级\nmember         String    普通会员、高级会员、终身会员\nuserObject     Pointer   指向用户表\nuserObjectId   String    用户的 Id\n\n\nTodo#\n\n * 阻止短时间内注册多次","routePath":"/docs/个人开发/02-会员资格","lang":"","toc":[{"text":"用户数据库设计","id":"用户数据库设计","depth":2,"charIndex":-1},{"text":"会员资格数据库设计","id":"会员资格数据库设计","depth":2,"charIndex":161},{"text":"Todo","id":"todo","depth":2,"charIndex":403}],"domain":"","frontmatter":{},"version":""},{"id":118,"title":"requestAnimationFrame 实现平滑滚动","content":"#\n\n大家好，我俊霖。\n\n最近接到一个修复通知，iOS 15.4 ~ 17，使用 CSS scroll-behavior: smooth 或 JavaScript 的 behavior:\n'smooth' 可能导致 iOS App Crash。\n\n我维护的 H5 有个锚定功能，是使用 element.scrollIntoView({ behavior: 'smooth' })\n来实现锚定并且带上动画的。现在得换种方法实现锚定。\n\n参考修复通知，我决定使用 requestAnimationFrame 来实现动画。\n\n首先，我准备改用 window.scrollTo() 替换掉 scrollIntoView 实现锚定。\n\n\n\n\nrequestAnimationFrame#\n\n下面这段代码的作用是：将页面平滑滚动到某个位置。它首先会获取当前滚动条的位置，然后计算目标位置和当前位置的距离，之后将这个距离分为若干个部分，每隔一段时间就滚动\n一部分，直到滚动到目标位置。\n\n\n\n我对 requestAnimationFrame 的理解，大概就是把它当做了一个 setInterval 的替代品。\n\n首先我用 setInterval 实现了一个锚定的滚动动画：\n\n","routePath":"/tmp/_2023-11-08-smoothly-scroll/","lang":"","toc":[{"text":"requestAnimationFrame","id":"requestanimationframe","depth":2,"charIndex":315}],"domain":"","frontmatter":{"tags":["requestAnimationFrame"]},"version":""},{"id":119,"title":"移动端适配 lib-flexible 和 postcss-pxtorem","content":"#\n\n最近看到，一般移动端适配会配合使用阿里的 lib-flexible 和 postcss-pxtorem 插件。\n\n我们假设我们的手机屏幕和设计稿都是 750px 的。\n\n使用 lib-flexible，会将 html 的 font-size 设置为屏幕宽度 clientWidth 的 1/10。也就是说 1rem = 75px;\n\n这时候，如果设计稿上有一个元素 width 是 200px 的，为了让手机屏幕能够适配。我们需要写 CSS 的时候，直接将 width 写成 (200 /\n75)rem。\n\n当然，手动将 px 换算为 rem 还是对我们写代码还是很不友好。这时候就可以使用 postcss-pxtorem 了。我们将这个插件配置的 rootValue\n写为 75px，这个插件会自动将我们的 css 从 px 换算为 rem。\n\n","routePath":"/tmp/_2023-11-14-px-to-rem/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":120,"title":"H5 转小程序非常多，为什么小程序转 H5 那么少呢？","content":"#","routePath":"/tmp/_2024-03-10-mini-program-to-h5/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":121,"title":"H5 刮刮乐效果如何实现","content":"#\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/fillRe\nct\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/clearR\nect","routePath":"/tmp/_2024-03-17-scratch-card/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":122,"title":"仿百亿补贴，H5 Tabs 和 List 的缓存方案如何设计","content":"#\n\n逛过百亿补贴的朋友，应该都看过下图的效果。向右滑动时，H5 会切换到新 Tab，加载新 Tab 对应的 List 数据，并把这部分数据缓存下来。\n\n当向左滑动时，可以看到旧 Tab 对应的 List。\n\n\n\n这种缓存方案如何设计呢？我实现设计了一番，发现情况的确比较复杂，便总结了这篇文章。\n\n接下来我会一步步分析百亿补贴对应的功能，并给出这些功能所需要缓存的数据。\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\nTabs 如何缓存#\n\n我们首先看下 Tabs 的功能。\n\n\n\n拼多多的 Tabs 分一级 Tab 和二级 Tab，二级 Tab 还可以展开和收缩。并且切换一级 Tab 时，之前选中的二级 Tab\n还能被保留。因此，我们需要记录的一个是二级 Tab 的数据，一个是选中的二级 Tab 下标，还有一个是二级 Tab 是否展开。\n\n\n\n\nList 如何缓存#\n\n\n第一页的状态#\n\n我们再来看下列表的状态。\n\n\n\n可以看到，第一页列表出于加载中时，会展示骨架屏；加载完成后，会直接展示数据。此外，我们还需要考虑到接口失败的情况。于是我们需要一个标记，来展示列表的状态。这个标\n记可以记为 status。\n\nstatus 有三种状态，分别是 loading（加载中）、finish（加载完毕）、error（加载失败）。我们把 status 再添加到需要缓存的字段中：\n\n\n\n\n加载更多的状态#\n\n\n\n再看列表底部的状态，目前能看到的状态是一个加载完成的状态，还有一个加载中的状态。\n\n不过加载更多的状态，不适合完全套用之前列表 status 的三种状态。\n\n当列表第一页时，底部状态应该是不展示的。我把底部状态设计为四种，分别是：\n\ninit（初始状态）、loading（加载中）、no_more（没有更多了）和 error（加载失败）。因此我们的缓存状态，需要再添加一个\nbottomStatus 状态。\n\n接下俩我们需要考虑，当加载下一页时，我们需要知道已经加载了多少页，所以我们还需要记录 pageIndex 这个状态。\n\n","routePath":"/tmp/_2024-03-23-ten-billion-subsidy-cache-tab-data/","lang":"","toc":[{"text":"Tabs 如何缓存","id":"tabs-如何缓存","depth":2,"charIndex":237},{"text":"List 如何缓存","id":"list-如何缓存","depth":2,"charIndex":404},{"text":"第一页的状态","id":"第一页的状态","depth":3,"charIndex":417},{"text":"加载更多的状态","id":"加载更多的状态","depth":3,"charIndex":622}],"domain":"","frontmatter":{},"version":""},{"id":123,"title":"","content":"拼多多的 SSR","routePath":"/tmp/_2024-04-08-ssr/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":124,"title":"仿今日头条，H5 的垂直滚动、Tab 水平切换如何实现？","content":"#\n\n我们经常在 App 中，看到这样的交互：\n\n * 用户纵向滚动页面时，横向的 Tab 会自动切换。\n * 用户点击横向 Tab 时，纵向的页面会自动锚定。\n\n比如今日头条的商品详情页中，四个 Tab 和页面滚动就有着上述联动关系：\n\n\n\n那么，这种效果该如何实现呢？本文我会先介绍布局，然后介绍页面滚动如何影响 Tab 水平切换，之后介绍 Tab\n水平切换如何影响页面滚动，最后给出完整的代码。最终我实现的效果如下：\n\n\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。\n\n\n\n\n总结#\n\n拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。","routePath":"/tmp/_2024-06-03-vertical-scrolling-but-horizontal-switching/","lang":"","toc":[{"text":"总结","id":"总结","depth":2,"charIndex":266}],"domain":"","frontmatter":{},"version":""},{"id":125,"title":"从快速切换 Tab 说起，先发出的请求后得到结果（请求竞态问题）如何解决？","content":"#\n\n开发 H5 的朋友或许都遇到过一个问题。场景如下，页面有一个 Tab，然后 Tab 下方有对应的商品列表：\n\n\n\n我们快速切换 Tab，会偶然发现 Tab 选项的商品不符合预期，比如最终选项是「男装」，但商品却还是「食品」。\n\n这是因为切换 Tab 时，我们会先发送「食品」的请求、再发送了「男装」的请求，但是由于网络速度等原因，接口先返回了「男装」的响应，再返回了「食品」的响应。\n\n","routePath":"/tmp/_2024-07-31-race-conditions/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":126,"title":"一个小程序组件埋点的优雅思路","content":"#\n\n\n\n\n\n\n\n","routePath":"/tmp/_2024-09-21-miniprogram-event-tracking/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":127,"title":"小程序 Webview 转 Skyline 过程总结","content":"#\n\n\n一、前置条件#\n\napp.json 中添加：\n\n\n\n\n二、挑选合适的页面#\n\n2、挑选页面，根据 skyline 支持的组件，挑选合适的页面。\n\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/compo\nnent.html\n\n\n三、改页面的 JSON#\n\n3、选中页面后，改页面的 json\n\n\n\n * navigationStyle 改为 custom，因为 skyline 只支持自定义导航栏\n * componentFramework 和 renderer 是官方文档要求添加的\n * disableScroll 设置为 true，因为 skyline 禁止页面滚动，只能通过 scroll-view 包裹住元素后，由\n   scroll-view 进行滚动\n\nhttps://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/migra\ntion/#%E5%BC%80%E5%A7%8B%E8%BF%81%E7%A7%BB\n\n\n四、改造页面滚动#\n\n函数                  改造方法\nonReachBottom       bindscrolltolower\nonPullDownRefresh   bindrefresherrefresh\nwx.pageScrollTo     ScrollViewContext.scrollTo\n\n参考：\n\n * https://developers.weixin.qq.com/miniprogram/dev/component/scroll-view.html\n * https://developers.weixin.qq.com/miniprogram/dev/api/ui/scroll/ScrollViewCont\n   ext.scrollTo.html","routePath":"/tmp/_2024-11-01-webview-to-skyline/","lang":"","toc":[{"text":"一、前置条件","id":"一前置条件","depth":2,"charIndex":3},{"text":"二、挑选合适的页面","id":"二挑选合适的页面","depth":2,"charIndex":30},{"text":"三、改页面的 JSON","id":"三改页面的-json","depth":2,"charIndex":169},{"text":"四、改造页面滚动","id":"四改造页面滚动","depth":2,"charIndex":515}],"domain":"","frontmatter":{},"version":""},{"id":128,"title":"预计更新博客","content":"#\n\n * H5、小程序词云卡片如何实现？\n\n\n\n * H5、小程序 Tab 进度条如何实现？\n\n\n\n * H5、小程序轮播列表缓存数据的方案如何设计？\n * H5 的 JS、CSS 等资源如何爬取？\n * H5 的 JS、CSS 等资源加载失败后如何重试？—— CDN 容灾如何做？\n * H5 Vite 如何兼容低版本浏览器？—— 只用 vite-legacy 就可以了吗？\n * H5 如何与 Android 和 iOS 进行通信？\n * H5 HTML 内联 script 如何提取处理？","routePath":"/tmp/_plan/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]