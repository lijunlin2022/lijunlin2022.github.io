"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["5465"],{30654:function(r,e,n){n.r(e),n.d(e,{default:function(){return l}});var s=n(85893),i=n(50065);function a(r){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",pre:"pre"},(0,i.ah)(),r.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"读取目录",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#读取目录",children:"#"}),"读取目录"]}),"\n",(0,s.jsx)(e.p,{children:"现在的 Node.js 提供了三种读取目录的方法："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fsPromises.readdir(path[, options])"}),"，异步读取，返回值为 Promise 类型"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 示例代码\r\nconst { readdir } = require('fs/promises')\r\n\r\nconst getFiles = async () => {\r\n  try {\r\n    const files = await readdir(__dirname)\r\n    files.forEach(f => console.log(f))\r\n  } catch (e) {\r\n    console.error(e)\r\n  }\r\n}\r\n\r\ngetFiles()\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs.readdir(path[, options], callback)"}),"，异步读取，利用回调函数来处理成功和失败的情况"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const { readdir } = require('fs')\r\n\r\nconst getFiles = () => {\r\n  readdir(__dirname, (err, files) => {\r\n    if (err) {\r\n      console.log(err)\r\n    } else {\r\n      files.forEach(f => console.log(f))\r\n    }\r\n  })\r\n}\r\n\r\ngetFiles()\n"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.code,{children:"fs.readdirSync(path[, options])"}),"，同步读取"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const { readdirSync } = require('fs')\r\n\r\nconst getFiles = () => {\r\n  const files = readdirSync(__dirname)\r\n  files.forEach(f => console.log(f))\r\n}\r\n\r\ngetFiles()\n"})}),"\n",(0,s.jsx)(e.p,{children:"同步读取目录的巧妙用法"}),"\n",(0,s.jsx)(e.p,{children:"通常来说，我们在读取文件时，常常使用异步的方法，但是有时使用同步方法有妙用，比如 Koa 注册路由的时候："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"routes\r\n├─index.js\r\n├─users.js\r\n├─topics.js\r\n├─questions.js\r\n└─answers.js\n"})}),"\n",(0,s.jsx)(e.p,{children:"我们需要为每一个文件注册一个路由，但一行一行地写很麻烦，因此我们可以使用同步读取文件的方法："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const { readdirSync } = require('fs')\r\n\r\nmodule.exports = (app) => {\r\n  readdirSync(__dirname).forEach(file => {\r\n    if (file === 'index.js') {\r\n      return\r\n    }\r\n    const router = require(`./${file}`)\r\n    app.use(router.routes()).use(router.allowedMethods())\r\n  })\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"类似代码有，gulp 批量注册任务："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const gulp = require('gulp');\r\nconst path = require('path');\r\nconst { readdirSync } = require('fs');\r\n\r\nconst gulpDirPath = path.join(__dirname, './gulp/')\r\nconst customTasks = readdirSync(gulpDirPath);\r\n\r\nconst load = (taskfile) => {\r\n  const extname = path.extname(taskfile);\r\n  if (extname === '.js') { // 过滤其它文件\r\n    const taskFilePath = path.join(gulpDirPath, taskfile);\r\n    const taskFunc = require(taskFilePath);\r\n    taskFunc(gulp);\r\n  }\r\n}\r\n\r\ncustomTasks.forEach(file => load(file));\n"})})]})}function c(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),r.components);return e?(0,s.jsx)(e,Object.assign({},r,{children:(0,s.jsx)(a,r)})):a(r)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["zh%2Fdocs%2Fnodejs%2F02-readdir.md"]={toc:[],title:"读取目录",frontmatter:{}}}}]);