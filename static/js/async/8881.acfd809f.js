"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["8881"],{96578:function(e,n,r){r.r(n),r.d(n,{default:()=>l});var s=r("85893"),a=r("50065"),t=r("95895");let c=r.p+"static/image/snake5.54e40c9a.jpg";function i(e){let n=Object.assign({p:"p",h2:"h2",a:"a",img:"img",code:"code",blockquote:"blockquote",ul:"ul",li:"li",pre:"pre"},(0,a.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"本文介绍了游戏中如何使用双线程，完成获取键盘输入控制贪吃蛇移动，为此我们需要学习两个函数，CreateThread 和 GetAsyncKeyState"}),"\n",(0,s.jsxs)(n.h2,{id:"双线程的作用",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#双线程的作用",children:"#"}),"双线程的作用"]}),"\n",(0,s.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:c})}),"\n",(0,s.jsxs)(n.p,{children:["在我们的设计中，开了两个线程，第一个线程用于获取键盘输入，它将影响一个全局变量 ",(0,s.jsx)(n.code,{children:"globalMovementDirection"})," ，当需要移动蛇的时候，第二个线程将读取 ",(0,s.jsx)(n.code,{children:"globalMovementDirection"})," 作为控制信号"]}),"\n",(0,s.jsxs)(n.h2,{id:"createthread-的用法",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#createthread-的用法",children:"#"}),"CreateThread 的用法"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"语法"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",meta:"",children:"HANDLE CreateThread(\r\n  LPSECURITY_ATTRIBUTES lpsa,\r\n  DWORD cbStack,\r\n  LPTHREAD_START_ROUTINE lpStartAddr,\r\n  LPVOID lpvThreadParam,\r\n  DWORD fdwCreate,\r\n  LPDWORD lpIDThread\r\n);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"参数"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"lpsa，忽略，必须为 NULL"}),"\n",(0,s.jsx)(n.li,{children:"cbStack，忽略"}),"\n",(0,s.jsx)(n.li,{children:"lpStartAddr，线程的起始地址"}),"\n",(0,s.jsx)(n.li,{children:"lpvThreadParam，指向传递给线程的单个 32 位参数值的长指针"}),"\n",(0,s.jsx)(n.li,{children:"fdwCreate，执行控制线程创建的标志"}),"\n",(0,s.jsx)(n.li,{children:"lpIDThread，指向接收线程标识符的 32 位变量的长指针，如果此参数为 NULL，则不反悔线程标识符"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["——",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/previous-versions/bb202727(v=msdn.10)?redirectedfrom=MSDN",target:"_blank",rel:"noopener noreferrer",children:"CreateThread | Microsoft Docs"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实际创建线程的代码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实际创建线程的代码",children:"#"}),"实际创建线程的代码"]}),"\n",(0,s.jsxs)(n.p,{children:["在 ",(0,s.jsx)(n.code,{children:"main"})," 函数中，我们有："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",meta:"",children:"void main() {\r\n	__asm {\r\n		// 第一个线程\r\n		// 获取键盘输入\r\n		// 操控蛇的移动\r\n		push 0\r\n		push 0\r\n		push 0\r\n		lea eax, dword ptr ds : [judgeMovementDirection]\r\n		push eax\r\n		push 0\r\n		push 0\r\n		call CreateThread\r\n\r\n		// 第二个线程\r\n		// 打印游戏画面\r\n		call enterGame\r\n	}\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["可以知道，第一个线程中就只有函数 ",(0,s.jsx)(n.code,{children:"judgeMovementDirection"})," 在运行，而 ",(0,s.jsx)(n.code,{children:"judgeMovementDirection"})," 就是的功能就是修改 ",(0,s.jsx)(n.code,{children:"globalMovementDirection"})," 变量"]}),"\n",(0,s.jsxs)(n.h2,{id:"getasynckeystate",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#getasynckeystate",children:"#"}),"GetAsyncKeyState"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"GetAsyncKeyState 是一个用来判断函数调用时指定虚拟键的状态，确定用户当前是否按下了键盘的一个键的函数。如果按下，则返回值最高位为 1"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"语法"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",meta:"",children:"SHORT GetAsyncKeyState(\r\n  int vKey\r\n);\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"参数"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"vKey"})}),"\n",(0,s.jsxs)(n.p,{children:["有关详细信息，请参阅",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes",target:"_blank",rel:"noopener noreferrer",children:"虚拟键代码"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"对 GetAsyncKeyState 调用之后，如果按键已经被按下，则返回值位 15 设为 1；如抬起，则为 0"}),"\n",(0,s.jsxs)(n.p,{children:["—— ",(0,s.jsx)(n.a,{href:"https://baike.baidu.com/item/GetAsyncKeyState/918387?fr=aladdin",target:"_blank",rel:"noopener noreferrer",children:"GetAsyncKeyState 百度百科"})]}),"\n",(0,s.jsxs)(n.p,{children:["—— ",(0,s.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-getasynckeystate",target:"_blank",rel:"noopener noreferrer",children:"GetAsyncKeyState | Microsoft Docs"})]}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"实际判断状态的代码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实际判断状态的代码",children:"#"}),"实际判断状态的代码"]}),"\n",(0,s.jsxs)(n.p,{children:["需要注意的时，贪吃蛇不能够直接掉头，所以在给 ",(0,s.jsx)(n.code,{children:"globalMovementDirection"})," 赋值时，必须首先判断此时蛇的移动方向"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果蛇向下移动，则向上的按键不生效"}),"\n",(0,s.jsx)(n.li,{children:"如果蛇向上移动，则向下的按键不生效"}),"\n",(0,s.jsx)(n.li,{children:"如果蛇向左移动，则向右的按键不生效"}),"\n",(0,s.jsx)(n.li,{children:"如果蛇向右移动，则向左的按键不生效"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-c",meta:"",children:"void  judgeMovementDirection() {\r\n	while (true) {\r\n		__asm {\r\n	back_while:\r\n		// 获取 w 键\r\n		push 87\r\n		call GetAsyncKeyState\r\n		// 与操作，获取第 15 位的值\r\n		and ax, 0ff00h\r\n		// 如果为 0 表示没有被按下\r\n		cmp ax, 0\r\n		jne w_press\r\n\r\n		// 获取 s 键\r\n		push 83\r\n		call GetAsyncKeyState\r\n		and ax, 0ff00h\r\n		cmp ax, 0\r\n		jne s_press\r\n\r\n		// 获取 a 键\r\n		push 65\r\n		call GetAsyncKeyState\r\n		and ax, 0ff00h\r\n		cmp ax, 0\r\n		jne a_press\r\n\r\n		// 获取 d 键\r\n		push 68\r\n		call GetAsyncKeyState\r\n		and ax, 0ff00h\r\n		cmp ax, 0\r\n		jne d_press\r\n		jmp back_while\r\n\r\n		// 如果 w 键被按下\r\n	w_press :\r\n		mov eax, dword ptr ds : [globalMovementDirection]\r\n		// 如果当前移动方向向下, 则忽略此次事件\r\n		cmp eax, 2\r\n		je w_back\r\n		mov dword ptr ds : [globalMovementDirection] , 1\r\n		w_back :\r\n		jmp back_while\r\n\r\n		// 如果 s 键被按下\r\n	s_press :\r\n		mov eax, dword ptr ds : [globalMovementDirection]\r\n		// 如果当前移动方向向上, 则忽略此次事件\r\n		cmp eax, 1\r\n		je s_back\r\n		mov dword ptr ds : [globalMovementDirection] , 2\r\n		s_back :\r\n		jmp back_while\r\n\r\n		// 如果 a 键被按下\r\n	a_press :\r\n		mov eax, dword ptr ds : [globalMovementDirection]\r\n		// 如果当前移动方向向右, 则忽略此次事件\r\n		cmp eax, 4\r\n		je a_back\r\n		mov dword ptr ds : [globalMovementDirection] , 3\r\n		a_back :\r\n		jmp back_while\r\n\r\n		// 如果 d 键被按下\r\n	d_press :\r\n		mov eax, dword ptr ds : [globalMovementDirection]\r\n		// 如果当前移动方向向左, 则忽略此次事件\r\n		cmp eax, 3\r\n		je d_back\r\n		mov dword ptr ds : [globalMovementDirection] , 4\r\n		d_back :\r\n		jmp back_while\r\n		}\r\n	}\r\n}\n"})})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,a.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["docs%2Fbit-life%2Fsnake%2Fdouble-thread.md"]={toc:[{id:"双线程的作用",text:"双线程的作用",depth:2},{id:"createthread-的用法",text:"CreateThread 的用法",depth:2},{id:"实际创建线程的代码",text:"实际创建线程的代码",depth:2},{id:"getasynckeystate",text:"GetAsyncKeyState",depth:2},{id:"实际判断状态的代码",text:"实际判断状态的代码",depth:2}],title:"",frontmatter:{}}},95895:function(e,n,r){r.d(n,{Z:function(){return d}});var s=r(85893),a=r(67294),t=r(45687);r(6175);let c={"zh-CN":e=>`预计阅读时间: ${e.minutes>=1?`${Math.ceil(e.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function i(e,n,r){let s=Object.keys(c).includes(n)?n:r;return c[s](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,r=(0,t.Vi)().page.readingTimeData,c=(0,t.Jr)(),d=(0,t.e7)(),[l,h]=(0,a.useState)(i(r,c,n));return(0,a.useEffect)(()=>{h(i(r,c,n))},[c,r]),(0,s.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:l})}}}]);