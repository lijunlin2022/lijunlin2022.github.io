"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["2301"],{7948:function(n,e,t){t.r(e),t.d(e,{default:function(){return a}});var r=t(5893),o=t(65);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",code:"code",pre:"pre",h2:"h2"},(0,o.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"requestanimationframe-实现平滑滚动",children:["requestAnimationFrame 实现平滑滚动",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#requestanimationframe-实现平滑滚动",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"大家好，我俊霖。"}),"\n",(0,r.jsxs)(e.p,{children:["最近接到一个修复通知，iOS 15.4 ~ 17，使用 CSS ",(0,r.jsx)(e.code,{children:"scroll-behavior: smooth"})," 或 JavaScript 的  ",(0,r.jsx)(e.code,{children:"behavior: 'smooth'"})," 可能导致 iOS App Crash。"]}),"\n",(0,r.jsxs)(e.p,{children:["我维护的 H5 有个锚定功能，是使用 ",(0,r.jsx)(e.code,{children:"element.scrollIntoView({ behavior: 'smooth' })"})," 来实现锚定并且带上动画的。现在得换种方法实现锚定。"]}),"\n",(0,r.jsxs)(e.p,{children:["参考修复通知，我决定使用 ",(0,r.jsx)(e.code,{children:"requestAnimationFrame"})," 来实现动画。"]}),"\n",(0,r.jsxs)(e.p,{children:["首先，我准备改用 ",(0,r.jsx)(e.code,{children:"window.scrollTo()"})," 替换掉 ",(0,r.jsx)(e.code,{children:"scrollIntoView"})," 实现锚定。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const targetPosition = element.offsetTop;\r\nwindow.scrollTo(0, targetPosition);\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"requestanimationframe",children:["requestAnimationFrame",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#requestanimationframe",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"下面这段代码的作用是：将页面平滑滚动到某个位置。它首先会获取当前滚动条的位置，然后计算目标位置和当前位置的距离，之后将这个距离分为若干个部分，每隔一段时间就滚动一部分，直到滚动到目标位置。"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const smoothScrollTo = (targetPosition, part) => {\r\n  const startPosition =\r\n    document.documentElement.scrollTop || document.body.scrollTop;\r\n  const distance = targetPosition - startPosition;\r\n  const step = Math.floor(distance / part);\r\n  let currentPosition = startPosition;\r\n\r\n  const t = setInterval(() => {\r\n    if (Math.abs(targetPosition - currentPosition) > Math.abs(step)) {\r\n      currentPosition += step;\r\n      window.scrollTo(0, currentPosition);\r\n    } else {\r\n      clearInterval(t);\r\n      window.scrollTo(0, targetPosition);\r\n    }\r\n  }, 60);\r\n}\n"})}),"\n",(0,r.jsxs)(e.p,{children:["我对 ",(0,r.jsx)(e.code,{children:"requestAnimationFrame"})," 的理解，大概就是把它当做了一个 ",(0,r.jsx)(e.code,{children:"setInterval"})," 的替代品。"]}),"\n",(0,r.jsxs)(e.p,{children:["首先我用 ",(0,r.jsx)(e.code,{children:"setInterval"})," 实现了一个锚定的滚动动画："]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-js",children:"const smoothScrollTo = (targetPosition, part) => {\r\n  const startPosition =\r\n    document.documentElement.scrollTop || document.body.scrollTop;\r\n  const distance = targetPosition - startPosition;\r\n  const step = Math.floor(distance / part);\r\n  let currentPosition = startPosition;\r\n  let animationFrameId = null;\r\n\r\n  const animation = () => {\r\n    if (Math.abs(targetPosition - currentPosition) > Math.abs(step)) {\r\n      currentPosition += step;\r\n      window.scrollTo(0, currentPosition);\r\n      animationFrameId = window.requestAnimationFrame(animation);\r\n    } else {\r\n      window.scrollTo(0, targetPosition);\r\n      window.cancelAnimationFrame(animationFrameId);\r\n    }\r\n  };\r\n\r\n  animation();\r\n}\n"})})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(s,{...n})}):s(n)}let a=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["tmp%2F_2023-11-08-smoothly-scroll%2Findex.md"]={toc:[{text:"requestAnimationFrame",id:"requestanimationframe",depth:2}],title:"requestAnimationFrame 实现平滑滚动",frontmatter:{tags:["requestAnimationFrame"]}}}}]);