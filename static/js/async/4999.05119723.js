"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["4999"],{52647:function(n,e,r){r.r(e),r.d(e,{default:function(){return i}});var s=r(85893),d=r(50065);function l(n){let e=Object.assign({p:"p",h2:"h2",a:"a",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong"},(0,d.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.p,{children:"本节以一个 Hello World 介绍了汇编嵌套 C 程序的基本结构，然后介绍了 printf 和 scanf 在汇编中的基本用法，本节之后，应该能完成显示主菜单的部分代码"}),"\n",(0,s.jsxs)(e.h2,{id:"开发环境",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#开发环境",children:"#"}),"开发环境"]}),"\n",(0,s.jsx)(e.p,{children:"Visual Studio 2019 创建新项目 → C++ 空项目 → 源文件右键 → 添加新建项 → Test.cpp"}),"\n",(0,s.jsxs)(e.h2,{id:"hello-world",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#hello-world",children:"#"}),"Hello World"]}),"\n",(0,s.jsx)(e.p,{children:"我们先来看一个简单的 Hello World 程序"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:'#include <stdio.h>\r\nvoid main() {\r\n	const char *szHello = "Hello World";\r\n	__asm {\r\n		mov eax, dword ptr ds:[szHello]\r\n		push eax\r\n		call printf\r\n		add esp, 4\r\n	}\r\n}\n'})}),"\n",(0,s.jsx)(e.p,{children:"下面逐行逐行地解释程序"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"为什么要包含头文件 studio ？"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",meta:"",children:"#include <stdio.h>\n"})}),"\n",(0,s.jsx)(e.p,{children:"C 嵌套汇编时，为了能在控制台打印出结果，我们需要调用标准库的 studio 的 printf 函数"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"szHello 前的 sz 是什么意思？"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",meta:"",children:'const char *szHello = "HelloWorld";\n'})}),"\n",(0,s.jsx)(e.p,{children:"此处使用了匈牙利命名法，sz 是 String Terminated with a Zero 的缩写，意为 以 '\\0' 结尾字符串"}),"\n",(0,s.jsxs)(e.p,{children:["为什么以 ",(0,s.jsx)(e.code,{children:"'\\0'"})," 结尾呢？"]}),"\n",(0,s.jsx)(e.p,{children:"C 语言没有专用的字符串变量，要用一个字符数组来存放。为了确定字符串的结束位置，C 语言创建字符串时总是在末尾添加 '\\0' 字符"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"__asm {}"})," 是什么意思？"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-assembly",meta:"",children:"__asm {\r\n\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"代表包含在花括号内部的代码均为汇编代码"}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"dword ptr"}),"\n",(0,s.jsx)(e.p,{children:"如果没有 dword ptr，可以看出汇编代码就是直接寻址的代码"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"mov eax, ds:[szHello]\n"})}),"\n",(0,s.jsx)(e.p,{children:"事实上，由于段地址总是默认存放在 ds 寄存器中，所以其实可以直接写为"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"mov eax, [szHello]\n"})}),"\n",(0,s.jsx)(e.p,{children:"如果你尝试将 Test.cpp 中的内容改为上述两种写法，其实也不会报错"}),"\n",(0,s.jsxs)(e.p,{children:["dword 是意思是 double word，即指令长度是",(0,s.jsx)(e.strong,{children:"双字"}),"(32 bit)，ptr 的意思是 pointer，即指针"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-assembly",meta:"",children:"; 意思是 取出 ds:[szHello] 地址的双字型数据，赋值给 eax\r\nmov eax, dword ptr ds:[szHello]\n"})}),"\n",(0,s.jsx)(e.p,{children:"加上 dword ptr 有助于让 eax 理解传递给它的参数是双字的"}),"\n",(0,s.jsxs)(e.p,{children:["之后如果我们要传递其他长度，比如",(0,s.jsx)(e.strong,{children:"单字节"}),"(8 bit)，可以这样写"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-assembly",meta:"",children:"mov al, byte ptr ds:[...]\n"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsx)(e.p,{children:"调用函数以及保持堆栈平衡"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-assembly",meta:"",children:"push eax\r\ncall printf\r\nadd esp, 4\n"})}),"\n",(0,s.jsx)(e.p,{children:"要调用一个子程序，且给这个子程序传递参数，有三种方法，我们这里使用的是堆栈传递参数（具体可以看《汇编技术与接口（李元章）》第 5 章）"}),"\n",(0,s.jsx)(e.p,{children:"注意点："}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"传递子程序参数，我们需要先将参数压栈"}),"\n",(0,s.jsx)(e.li,{children:"C 语言函数，传递参数时是从右往左压栈"}),"\n",(0,s.jsx)(e.li,{children:"调用函数之后，需要保证堆栈平衡"}),"\n",(0,s.jsx)(e.li,{children:"子程序的返回结果默认保存在寄存器 EAX 中"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"这里我们首先将保存在 eax 中的参数压栈，然后调用 printf 函数，之后再恢复堆栈平衡"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.h2,{id:"lea结合-scanf",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#lea结合-scanf",children:"#"}),"lea，结合 scanf"]}),"\n",(0,s.jsx)(e.p,{children:"之前我们已经学会如何使用 printf 函数，解析来我们来学习如何使用 scanf 函数"}),"\n",(0,s.jsx)(e.p,{children:"常见的 scanf 用法有"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",meta:"",children:'int age = 0;\r\nscanf("%d", &age);\r\n\r\nchar ch = 0;	// 初始化为 ascii 码表中的 0，即 NULL\r\nscanf("%c", &ch);\r\n\r\nchar name[21];\r\nmemset(name, 0, sizeof(name));\r\nscanf("%s", name);\n'})}),"\n",(0,s.jsxs)(e.p,{children:["其中，",(0,s.jsx)(e.code,{children:"&age"})," 和 ",(0,s.jsx)(e.code,{children:"&ch"})," 表示取地址，而 ",(0,s.jsx)(e.code,{children:"name"})," 是数组名字，直接代码地址"]}),"\n",(0,s.jsxs)(e.p,{children:["我们在写汇编代码时，也需要取地址，这时候就需要用到命令 ",(0,s.jsx)(e.code,{children:"lea"})," ，",(0,s.jsx)(e.code,{children:"lea"})," 就表示取内存的地址"]}),"\n",(0,s.jsx)(e.p,{children:"例如："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"lea eax, dword ptr ds:[szOutput]\n"})}),"\n",(0,s.jsxs)(e.p,{children:["就代表取 ",(0,s.jsx)(e.code,{children:"ds:[szOutPut]"})," 的地址，放到寄存器 eax 中"]}),"\n",(0,s.jsxs)(e.h2,{id:"完成部分显示主菜单的代码",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#完成部分显示主菜单的代码",children:"#"}),"完成部分显示主菜单的代码"]}),"\n",(0,s.jsxs)(e.p,{children:["现在我们可以完成部分显示主菜单的代码了，下面代码是 ",(0,s.jsx)(e.code,{children:"snake.cpp"})," 的 ",(0,s.jsx)(e.code,{children:"showMainMenu()"})," 函数，它翻译的纯汇编具体可以看 ",(0,s.jsx)(e.code,{children:"snake.asm"})," 的 ",(0,s.jsx)(e.code,{children:"showMainMenu()"})," 函数"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-c",meta:"",children:'void showMainMenu() {\r\n	const char* dividingLine = "-------------------------------------------------------------------\\n";\r\n	const char* authorInfo = "作者: 小霖家的混江龙\\n";\r\n	const char* operationGuide = "按 1 开始游戏\\n按 2 结束游戏\\n按 W 向上移动\\n按 S 向下移动\\n按 A 向左移动\\n按 D 向右移动\\n";\r\n	__asm {\r\n		// 打印分割字符\r\n		mov eax, dword ptr ds : [dividingLine]\r\n		push eax\r\n		call printf\r\n		add esp, 4\r\n\r\n		// 打印作者信息\r\n		mov eax, dword ptr ds : [authorInfo]\r\n		push eax\r\n		call printf\r\n		add esp, 4\r\n\r\n		// 打印提示信息\r\n		mov eax, dword ptr ds : [operationGuide]\r\n		push eax\r\n		call printf\r\n		add esp, 4\r\n\r\n		// 打印分割字符\r\n		mov eax, dword ptr ds : [dividingLine]\r\n		push eax\r\n		call printf\r\n		add esp, 4\r\n	}\r\n}\n'})}),"\n",(0,s.jsxs)(e.h2,{id:"碎碎念",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#碎碎念",children:"#"}),"碎碎念"]}),"\n",(0,s.jsx)(e.p,{children:"博主不是很喜欢匈牙利命名法，因此在 snake.cpp 和 snake.asm 中几乎都未使用匈牙利命名法"}),"\n",(0,s.jsx)(e.p,{children:"我在 (3) 中给出的 C 语言代码，将 int，char，char 型数组都进行了初始化，事实上你不初始化也不会报错"}),"\n",(0,s.jsx)(e.p,{children:"我这么做主要是提醒自己，初始化很重要"}),"\n",(0,s.jsx)(e.p,{children:"为什么初始化很重要呢？int，char 和数组即便不初始化，编译器也能够判断出它们应该占用多大的内存空间，但是如果是一个指针，没有初始化，编译器便完全无法确定指针应该分配多少内存，程序便会报错"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,d.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(l,n)})):l(n)}let i=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["zh%2Fdocs%2Fbit-life%2Fsnake%2Fprintf-and-scanf.md"]={toc:[{id:"开发环境",text:"开发环境",depth:2},{id:"hello-world",text:"Hello World",depth:2},{id:"lea结合-scanf",text:"lea，结合 scanf",depth:2},{id:"完成部分显示主菜单的代码",text:"完成部分显示主菜单的代码",depth:2},{id:"碎碎念",text:"碎碎念",depth:2}],title:"",frontmatter:{}}}}]);