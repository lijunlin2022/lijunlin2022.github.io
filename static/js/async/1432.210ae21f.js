"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["1432"],{55329:function(n,r,e){e.r(r),e.d(r,{default:function(){return c}});var s=e(85893),a=e(50065);function t(n){let r=Object.assign({h1:"h1",a:"a",p:"p",pre:"pre",code:"code",h2:"h2",ul:"ul",li:"li",h3:"h3",ol:"ol",strong:"strong"},(0,a.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"结构体",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#结构体",children:"#"}),"结构体"]}),"\n",(0,s.jsx)(r.p,{children:"结构体是由一系列数据构成的数据集合。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Book struct {\r\n  title  string\r\n  author string\r\n}\r\n\r\nfunc main() {\r\n  book1 := Book{"骆驼祥子", "老舍"}\r\n  book2 := Book{title: "黄金时代", author: "王小波"}\r\n  fmt.Println(book1)\r\n  fmt.Println(book2)\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"结构体作为参数传递给函数，go 语言中的结构体是值类型，因此在将结构体传递给函数时，实际上是传递结构体的副本。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'func changeBook(b Book) Book {\r\n  b.title = "狂人日记"\r\n  b.author = "鲁迅"\r\n  return b\r\n}\r\n\r\nfunc main() {\r\n  book := Book{"骆驼祥子", "老舍"}\r\n\r\n  newBook := changeBook(book)\r\n\r\n  fmt.Println(book)    // {骆驼祥子 老舍}\r\n  fmt.Println(newBook) // {狂人日记 鲁迅}\r\n}\n'})}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'func changeBookWithPtr(ptr *Book) Book {\r\n  ptr.title = "狂人日记"\r\n  ptr.author = "鲁迅"\r\n  return *ptr\r\n}\r\n\r\nfunc main() {\r\n  book := Book{"骆驼祥子", "老舍"}\r\n  newBook := changeBookWithPtr(&book)\r\n  fmt.Println(book)    // {狂人日记 鲁迅}\r\n  fmt.Println(newBook) // {狂人日记 鲁迅}\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"方法和接收者",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#方法和接收者",children:"#"}),"方法和接收者"]}),"\n",(0,s.jsx)(r.p,{children:"go 语言中的方法 (Method) 是一种作用于特定变量类型的函数。这种特定类型变量叫做接收者（Receiver），接收者的概念就类似于其他语言中的 this 或者 self。"}),"\n",(0,s.jsx)(r.p,{children:"方法定义格式如下："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:"func (vname vtype) func_name(parameter_list) [return_types] {\r\n  func_body\r\n}\n"})}),"\n",(0,s.jsxs)(r.p,{children:["方法的定义方式和函数的定义方法，只是将 ",(0,s.jsx)(r.code,{children:"(vname vtype)"})," 和 ",(0,s.jsx)(r.code,{children:"func_name(parameter_list)"})," 做一个调换。其中:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"vname 是接收者变量，他在命名时官方建议使用 vtype 的第一个小写字母，而不是 self 和 this 之类的变量名。例如，Person 类型的接收者变量应该命名为 p，Connector 类型的接收者变量应该命名为 c 等。"}),"\n",(0,s.jsx)(r.li,{children:"vtpe 是接收者类型，可以是指针类型和非指针类型。"}),"\n",(0,s.jsx)(r.li,{children:"func_name, paramter_list 和 return_types 具体格式与函数相同。"}),"\n"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc (p Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  man := Person{"小明", 20}\r\n  man.Intro()\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"其余的初始化方法",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#其余的初始化方法",children:"#"}),"其余的初始化方法"]}),"\n",(0,s.jsxs)(r.h3,{id:"new-操作符",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#new-操作符",children:"#"}),"new 操作符"]}),"\n",(0,s.jsxs)(r.p,{children:["可以使用 ",(0,s.jsx)(r.code,{children:"new"})," 来初始化结构体，此时结构体内部属性的值默认为该属性的零值。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc (p Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  man := new(Person)\r\n  man.Intro() // 我的名字是, 今年0岁\r\n  man.name = "小明"\r\n  man.age = 20\r\n  man.Intro() // 我的名字是小明, 今年20岁\r\n}\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"-取结构体的地址实例化",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#-取结构体的地址实例化",children:"#"}),"& 取结构体的地址实例化"]}),"\n",(0,s.jsx)(r.p,{children:"使用 & 对结构体取地址，相当于对该结构体类型进行了一次 new 实例化操作。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc (p Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  man := &Person{"小明", 20}\r\n  man.Intro() // 我的名字是小明, 今年20岁\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"不同初始化方法的区别",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#不同初始化方法的区别",children:"#"}),"不同初始化方法的区别"]}),"\n",(0,s.jsxs)(r.p,{children:["我们看到，",(0,s.jsx)(r.code,{children:"Person{}"}),"、",(0,s.jsx)(r.code,{children:"new(Person)"})," 和 ",(0,s.jsx)(r.code,{children:"&Person{}"})," 都可以初始化结构体，那么它们有什么区别呢？"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"man = Person{}"})," 这种方式，man 是一个变量，它是 Person 的实例。当你修改 man 的字段时，你是在修改实例的字段，和 Person 本身无关。"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"man = new(Person)"})," 和 ",(0,s.jsx)(r.code,{children:"&Person{}"})," 这种方式，man 是一个指针。它是 Person 的指针。当你修改 man 的字段时，所有指向 Person 的指针的字段都会改变。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc (p Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  p1 := Person{"小明", 20}\r\n  p2 := &Person{"小刚", 20}\r\n  p3 := new(Person)\r\n  p3.name = "小华"\r\n  p3.age = 20\r\n\r\n  man1, man2 := p1, p1\r\n  man1.age = 30\r\n  man1.Intro() // 我的名字是小明, 今年30岁\r\n  man2.Intro() // 我的名字是小明, 今年20岁\r\n\r\n  man3, man4 := p2, p2\r\n  man3.age = 30\r\n  man3.Intro() // 我的名字是小刚, 今年30岁\r\n  man4.Intro() // 我的名字是小刚, 今年30岁\r\n\r\n  man5, man6 := p3, p3\r\n  man5.age = 40\r\n  man5.Intro() // 我的名字是小华, 今年40岁\r\n  man6.Intro() // 我的名字是小华, 今年40岁\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"方法参数用变量还是指针",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#方法参数用变量还是指针",children:"#"}),"方法参数用变量还是指针？"]}),"\n",(0,s.jsx)(r.p,{children:"在 go 语言中，如果一个方法不会修改结构体内部的值，那么从结果上看，无论参数是变量还是指针，都不会有影响。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc (p Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc (p *Person) IntroWithPtr() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  p1 := Person{"小明", 20}\r\n  p1.Intro()        // 我的名字是小明, 今年20岁\r\n  p1.IntroWithPtr() // 我的名字是小明, 今年20岁\r\n}\n'})}),"\n",(0,s.jsx)(r.p,{children:"但是从性能、内存分配和可读性考虑，一般我们还是会注意区分参数是变量还是指针。一般以下情况我们会考虑使用指针："}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsx)(r.li,{children:"需要修改接收器中的值。"}),"\n",(0,s.jsx)(r.li,{children:"结构体比较大的时候。如果结构体非常大，那么将其作为值类型传递会消耗更多的内存和 CPU，因为 go 需要复制整个结构体。在这种情况下，使用指针类型可以提高性能，因为指针只需要存储一个内存地址。"}),"\n",(0,s.jsx)(r.li,{children:"希望保持一致性的时候。如果你的某些方法需要修改结构体的值（因此需要使用指针），那么为了保持一致性，你可能会希望所有的方法都使用指针，即使有些方法并不需要修改结构体的值"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"构造函数",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#构造函数",children:"#"}),"构造函数"]}),"\n",(0,s.jsx)(r.p,{children:"go 语言中没有原生的构造函数，我们可以自己写一个。这里考虑到性能，我们使用的是指针。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  name string\r\n  age  int\r\n}\r\n\r\nfunc newPerson(name string, age int) *Person {\r\n  return &Person{\r\n    name,\r\n    age,\r\n  }\r\n}\r\n\r\nfunc (p *Person) Intro() {\r\n  fmt.Printf("我的名字是%s, 今年%d岁\\n", p.name, p.age)\r\n}\r\n\r\nfunc main() {\r\n  p1 := newPerson("小明", 20)\r\n  p1.Intro() // 我的名字是小明, 今年20岁\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"私有变量公有变量私有方法和公有方法",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#私有变量公有变量私有方法和公有方法",children:"#"}),"私有变量、公有变量、私有方法和公有方法"]}),"\n",(0,s.jsx)(r.p,{children:"在 go 语言中，变量的公有或私有取决于其名称的首字母是否大写。"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"如果变量、函数、类型等名称首字母大写，那么它就是公有的，也就是说，它可以被其他包访问。"}),"\n",(0,s.jsx)(r.li,{children:"如果名称首字母小写，那么它就是私有的，只能在当前包内部访问，不能被其他包访问。"}),"\n"]}),"\n",(0,s.jsxs)(r.h2,{id:"匿名字段和内嵌结构体",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#匿名字段和内嵌结构体",children:"#"}),"匿名字段和内嵌结构体"]}),"\n",(0,s.jsxs)(r.h3,{id:"匿名字段",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#匿名字段",children:"#"}),"匿名字段"]}),"\n",(0,s.jsxs)(r.p,{children:["结构体内部可以包含一个或多个匿名字段，这些字段可以",(0,s.jsx)(r.strong,{children:"没有名字，只有类型"}),"，此时类型就是字段的名字。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Person struct {\r\n  string\r\n  int\r\n}\r\n\r\nfunc main() {\r\n  p := Person{"小霖家的混江龙", 23}\r\n  fmt.Printf("name: %s, age: %d\\n", p.string, p.int) // name: 小霖家的混江龙, age: 23\r\n}\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"内嵌结构体",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#内嵌结构体",children:"#"}),"内嵌结构体"]}),"\n",(0,s.jsxs)(r.p,{children:["匿名字段本身可以是一个结构体类型，也就是说",(0,s.jsx)(r.strong,{children:"结构体可以内嵌结构体"}),"。"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Education struct {\r\n  school string\r\n  major  string\r\n}\r\n\r\ntype Person struct {\r\n  string\r\n  int\r\n  *Education\r\n}\r\n\r\nfunc main() {\r\n  p := &Person{\r\n    "小霖家的混江龙",\r\n    23,\r\n    &Education{"北京理工大学", "计算机科学与技术"},\r\n  }\r\n  fmt.Printf(\r\n    "name: %s, age: %d, school: %s, major: %s\\n",\r\n    p.string,\r\n    p.int,\r\n    p.school,\r\n    p.major,\r\n  )\r\n}\n'})}),"\n",(0,s.jsxs)(r.h2,{id:"重载",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#重载",children:"#"}),"重载"]}),"\n",(0,s.jsx)(r.p,{children:"当内层结构体和外层结构体拥有相同的名字时，外层名字会覆盖内层名字（但是二者的内存空间均存在），这提供了一种重载字段、方法的方式。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Dog struct {\r\n  name string\r\n}\r\n\r\ntype Husky struct {\r\n  *Dog\r\n  name string\r\n}\r\n\r\nfunc main() {\r\n  h := &Husky{\r\n    Dog: &Dog{\r\n      name: "狗",\r\n    },\r\n    name: "哈士奇",\r\n  }\r\n  fmt.Println(h.name) // 哈士奇\r\n}\n'})}),"\n",(0,s.jsxs)(r.h3,{id:"自建-string-方法",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#自建-string-方法",children:"#"}),"自建 String() 方法"]}),"\n",(0,s.jsx)(r.p,{children:"如果类型定义了 String() 方法，它就会在 fmt.Println() 和 fmt.Printf() 时自动使用 String() 方法。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-go",meta:"",children:'type Dog struct {\r\n  name  string\r\n  color string\r\n}\r\n\r\nfunc (d *Dog) String() string {\r\n  return fmt.Sprintf("名字->%s; 颜色->%s", d.name, d.color)\r\n}\r\n\r\nfunc main() {\r\n  d := &Dog{name: "旺财", color: "白色"}\r\n  fmt.Printf("%v\\n", d) // 名字->旺财; 颜色->白色\r\n  fmt.Println(d)        // 名字->旺财; 颜色->白色\r\n}\n'})})]})}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,a.ah)(),n.components);return r?(0,s.jsx)(r,Object.assign({},n,{children:(0,s.jsx)(t,n)})):t(n)}let c=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["zh%2Fdocs%2Fgo%2F08-struct.md"]={toc:[{id:"方法和接收者",text:"方法和接收者",depth:2},{id:"其余的初始化方法",text:"其余的初始化方法",depth:2},{id:"new-操作符",text:"new 操作符",depth:3},{id:"-取结构体的地址实例化",text:"& 取结构体的地址实例化",depth:3},{id:"不同初始化方法的区别",text:"不同初始化方法的区别",depth:2},{id:"方法参数用变量还是指针",text:"方法参数用变量还是指针？",depth:2},{id:"构造函数",text:"构造函数",depth:2},{id:"私有变量公有变量私有方法和公有方法",text:"私有变量、公有变量、私有方法和公有方法",depth:2},{id:"匿名字段和内嵌结构体",text:"匿名字段和内嵌结构体",depth:2},{id:"匿名字段",text:"匿名字段",depth:3},{id:"内嵌结构体",text:"内嵌结构体",depth:3},{id:"重载",text:"重载",depth:2},{id:"自建-string-方法",text:"自建 String() 方法",depth:3}],title:"结构体",frontmatter:{}}}}]);