"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["6472"],{35087:function(n,e,c){c.r(e),c.d(e,{default:function(){return t}});var s=c(85893),o=c(50065);function r(n){let e=Object.assign({h1:"h1",a:"a",p:"p",sup:"sup",blockquote:"blockquote",h2:"h2",code:"code",ul:"ul",li:"li",pre:"pre",section:"section",ol:"ol"},(0,o.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"异步分包",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步分包",children:"#"}),"异步分包"]}),"\n",(0,s.jsxs)(e.p,{children:["截止 2022 年 3 月 3 日，小程序的体积限制如下：",(0,s.jsx)(e.sup,{children:(0,s.jsx)(e.a,{href:"#user-content-fn-1",id:"user-content-fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})})]}),"\n",(0,s.jsxs)(e.blockquote,{children:["\n",(0,s.jsx)(e.p,{children:"整个小程序所有分包大小不超过 20M\r\n单个分包/主包大小不能超过 2M"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"因此，作为小程序开发者，总有一天会面临小程序的体积问题。"}),"\n",(0,s.jsx)(e.p,{children:"开发者一般会将核心页面放在主包中，将非核心的页面放在分包中。但是随着业务的迭代，主包总会有超过 2M 的时候，这个时候就需要用到「分包异步化」了。"}),"\n",(0,s.jsxs)(e.p,{children:["微信官方文档将「分包异步化」分为：「跨分包自定义组件引用」 和 「跨分包 JS 代码引用」 ",(0,s.jsx)(e.sup,{children:(0,s.jsx)(e.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})}),"。根据我实际的开发经验，「跨分包自定义组件引用」更加常见实用，下面我将介绍简单介绍这种方法。"]}),"\n",(0,s.jsx)(e.p,{children:"为了行文方便，我后文将使用了「跨分包自定义组件引用」这种方式的组件，称为「异步组件」。"}),"\n",(0,s.jsxs)(e.h2,{id:"给异步组件单独建一个分包",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#给异步组件单独建一个分包",children:"#"}),"给「异步组件」单独建一个分包"]}),"\n",(0,s.jsxs)(e.p,{children:["我创建了一个分包 ",(0,s.jsx)(e.code,{children:"sub-async-components-package"}),"，之后所有的异步组件，都存放到这个分包中。"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"app.json"}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",meta:"",children:'{\r\n  "pages": [\r\n    "pages/index/index"\r\n  ],\r\n  "subPackages": [{\r\n    "root": "sub-async-components-package",\r\n    "pages": [\r\n      "pages/index"\r\n    ]\r\n  }]\r\n}\n'})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.code,{children:"sub-async-components-package"})," 的目录结构如下："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{meta:"",children:"src\r\n├─pages\r\n└─sub-async-components-package\r\n  └─async-components\r\n    └─component-a\r\n    └─component-b\r\n    └─component-c\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"在主包页面中引入异步组件",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#在主包页面中引入异步组件",children:"#"}),"在主包页面中引入异步组件"]}),"\n",(0,s.jsx)(e.p,{children:"完成第一步之后，我们可以在主包的页面中，以如下方式引入异步组件。异步组件的传参，和普通组件一致。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-json",meta:"",children:'{\r\n  "usingComponents": {\r\n    "async-component-a": "/sub-async-components-package/async-components/component-a/index",\r\n    "async-component-b": "/sub-async-components-package/async-components/component-b/index",\r\n    "async-component-c": "/sub-async-components-package/async-components/component-c/index",\r\n  },\r\n  "componentPlaceholder": {\r\n    "async-component-a": "view",\r\n    "async-component-b": "view",\r\n    "async-component-c": "view"\r\n  }\r\n}\n'})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-html",meta:"",children:"<async-component-a></async-component-a>\r\n<async-component-b></async-component-b>\r\n<async-component-c></async-component-c>\n"})}),"\n",(0,s.jsxs)(e.p,{children:["现在我们简单一下上述配置的意思。",(0,s.jsx)(e.code,{children:"componentPlaceholder"})," 顾名思义就是组件占位符的意思。在分包还没有加载完成之前，页面会用 ",(0,s.jsx)(e.code,{children:"view"})," 标签暂时替代 ",(0,s.jsx)(e.code,{children:"async-component-x"})," 标签，等到分包加载完成之后，再将 ",(0,s.jsx)(e.code,{children:"view"})," 标签占据的位置还给 ",(0,s.jsx)(e.code,{children:"async-component-x"}),"。"]}),"\n",(0,s.jsxs)(e.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsxs)(e.h2,{className:"sr-only",id:"footnote-label",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#footnote-label",children:"#"}),"Footnotes"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{id:"user-content-fn-1",children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages.html",target:"_blank",rel:"noopener noreferrer",children:"分包加载 | 微信开放文档"})," ",(0,s.jsx)(e.a,{href:"#user-content-fnref-1","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content",children:"↩"})]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html",target:"_blank",rel:"noopener noreferrer",children:"分包异步化 | 微信开放文档"})," ",(0,s.jsx)(e.a,{href:"#user-content-fnref-2","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content",children:"↩"})]}),"\n"]}),"\n"]}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(r,n)})):r(n)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["zh%2Fdocs%2Fminiprogram%2F01-async-subpackage.md"]={toc:[{id:"给异步组件单独建一个分包",text:"给「异步组件」单独建一个分包",depth:2},{id:"在主包页面中引入异步组件",text:"在主包页面中引入异步组件",depth:2}],title:"异步分包",frontmatter:{}}}}]);