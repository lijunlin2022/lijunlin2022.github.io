"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["2452"],{54558:function(e,n,r){r.r(n),r.d(n,{default:function(){return t}});var s=r(85893),l=r(50065),c=r(95895);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",strong:"strong",h2:"h2",ul:"ul",li:"li",h3:"h3",code:"code",pre:"pre",blockquote:"blockquote"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"垃圾回收",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#垃圾回收",children:"#"}),"垃圾回收"]}),"\n",(0,s.jsx)(c.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.p,{children:["JavaScript 通过自动内存管理实现内存分配和限制资源回收，它的基本思路是：确定哪个变量不会再使用，然后释放它的内存。整个过程是周期性的，即",(0,s.jsx)(n.strong,{children:"垃圾回收程序每隔一定时间就会自动运行"}),"。"]}),"\n",(0,s.jsxs)(n.h2,{id:"标记策略",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#标记策略",children:"#"}),"标记策略"]}),"\n",(0,s.jsx)(n.p,{children:"为了跟踪哪个变量不会再使用，浏览器发展历史上用到过两种主要的标记策略："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"标记清理"}),"\n",(0,s.jsx)(n.li,{children:"引用计数"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"标记清理",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#标记清理",children:"#"}),"标记清理"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"标记清理"}),"（mark-and-sweep）是 JavaScript 最常用的垃圾回收策略。"]}),"\n",(0,s.jsx)(n.p,{children:"当变量进入上下文，比如在函数内部声明一个变量时，整个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码还在运行，就有可能用到它们。"}),"\n",(0,s.jsx)(n.p,{children:"当变量离开山下问时，也会被加上离开的标记。"}),"\n",(0,s.jsxs)(n.p,{children:["垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会去除掉所有在上下文中的变量，以及被在上下文中的变量引用的变量，留下待删除的变量。随后垃圾回收程序做一次",(0,s.jsx)(n.strong,{children:"内存清理"}),"，销毁带标记的所有值并回收它们的内存。"]}),"\n",(0,s.jsxs)(n.h3,{id:"引用计数",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#引用计数",children:"#"}),"引用计数"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"引用计数"}),"（reference-counting）则相对不常用。"]}),"\n",(0,s.jsx)(n.p,{children:"它的思路是：对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"如果同一个值又被赋给另一个变量，那么引用数加 1"}),"\n",(0,s.jsx)(n.li,{children:"如果保存该值的引用的变量被其他值给覆盖了，那么引用数减 1"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地回收内存。"}),"\n",(0,s.jsx)(n.p,{children:"垃圾回收机制下次运行时会自动释放引用数为 0 的值的内存。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"引用计数的问题"})}),"\n",(0,s.jsxs)(n.p,{children:["引用计数可能出现",(0,s.jsx)(n.strong,{children:"循环引用"}),"的问题，如下所示："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function problem () {\r\n    let objA = new Object()\r\n    let objB = new Object()\r\n    \r\n    objA.someOtherObj = objB\r\n    objB.anotherObj = objA\r\n}\n"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["如果使用标记清理策略，函数结束后，",(0,s.jsx)(n.code,{children:"objA"})," 和 ",(0,s.jsx)(n.code,{children:"objB"})," 都会被回收"]}),"\n",(0,s.jsx)(n.li,{children:"使用引用计数，它们的引用数都是 2，函数结束后不会被回收"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"由于引用计数的缺陷，Netscape 4.0 放弃引用计数而采用标记清理。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"IE8 和 IE 以前的问题"})}),"\n",(0,s.jsx)(n.p,{children:"IE8 以前，DOM 和 BOM 都是 C++ 实现的组件对象模型，它们还是使用引用计数来实现垃圾清理的。为此，当出现 JavaScript 原生对象和 DOM 或者 BOM 循环引用时，就会出现问题，如下所示"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"let element = document.getElementById('some_element')\r\nlet myObj = new Object()\r\nmyObj.element = element\r\nelement.someObj = myObj\n"})}),"\n",(0,s.jsxs)(n.p,{children:["为此，我们需要讲变量设置为 ",(0,s.jsx)(n.code,{children:"null"})," 切断原生 JavaScript 对象和 DOM 元素之间的连接"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"myObj.element = null\r\nelement.someObj = null\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"值得高兴的是"}),"，",(0,s.jsx)(n.strong,{children:"IE9 讲 DOM 和 BOM 改为了 JavaScript 对象"}),"，",(0,s.jsx)(n.strong,{children:"避免了这个问题"})]}),"\n",(0,s.jsxs)(n.h2,{id:"性能",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能",children:"#"}),"性能"]}),"\n",(0,s.jsx)(n.p,{children:"垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失。尤其在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率。"}),"\n",(0,s.jsxs)(n.p,{children:["由于开发者并不知道什么时候会运行垃圾回收机制，因此最好的办法就是在写代码的时候要做到：",(0,s.jsx)(n.strong,{children:"无论什么时候开始收集垃圾"}),"，",(0,s.jsx)(n.strong,{children:"都能让它尽快结束工作"}),"。"]}),"\n",(0,s.jsxs)(n.p,{children:["和其他使用垃圾回收的编程环境不同，JavaScript 运行在一个内存管理和垃圾回收都很特殊的环境——",(0,s.jsx)(n.strong,{children:"分配给浏览器的内存通常要比分配给大型桌面软件的要少很多"}),"，分配给移动浏览器的就更少了。这更多出于安全的考虑，目的是避免大量 JavaScript 网页耗尽系统内存而导致操作系统崩溃。"]}),"\n",(0,s.jsxs)(n.h2,{id:"性能优化",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#性能优化",children:"#"}),"性能优化"]}),"\n",(0,s.jsxs)(n.h3,{id:"解除引用",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解除引用",children:"#"}),"解除引用"]}),"\n",(0,s.jsxs)(n.p,{children:["如果数据不再必要，那么把它设置为 null，从而释放其引用，就叫",(0,s.jsx)(n.strong,{children:"解除引用"}),"。这个建议最适合全局变量和全局对象的属性。局部变量在超出作用域后会被自动解除引用。"]}),"\n",(0,s.jsxs)(n.p,{children:["如下所示：",(0,s.jsx)(n.code,{children:"globalPerson"})," 是一个全局变量，应该在不再需要时手动解除其引用，最后一行就是这么做的"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function createPerson(name) {\r\n    let localPerson = new Object()\r\n    localPerson.name = name\r\n    return localPerson\r\n}\r\n\r\nlet globalPerson = createPerson('Tom')\r\n\r\n// 解除 globalPerson 对值的引用\r\n\r\nglobalPerson = null\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"通过-const-和-let-声明提升性能",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#通过-const-和-let-声明提升性能",children:"#"}),"通过 const 和 let 声明提升性能"]}),"\n",(0,s.jsx)(n.p,{children:"这两个关键字不仅可以改善代码风格，还可以改进垃圾回收。"}),"\n",(0,s.jsx)(n.p,{children:"因为 const 和 let 都以块（而非函数）作为作用域，所以使用这两个关键字可能会更早地让垃圾回收程序介入。"}),"\n",(0,s.jsxs)(n.h3,{id:"隐藏类和删除操作",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#隐藏类和删除操作",children:"#"}),"隐藏类和删除操作"]}),"\n",(0,s.jsx)(n.p,{children:"V8 引擎在将解释后的 JavaScript 代码变为为实际的机器码时会利用 “隐藏类”。如果代码非常注重性能，这一点非常重要。"}),"\n",(0,s.jsxs)(n.p,{children:["下述代码会让 ",(0,s.jsx)(n.code,{children:"a1"})," 和 ",(0,s.jsx)(n.code,{children:"a2"})," 共享隐藏类："]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function Article () {\r\n    this.title = 'Hello'\r\n}\r\n\r\nlet a1 = new Article()\r\nlet a2 = new Article()\n"})}),"\n",(0,s.jsx)(n.p,{children:"但如果添加："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"a2.author = 'Tom'\n"})}),"\n",(0,s.jsxs)(n.p,{children:["就会让两个 ",(0,s.jsx)(n.code,{children:"Article"})," 对应不同的隐藏类。根据这种操作的频率和隐藏类的大小，这可能对性能产生明显的影响。"]}),"\n",(0,s.jsxs)(n.p,{children:["解决方案是：",(0,s.jsx)(n.strong,{children:"避免动态添加属性"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function Article (author) {\r\n    this.title = 'Hello'\r\n    this.author = author\r\n}\r\n\r\nlet a1 = new Article()\r\nlet a2 = new Article('Tom')\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此外：",(0,s.jsxs)(n.strong,{children:["使用 ",(0,s.jsx)(n.code,{children:"delete"})," 关键字会导致无法共享隐藏类"]})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function Article (author) {\r\n    this.title = 'Hello'\r\n    this.author = author\r\n}\r\n\r\nlet a1 = new Article()\r\nlet a2 = new Article('Tom')\r\n\r\ndelete a2.author\n"})}),"\n",(0,s.jsxs)(n.p,{children:["解决方案是：",(0,s.jsx)(n.strong,{children:"避免动态删除属性"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"a2.author = null\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"总结"}),"，为了性能更好，我们应该："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"避免动态添加属性、避免动态删除属性"}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"内存泄漏",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#内存泄漏",children:"#"}),"内存泄漏"]}),"\n",(0,s.jsx)(n.p,{children:"在内存有限的设备上，内存泄漏是一个大问题，JavaScript 中的内存写偶偶大部分是由不合理的引用导致的。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"意外声明全局变量——最常见也最容易修复的问题"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"function setName () {\r\n    name = 'Tom'\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["此时会把 name 当作 window 的属性创建，这种情况下只需要使用 ",(0,s.jsx)(n.code,{children:"var"}),"、",(0,s.jsx)(n.code,{children:"const"})," 和 ",(0,s.jsx)(n.code,{children:"let"})," 即可"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"定时器也可能悄悄地造成内存泄漏"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"let name = 'Jake'\r\nsetInterval(() => {\r\n    return function() {\r\n        return name\r\n    }\r\n})\n"})}),"\n",(0,s.jsx)(n.p,{children:"只要定时器一直运行，回调函数中的 name 就会一直占用内存。所以定时器我们需要及时清除"}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"使用 JavaScript 闭包很可能会在不知不觉间造成内存泄漏"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"let outer = function () {\r\n    let name = 'Tom'\r\n    return function() {\r\n        return name\r\n    }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"调用 outer 就会导致分配给 name 的内存被泄漏"}),"\n",(0,s.jsx)(n.p,{children:"因为只要返回的函数还存在，没有被调用，就会导致垃圾清理程序一直不能清理 name，假如 name 的内容很大，那可能就是大问题"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"静态分配与对象池",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#静态分配与对象池",children:"#"}),"静态分配与对象池"]}),"\n",(0,s.jsx)(n.p,{children:"浏览器决定何时运行垃圾回收程序的一个标准是对象更替的速度。如果有很多对象被初始化，然后又都超出了作用域，俺么浏览器就会采用更激进的办法调度垃圾回收程序。"}),"\n",(0,s.jsxs)(n.p,{children:["因此，一个办法就是不要动态创建对象，而使用已有的对象。这种办法中的一个策略就是",(0,s.jsx)(n.strong,{children:"对象池"}),"。"]}),"\n",(0,s.jsx)(n.p,{children:"在初始化的某一刻，创建一个对象池，用来管理一组可回收的对象，应用程序可以次昂这个对象池请求一个对象、设置器属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象的初始化，垃圾回收探测就不会发现有对象更替。"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"注意"}),"：静态分配时优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但是这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。"]}),"\n"]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}let t=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["docs%2Fjs%2F%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md"]={toc:[{id:"标记策略",text:"标记策略",depth:2},{id:"标记清理",text:"标记清理",depth:3},{id:"引用计数",text:"引用计数",depth:3},{id:"性能",text:"性能",depth:2},{id:"性能优化",text:"性能优化",depth:2},{id:"解除引用",text:"解除引用",depth:3},{id:"通过-const-和-let-声明提升性能",text:"通过 const 和 let 声明提升性能",depth:3},{id:"隐藏类和删除操作",text:"隐藏类和删除操作",depth:3},{id:"内存泄漏",text:"内存泄漏",depth:3},{id:"静态分配与对象池",text:"静态分配与对象池",depth:3}],title:"垃圾回收",frontmatter:{}}},95895:function(e,n,r){r.d(n,{Z:function(){return t}});var s=r(85893),l=r(67294),c=r(45687);r(6175);let i={"zh-CN":e=>`预计阅读时间: ${e.minutes>=1?`${Math.ceil(e.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,r){let s=Object.keys(i).includes(n)?n:r;return i[s](e)}let t=e=>{let{defaultLocale:n="en-US"}=e,r=(0,c.Vi)().page.readingTimeData,i=(0,c.Jr)(),t=(0,c.e7)(),[d,h]=(0,l.useState)(a(r,i,n));return(0,l.useEffect)(()=>{h(a(r,i,n))},[i,r]),(0,s.jsx)("span",{"data-dark":String(t),className:"rp-reading-time",children:d})}}}]);