"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["9286"],{3165:function(n,e,r){r.r(e),r.d(e,{default:()=>j});var d=r("5893"),s=r("65");let a=r.p+"static/image/codepen.6bafa875.gif",i=r.p+"static/image/intension.5d22ff62.png",t=r.p+"static/image/pull-down-basic.3f48c8f6.gif",c=r.p+"static/image/loading.ba11dc1c.gif",l=r.p+"static/image/prinple.a2aa4052.png",h=r.p+"static/image/pull-down.a7edac87.gif";function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",h3:"h3",pre:"pre",code:"code",ul:"ul",li:"li",strong:"strong"},(0,s.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h1,{id:"h5-下拉刷新如何实现",children:["H5 下拉刷新如何实现？",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#h5-下拉刷新如何实现",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"最近我需要做一个下拉刷新的功能，实现功能后我发现，它需要处理的情况还蛮多，于是我整理了这篇文章。"}),"\n",(0,d.jsx)(e.p,{children:"下图是我实现的效果，分为三步：开始下拉时，屏幕顶部会出现加载动画；加载过程中，屏幕顶部高度保持不变；加载完成后，加载动画隐藏。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:h,alt:""})}),"\n",(0,d.jsx)(e.p,{children:"首先我会讲解下拉的原理、根据原理写出初始代码；然后我会说明代码存在的缺陷、解决缺陷并做些额外优化；最后我会给出完整代码，并做一个总结。"}),"\n",(0,d.jsxs)(e.h2,{id:"下拉的原理",children:["下拉的原理",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#下拉的原理",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:l,alt:""})}),"\n",(0,d.jsx)(e.p,{children:"如图所示，蓝色框代表视口，绿色框代表容器，橙色框代表加载动画。最开始时，加载动画处于视口外；开始下拉之后，容器向下移动，加载动画从上方进入视口；结束下拉后，容器又开始向上移动，加载动画也从上方退出视口。"}),"\n",(0,d.jsxs)(e.h2,{id:"下拉基础代码",children:["下拉基础代码",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#下拉基础代码",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"知道原理，我们现在开始写代码，首先是布局的代码："}),"\n",(0,d.jsxs)(e.h3,{id:"布局代码",children:["布局代码",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#布局代码",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"我们把 box 元素当作容器，把 loader-box，loader-box + loading 元素当作动画，至于 h1 元素不需要关注，我们只把它当作操作提示。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-html",children:'<div id="box">\r\n  <div class="loader-box">\r\n    <div id="loading"></div>\r\n  </div>\r\n  <h1>下拉刷新 ↓</h1>\r\n</div>\n'})}),"\n",(0,d.jsx)(e.p,{children:"loader-box 的高度是 80px，按上一节原理中的分析，初始时我们需要让 loader-box 位于视口上方，因此 CSS 代码中我们需要把它的位置向上移动 80px。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-css",children:".loader-box {\r\n  position: relative;\r\n  top: -80px;\r\n  height: 80px;\r\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"loader-box 中的 loader 是纯 CSS 的加载动画。我们利用 border 画出的一个圆形边框，左、上、右边框是浅灰色，下边框是深灰色："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXIAAABGCAIAAABe2ohRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAARCSURBVHic7dw7TyJdHIDxAwMzA4OCIRMSDIkUJlpqYWNhYW/tp/DDSE9tbW9hYWOhnZpYYDAUhBABh8sMt7cYc14WVxflqOzO86uOZPjnFJsnc2EnNB6PBQCoE/7pDQD415AVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIpFfnoDWHSe53U6nV6v1+/3B4PBeDwOhUKRSCQajZqmGY/HdV3/6T1isYR48z7e4jhOq9Xq9XrvH2aa5vLyciKR+J5dYfGRFfyG53n1er3b7c7+lVgslk6nOXOBICt47fn5uVarTX5iWZZlWYZhaJoWDodHo9FwOHRdt91ut9vtySNt215aWvre/WLhkBX8olqtTpYilUolk0lN0946fjgcNpvNRqMhP7EsK5PJfO0usdjICv43eZ6i67pt24ZhzPJF13VrtZrnef6fnLMEHA+Y8cLzPNkUTdOy2eyMTRFCGIaRzWblSc1kYhBAZAUv6vW6v9B1PZfLhcMf+7cRDodzuZy8ZSunIYDICoQQwnEc+dzHtu2PNsUXDodt2/bX3W7XcRxl+8NfhaxACCFarZa/SKVSs1/7vGYYRiqVmpqJoCErEJ7nyd+8JZPJOafJCb1ejzsswURWIDqdjr+wLOudZ8kz0jTNsqypyQgUsgIhT1VkDuYk5/zxh//4J5EViH6/7y/muasySc6RkxEoZAViMBj4i/mvgKbmyMkIFLICIX9p/bnnyq/JOfyGO5jICkQoFPIXo9FIyUA5R05GoJAViEjk5W1ew+FQyUA5R05GoJAViGg06i9c11UyUM6RkxEoZAXCNE1/MfXylE+Tc+RkBApZgYjH4/6i3W7Pfx00HA5lVuRkBApZgdB1XZ5WNJvNOafJCaZp8g7KYCIrEEKI5eVlf9FoNOa5w+K6rnxTnJyJoCErEEKIRCIRi8X8da1W+9yT5tFoJF8EFYvFeBd/YJEVvEin0/7C87ybm5uP/ufjqW/JaQggsoIX/strhRCNRqNYLBYKhXK5PON3y+VyoVAoFov+FZBt29xVCTJekY1fPDw8HB8fyz/39/f39vbeuZxxHOf8/Pzs7Ex+cnR0tLa29qWbxIIjK5h2eXl5cnIy+cnW1tbm5mYul1tZWdF13fO8p6enx8fH29vb6+vrySMPDw93dna+d79YOGQFv1GpVE5PT+/v72f/yvr6+sHBwerq6tftCn8LsoI3XV1dXVxclEql9w/L5/O7u7vb29vfsyssPrKCP6hUKnd3d6VSqVqtNpvNwWAQiUSSyWQmk8nn8xsbG5yhYApZAaAYD5gBKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWACj2H3/xd/JlnTeYAAAAAElFTkSuQmCC",alt:""})}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-css",children:"#loader {\r\n  width: 25px;\r\n  height: 25px;\r\n  border: 3px solid #ddd;\r\n  border-radius: 50%;\r\n  border-bottom: 3px solid #717171;\r\n  transform: rotate(0deg);\r\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"开始刷新时，我们给 loader 元素增加一个动画，让它从 0 度到 360 度无限旋转，就实现了加载动画："}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:c,alt:""})}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-css",children:"#loader.loading {\r\n  animation: loading 1s linear infinite;\r\n}\r\n\r\n@keyframes loading {\r\n  from { transform: rotate(0deg); }\r\n  to { transform: rotate(360deg); }\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"逻辑代码",children:["逻辑代码",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑代码",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"看完布局代码，我们再看逻辑代码。逻辑代码中，我们要监听用户的手指滑动、实现下拉手势。我们需要用到三个事件："}),"\n",(0,d.jsxs)(e.ul,{children:["\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/touchstart_event",target:"_blank",rel:"noopener noreferrer",children:"touchstart"})," 代表触摸开始；"]}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/touchmove_event",target:"_blank",rel:"noopener noreferrer",children:"touchmove"})," 代表触摸移动；"]}),"\n",(0,d.jsxs)(e.li,{children:[(0,d.jsx)(e.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Element/touchend_event",target:"_blank",rel:"noopener noreferrer",children:"touchend"})," 代表触摸结束。"]}),"\n"]}),"\n",(0,d.jsxs)(e.p,{children:["从 ",(0,d.jsx)(e.code,{children:"touchstart"})," 和 ",(0,d.jsx)(e.code,{children:"touchmove"})," 事件中我们可以获取手指的坐标，比如 ",(0,d.jsx)(e.code,{children:"event.touches[0].clientX"})," 是手指相对视口左边缘的 X 坐标，",(0,d.jsx)(e.code,{children:"event.touches[0].clientY"})," 是手指相对视口上边缘的 Y 坐标；从 ",(0,d.jsx)(e.code,{children:"touchend"})," 事件中我们则无法获得 ",(0,d.jsx)(e.code,{children:"clientX"})," 和 ",(0,d.jsx)(e.code,{children:"clientY"}),"。"]}),"\n",(0,d.jsx)(e.p,{children:"我们可以先记录用户手指 touchstart 的 clientY 作为开始坐标，记录用户最后一次触发 touchmove 的 clientY 作为结束坐标，二者相减就得到手指移动的距离 distanceY。"}),"\n",(0,d.jsx)(e.p,{children:"设置手指移动多少距离，容器就移动多少距离，就得到了我们的逻辑代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"const box = document.getElementById('box')\r\nconst loader = document.getElementById('loader')\r\nlet startY = 0, endY = 0, distanceY = 0\r\n\r\nfunction start(e) {\r\n  startY = e.touches[0].clientY\r\n}\r\n\r\nfunction move(e) {\r\n  endY =  e.touches[0].clientY\r\n  distanceY = endY - startY\r\n  box.style = `\r\n    transform: translateY(${distanceY}px);\r\n    transition: all 0.3s linear;\r\n  `\r\n}\r\n\r\nfunction end() {\r\n  setTimeout(() => {\r\n    box.style = `\r\n      transform: translateY(0);\r\n      transition: all 0.3s linear;\r\n    `\r\n    loader.className = 'loading'\r\n  }, 1000)\r\n}\r\n\r\nbox.addEventListener('touchstart', start)\r\nbox.addEventListener('touchmove', move)\r\nbox.addEventListener('touchend', end)\n"})}),"\n",(0,d.jsx)(e.p,{children:"逻辑代码实现一个简陋的下拉效果，当然现在还有很多缺陷。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:t,alt:""})}),"\n",(0,d.jsxs)(e.h2,{id:"简陋下拉效果的-6-个缺陷",children:["简陋下拉效果的 6 个缺陷",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#简陋下拉效果的-6-个缺陷",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"之前我们实现了简陋的下拉效果，它还需要解决 6 个缺陷，才能算一个完善的功能。"}),"\n",(0,d.jsxs)(e.h3,{id:"没有最小最大距离限制",children:["没有最小、最大距离限制",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#没有最小最大距离限制",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第一个缺陷是，下拉没有做最小、最大距离的限制。"}),"\n",(0,d.jsx)(e.p,{children:"通常来说，我们下拉屏幕时，距离太小应该不能触发刷新，距离太大也不行，下滑到一定距离后，就应该无法继续下滑。"}),"\n",(0,d.jsxs)(e.p,{children:["因此我们可以给下拉设置最小距离限制 ",(0,d.jsx)(e.code,{children:"DISTANCE_Y_MIN_LIMIT"}),"、最大距离限制 ",(0,d.jsx)(e.code,{children:"DISTANCE_Y_MAX_LIMIT"}),"。如果 touchend 中发现下拉距离小于最小距离，直接不触发加载；如果 touchmove 中下拉距离超过最大距离，页面只向下移动最大距离。"]}),"\n",(0,d.jsx)(e.p,{children:"解决缺陷关键代码如下："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"const DISTANCE_Y_MAX_LIMIT = 150\r\n  DISTANCE_Y_MIN_LIMIT = 80\r\n\r\nfunction move(e) {\r\n  endY =  e.touches[0].clientY\r\n  distanceY = endY - startY\r\n  if (distanceY > DISTANCE_Y_LIMIT) {\r\n    distanceY = DISTANCE_Y_LIMIT\r\n  }\r\n  box.style = `\r\n    transform: translateY(${distanceY}px);\r\n    transition: all 0.3s linear;\r\n  `\r\n}\r\n\r\nfunction end() {\r\n  if (distanceY < DISTANCE_Y_MIN_LIMIT) {\r\n    box.style = `\r\n      transform: translateY(0px);\r\n      transition: all 0.3s linear;\r\n    `\r\n    return\r\n  }\r\n  ...\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"加载动画没有停留在视口顶部",children:["加载动画没有停留在视口顶部",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#加载动画没有停留在视口顶部",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第二个缺陷是，下拉没有让加载动画停留在视口顶部。"}),"\n",(0,d.jsxs)(e.p,{children:["我们可以把 end 函数加以改造，在数据还没有加载完成时（用 setTimeout 模拟的），让加载动画 style 的 ",(0,d.jsx)(e.code,{children:"translateY"})," 一直是 80px，",(0,d.jsx)(e.code,{children:"translateY(80px)"})," 可以和 初始 CSS 的 ",(0,d.jsx)(e.code,{children:"top: -80px;"})," 相互抵消，让动画在未刷新完成前停留在视口顶部。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function end() {\r\n  ...\r\n  box.style = `\r\n    transform: translateY(80px);\r\n    transition: all 0.3s linear;\r\n  `\r\n  loader.className = 'loading'\r\n  setTimeout(() => {\r\n    box.style = `\r\n      transform: translateY(0px);\r\n      transition: all 0.3s linear;\r\n    `\r\n    loader.className = ''\r\n  }, 1000)\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"重复触发",children:["重复触发",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#重复触发",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第三个缺陷是，下拉可以重复触发。"}),"\n",(0,d.jsx)(e.p,{children:"正常来说，如果我们已经下拉过，数据正在加载中时，我们不能继续下拉。"}),"\n",(0,d.jsx)(e.p,{children:"我们可以增加一个加载锁 loadLock。当加载锁开启时，start，move 和 end 事件都不会触发。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"let loadLock = false\r\n\r\nfunction start(e) {\r\n  if (loadLock) { return }\r\n  ...\r\n}\r\n\r\nfunction move(e) {\r\n  if (loadLock) { return }\r\n  ...\r\n}\r\n\r\nfunction end(e) {\r\n  if (loadLock) { return }\r\n  ...\r\n  setTimeout(() => {\r\n    ...\r\n    loadLock = true\r\n    ...\r\n  }, 1000)\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"没有限制方向",children:["没有限制方向",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#没有限制方向",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第四个缺陷是，没有限制方向。"}),"\n",(0,d.jsxs)(e.p,{children:["目前我们的代码，用户上拉也能触发。我们可以增加判断，当 ",(0,d.jsx)(e.code,{children:"endY - startY"})," 小于 0 时，阻止 ",(0,d.jsx)(e.code,{children:"touchmove"})," 和 ",(0,d.jsx)(e.code,{children:"touchend"})," 的逻辑。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function move(e) {\r\n  ...\r\n  if (endY - startY < 0) { return }\r\n  ...\r\n}\r\n\r\nfunction end() {\r\n  if (endY - startY < 0) { return }\r\n  ...\r\n}\n"})}),"\n",(0,d.jsxs)(e.p,{children:["你可能会疑惑，为什么我宁愿写多个判断拦截，也不取消监听事件。这是因为",(0,d.jsx)(e.strong,{children:"一旦取消监听事件，我们需要考虑在一个合适的时间重新监听"}),"，这会把问题变得更复杂。"]}),"\n",(0,d.jsxs)(e.h3,{id:"没有阻止原生滚动",children:["没有阻止原生滚动",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#没有阻止原生滚动",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第五个缺陷时，我们在加载数据时没有阻止原生滚动。"}),"\n",(0,d.jsx)(e.p,{children:"虽然我们已经阻止了重复下拉，touchmove 和 touchend 事件被拦截了，但是 H5 原生滚动还能用。"}),"\n",(0,d.jsxs)(e.p,{children:["我们可以在刷新时给 body 设置一个 ",(0,d.jsx)(e.code,{children:"overflow: hidden;"})," 属性，刷新结束后清除 ",(0,d.jsx)(e.code,{children:"overflow: hidden"}),"，这样就可以阻止原生滚动。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-css",children:"body.overflowHidden {\r\n  overflow: hidden;\r\n}\n"})}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"const body = document.body\r\nfunction end() {\r\n  ...\r\n  box.style = `\r\n    transform: translateY(80px);\r\n    transition: all 0.3s linear;\r\n  `\r\n  loader.className = 'loading'\r\n  body.className = 'overflowHidden'\r\n  setTimeout(() => {\r\n    ...\r\n    box.style = `\r\n      transform: translateY(0px);\r\n      transition: all 0.3s linear;\r\n    `\r\n    loader.className = ''\r\n    body.className = ''\r\n  }, 1000)\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"没有阻止-ios-橡皮筋效果",children:["没有阻止 iOS 橡皮筋效果",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#没有阻止-ios-橡皮筋效果",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第 6 个缺陷是，没有阻止 iOS 的橡皮筋效果。"}),"\n",(0,d.jsxs)(e.p,{children:["iOS 浏览器默认滑动时有一个橡皮筋效果，我们需要阻止它，避免影响我们的下拉手势。阻止方式就是给监听器设置 ",(0,d.jsx)(e.code,{children:"passive: false"}),"。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function addTouchEvent() {\r\n  box.addEventListener('touchstart', start, { passive: false })\r\n  box.addEventListener('touchmove', move, { passive: false })\r\n  box.addEventListener('touchend', end, { passive: false })\r\n}\r\n\r\naddTouchEvent()\n"})}),"\n",(0,d.jsx)(e.p,{children:"解决完 6 个缺陷后，我们已经得到无缺陷的下拉刷新功能，但离丝滑的下拉刷新还有一段距离。我们还可以做一些优化，让下拉刷新更完善。"}),"\n",(0,d.jsxs)(e.h2,{id:"优化",children:["优化",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#优化",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"我们可以做两个优化，第一个优化是添加阻尼效果："}),"\n",(0,d.jsxs)(e.h3,{id:"增加阻尼效果",children:["增加阻尼效果",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#增加阻尼效果",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"所谓阻尼效果，就是下拉过程我们可以感受到一股阻力的存在，虽然我们下拉力度是一样的，但距离的增加速度变慢了。用物理术语表示的话，就是加速度变小了。"}),"\n",(0,d.jsx)(e.p,{children:"体现到代码上，我们可以设置一个百分比，百分比会随着下拉距离增加而减少，把百分比乘以距离当作最后的距离。"}),"\n",(0,d.jsxs)(e.p,{children:["代码中百分比 ",(0,d.jsx)(e.code,{children:"percent"})," 设为 ",(0,d.jsx)(e.code,{children:"(100 - distanceY * 0.5) / 100"}),"，当 ",(0,d.jsx)(e.code,{children:"distanceY"})," 越来越大时，百分比 ",(0,d.jsx)(e.code,{children:"percent"})," 越来越小，最后再把 ",(0,d.jsx)(e.code,{children:"distanceY * percent"})," 赋值给 ",(0,d.jsx)(e.code,{children:"distanceY"}),"。"]}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"function move(e) {\r\n  ...\r\n  distanceY = endY - startY\r\n  let percent = (100 - distanceY * 0.5) / 100\r\n  percent = Math.max(0.5, percent)\r\n  distanceY = distanceY * percent\r\n  if (distanceY > DISTANCE_Y_MAX_LIMIT) {\r\n    distanceY = DISTANCE_Y_MAX_LIMIT\r\n  }\r\n  ...\r\n}\n"})}),"\n",(0,d.jsxs)(e.h3,{id:"利用角度判断用户下拉意图",children:["利用角度判断用户下拉意图",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用角度判断用户下拉意图",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"第二个优化是利用角度判断用户下拉意图。"}),"\n",(0,d.jsx)(e.p,{children:"下图展示了两种用户下拉的情况，β 角度比 α 角度小，角度越小用户下拉意图越明显、误触的可能性更小。"}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:i,alt:""})}),"\n",(0,d.jsx)(e.p,{children:"我们可以利用反三角函数求出角度来判断下拉意图。"}),"\n",(0,d.jsxs)(e.p,{children:["JavaScript 中，反正切函数是 ",(0,d.jsx)(e.code,{children:"Math.atan()"}),"，需要注意的是，反正切函数算出的是弧度，我们还需要将它乘以 ",(0,d.jsx)(e.code,{children:"180 / π"})," 才能获取角度。"]}),"\n",(0,d.jsx)(e.p,{children:"下面的代码中，我们做了一个限制，只有角度小于 40 时，我们才认为用户的真实意图是想要下拉刷新。"}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-js",children:"const DEG_LIMIT = 40\r\nfunction move(e) {\r\n  ...\r\n  distanceY = endY - startY\r\n  distanceX = endX - startX\r\n  const deg = Math.atan(Math.abs(distanceX) / distanceY)\r\n    * (180 / Math.PI)\r\n  if (deg > DEG_LIMIT) {\r\n    [startY, startX] = [endY, endX]\r\n    return\r\n  }\r\n  ...\r\n}\n"})}),"\n",(0,d.jsxs)(e.h2,{id:"代码示例",children:["代码示例",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码示例",children:"#"})]}),"\n",(0,d.jsxs)(e.p,{children:["你可以在 ",(0,d.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/xxBeZrr",target:"_blank",rel:"noopener noreferrer",children:"codepen"})," 中查看效果，web 端需要按 F12 用手机浏览器打开。"]}),"\n",(0,d.jsx)(e.p,{children:(0,d.jsx)("img",{src:a,alt:""})}),"\n",(0,d.jsxs)(e.h2,{id:"总结",children:["总结",(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,d.jsx)(e.p,{children:"本文讲解了下拉的原理、并根据原理写出初始代码。在初始代码的基础上，我解决了 6 个缺陷、做了 2 个优化，实现了一个完善的下拉刷新效果。"})]})}function x(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,d.jsx)(e,{...n,children:(0,d.jsx)(o,{...n})}):o(n)}let j=x;x.__RSPRESS_PAGE_META={},x.__RSPRESS_PAGE_META["blog%2F2024%2F02-28%2Findex.md"]={toc:[{text:"下拉的原理",id:"下拉的原理",depth:2},{text:"下拉基础代码",id:"下拉基础代码",depth:2},{text:"布局代码",id:"布局代码",depth:3},{text:"逻辑代码",id:"逻辑代码",depth:3},{text:"简陋下拉效果的 6 个缺陷",id:"简陋下拉效果的-6-个缺陷",depth:2},{text:"没有最小、最大距离限制",id:"没有最小最大距离限制",depth:3},{text:"加载动画没有停留在视口顶部",id:"加载动画没有停留在视口顶部",depth:3},{text:"重复触发",id:"重复触发",depth:3},{text:"没有限制方向",id:"没有限制方向",depth:3},{text:"没有阻止原生滚动",id:"没有阻止原生滚动",depth:3},{text:"没有阻止 iOS 橡皮筋效果",id:"没有阻止-ios-橡皮筋效果",depth:3},{text:"优化",id:"优化",depth:2},{text:"增加阻尼效果",id:"增加阻尼效果",depth:3},{text:"利用角度判断用户下拉意图",id:"利用角度判断用户下拉意图",depth:3},{text:"代码示例",id:"代码示例",depth:2},{text:"总结",id:"总结",depth:2}],title:"H5 下拉刷新如何实现？",frontmatter:{tags:["H5"]}}}}]);