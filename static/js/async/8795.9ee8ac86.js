"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["8795"],{89648:function(n,e,r){r.r(e),r.d(e,{default:function(){return c}});var t=r(85893),s=r(50065),i=r(95895),o=r(42548);function l(n){let e=Object.assign({pre:"pre",code:"code",p:"p"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n","\n","\n","\n",(0,t.jsx)(o.Z,{markdown:`
# 小程序如何检测无流量组件？

## 背景

小程序经过长期迭代后，会有很多组件被页面 json 直接引用，这些组件虽然没有流量，但是打包的时没有办法排除掉。应该怎么办

## 思路：先获取全体组件的集合，再获取有流量组件的集合，然后取二者的差集

### 获取全体组件的集合

- 组件基础文件有 4 个，wxml、wxss、js 和 json，其中 json 中，总是有 "component": true。可以扫描所有的文件夹，如果满足条件，则认为和 json 同名的 wxml 是一个组件。 

### 获取有流量的组件集合

`}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const fs = require('fs');\r\nconst path = require('path');\r\n\r\n// 目标文件夹路径\r\nconst targetDir = './';\r\n\r\n// 使用栈读取文件夹中的所有文件\r\nfunction readDirWithStack(dir) {\r\n  let results = [];\r\n  let stack = [dir];\r\n\r\n  while (stack.length) {\r\n    const currentDir = stack.pop();\r\n    const list = fs.readdirSync(currentDir);\r\n\r\n    list.forEach(file => {\r\n      const filePath = path.resolve(currentDir, file);\r\n      const stat = fs.statSync(filePath);\r\n\r\n      if (stat && stat.isDirectory()) {\r\n        stack.push(filePath);\r\n      } else {\r\n        results.push(filePath);\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(results)\r\n  return results;\r\n}\r\n\r\n// 判断是否为组件\r\nfunction isComponent(filePath) {\r\n  const dir = path.dirname(filePath);\r\n  const files = fs.readdirSync(dir);\r\n  const jsonFile = files.find(file => file.endsWith('.json'));\r\n  if (jsonFile) {\r\n    const jsonFilePath = path.join(dir, jsonFile);\r\n    const jsonContent = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));\r\n    return jsonContent.component === true;\r\n  }\r\n  return false;\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"获取有流量组件名单思路：给每一个组件打点，如果组件走到 attached 生命周期，就上报一条记录，最后就能得到所有有流量的组件。"}),"\n",(0,t.jsx)(e.p,{children:"不过，如果给所有组件直接插入代码打点，工作量会非常庞大，如果有人新增组件，也可能忘记这条逻辑，所有我们需要其他方式。"}),"\n",(0,t.jsx)(e.p,{children:"介绍这个方式前，我先介绍一些小程序中，behavior 的概念。小程序中可以利用 Behavior 给组件生命周期内插入一段逻辑。"}),"\n",(0,t.jsx)(e.p,{children:"基础用法为："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const myBehavior = Behavior({\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> my behavior')\r\n    }\r\n  }\r\n})\r\n\r\nComponent({\r\n  behaviors: [myBehavior],\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> normal behavior')\r\n    }\r\n  }\r\n})\n"})}),"\n",(0,t.jsx)(e.p,{children:"这种方法类似 Vue 的 mixin 或 React 的 HOC，之后小程序会把 Behavior 和 Component 组件的生命周期融合。"}),"\n",(0,t.jsx)(e.p,{children:"替换生命周期"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"// 替换 Component 函数\r\nfunction replaceComponentFunction(filePath) {\r\n  const fileContent = fs.readFileSync(filePath, 'utf8');\r\n  const newContent = fileContent.replace(\r\n    /\\bComponent\\(/g,\r\n    \"require('@utils/enhance-component.js').enhanceComponent(\"\r\n  );\r\n  fs.writeFileSync(filePath, newContent, 'utf8');\r\n}\r\n\r\n// 获取所有 .js 文件\r\nconst files = readDirWithStack(targetDir).filter(file => file.endsWith('.js'));\r\n\r\n// 替换每个文件中的 Component 函数\r\nfiles.forEach(file => {\r\n  if (isComponent(file)) {\r\n    replaceComponentFunction(file);\r\n  }\r\n});\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const enhanceBehavior = Behavior({\r\n  lifetimes: {\r\n    attached: function () {\r\n      console.log('enhance component >>>>>: ', this.is)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports.enhanceComponent = function (config) {\r\n  const { behaviors = [], ...params } = config || {}\r\n  return Component({\r\n    behaviors: [enhanceBehavior, ...behaviors],\r\n    ...params,\r\n  })\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"result 是用于存储所有文件路径的数组，stack 则是用来完成工作的栈"}),"\n",(0,t.jsx)(e.p,{children:"初始情况下，stack 内部是根目录，我们开始读取根目录中的所有文件和子目录；"}),"\n",(0,t.jsx)(e.p,{children:"我们利用 fs.statSyc 获取文件状态信息 stat，如果 stat.isDirectory() 为 true，证明它是一个目录，把它压入栈中，以便之后处理"}),"\n",(0,t.jsx)(e.p,{children:"如果为 false，证明它是一个文件，就放到 result 数组中"}),"\n",(0,t.jsx)(e.p,{children:"我们会不断从栈中取出目录读取文件，直到栈中再也没有目录，这样就实现了获取所有文件路径的功能"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(l,n)})):l(n)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["blog%2F2024%2F11%2F25%2Foutline.mdx"]={toc:[],title:"",frontmatter:{}}},42548:function(n,e,r){r.d(e,{Z:()=>u});var t=r("85893"),s=r("67294"),i=r("1001"),o=r("72555");let l=new(r("94970")).$T,{scripts:a,styles:c}=l.getAssets();"undefined"!=typeof window&&((0,o.j)(c),(0,o.fs)(a,{getMarkmap:()=>i}));var f=r("70243");r("59723");let h={minHeight:"50vh",backgroundColor:"#f1f1f1"};function u(n){let{markdown:e}=n,[r]=(0,s.useState)(e),[o,a]=(0,s.useState)(h),c=(0,s.useRef)(),u=(0,s.useRef)(),d=(0,s.useRef)(),p=(n,e)=>{for(;null==e?void 0:e.firstChild;)e.firstChild.remove();if(n&&e){let r=new f.o;r.attach(n),r.register({id:"full",title:"full screen",content:f.o.icon("M16 4h-12v12h12v-8h-8v4h2v-2h4v4h-8v-8h10z"),onClick:()=>{var n;let e=null===(n=document.getElementsByClassName("rspress-sidebar"))||void 0===n?void 0:n[0];if(!!e){if("fixed"===c.current.style.position){a(h),e.style.display="block";return}a({position:"fixed",zIndex:1,right:0,bottom:0,width:"100vw",height:"calc(100vh - var(--rp-nav-height))",backgroundColor:"#f1f1f1"}),e.style.display="none"}}}),r.setItems(["zoomIn","zoomOut","fit","full"]),e.append(r.render())}};return(0,s.useEffect)(()=>{if(u.current)return;let n=i.Markmap.create(c.current);u.current=n,p(u.current,d.current)},[c.current]),(0,s.useEffect)(()=>{let n=u.current;if(!n)return;let{root:e}=l.transform(r);n.setData(e),n.fit()},[u.current,r]),(0,s.useEffect)(()=>{let n=u.current;if(!!n)n.fit()},[o]),(0,t.jsx)(s.Fragment,{children:(0,t.jsxs)("div",{className:"relative",style:o,children:[(0,t.jsx)("svg",{className:"w-full h-full",ref:c,style:o}),(0,t.jsx)("div",{className:"absolute bottom-0 right-0 z-10",ref:d})]})})}}}]);