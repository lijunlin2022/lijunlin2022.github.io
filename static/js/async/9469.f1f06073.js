"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["9469"],{7:function(n,e,l){l.r(e),l.d(e,{default:function(){return c}});var r=l(5893),i=l(65);function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",sup:"sup",ul:"ul",li:"li",h2:"h2",pre:"pre",code:"code",h3:"h3",ol:"ol",strong:"strong",section:"section"},(0,i.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"h5-离线包放入-html-后降级方案如何设计",children:["H5 离线包放入 HTML 后降级方案如何设计？",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#h5-离线包放入-html-后降级方案如何设计",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["离线包是移动端 H5 常见的性能优化方案。开发者们或多或少都接触过离线包。francecil 大佬还总结了离线包是否要放入 HTML 的两种决策，以及决策的优缺点： ",(0,r.jsx)(e.sup,{children:(0,r.jsx)(e.a,{href:"#fn-1",id:"fnref-1","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"："]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"放入 HTML（缓存优先）：更好的性能，但更新不及时。"}),"\n",(0,r.jsx)(e.li,{children:"不放入 HTML（网络优先）：实时更新，但性能较差，可能会加载失败。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"我选择把 HTML 放入离线包，这意味着 H5 出现线上故障时，没有办法及时修复。因此，我必须额外设计一套降级方案，保证离线包发生故障时能够快速降级。"}),"\n",(0,r.jsx)(e.p,{children:"如果你也为离线包的降级而烦恼，看了这篇文章，你一定有所收获。我会从离线包的机制说起，解释离线包放入 HTML 后为什么更新不及时，然后我会介绍自己设计的降级方案，最后我会对这个方案做一个总结。"}),"\n",(0,r.jsxs)(e.h2,{id:"离线包的生效机制",children:["离线包的生效机制",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#离线包的生效机制",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为什么离线包放入 HTML 后更新不及时？为了回答这个问题，我们必须先知道它是如何生效的。"}),"\n",(0,r.jsx)(e.p,{children:"离线包首先会把 HTML、CSS 和 JS 等资源文件打包成一个压缩包，并预先下载到 App 本地，解压到缓存中。当用户访问 H5 时，Webview 开始加载资源的 URL 并发出资源请求，App 会拦截这些请求。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如果缓存中有满足请求的资源，App 会使用缓存资源；"}),"\n",(0,r.jsx)(e.li,{children:"如果缓存中没有满足请求的资源，App 会使用线上资源。"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart LR\r\n  A(加载离线包) --\x3e B[解压到缓存]\r\n  B --\x3e C[Webview 加载 URL]\r\n  C --\x3e D{{从缓存读取}}\r\n  D --\x3e |有|E[返回缓存数据]\r\n  D --\x3e |无|F[请求线上地址]\n"})}),"\n",(0,r.jsx)(e.p,{children:"什么时候叫缓存资源满足请求呢？就是缓存文件名字和请求文件名字一致。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"如果我们在离线包里放入 HTML，由于 HTML 文件不会轻易改变，即使线上资源有更新，App 也会优先使用缓存资源；"}),"\n",(0,r.jsx)(e.li,{children:"如果我们不放入 HTML，由于 CSS 和 JS 文件名的哈希会改变，所以线上资源有更新时，App 内 HTML、CSS 和 JS 都会使用线上资源。"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"我设计的降级方案",children:["我设计的降级方案",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#我设计的降级方案",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上一节我们已经知道，HTML 文件名没有变化，离线包就不会失效。我们可以利用跳转间接改变文件名。"}),"\n",(0,r.jsxs)(e.h3,{id:"利用跳转降级离线包",children:["利用跳转降级离线包",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用跳转降级离线包",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"首先，我们需要准备两个内容一样的 HTML，一个是 index.html，另一个是 index-online.html。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"index.html 会放入离线包；"}),"\n"]}),"\n",(0,r.jsxs)(e.li,{children:["\n",(0,r.jsx)(e.p,{children:"index-online.html 不会放入离线包。"}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"然后，我们会设计一个开关，控制 index.html 是否要跳转。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"开关开启时，index.html 会跳转到 index-online.html；"}),"\n",(0,r.jsx)(e.li,{children:"开关关闭时，index.html 保持原始逻辑。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这样发生线上故障时，我们可以回滚线上的 H5 页面，此时 index-online.html 恢复正常，而缓存在用户 App 本地的 index.html 还有问题。"}),"\n",(0,r.jsx)(e.p,{children:"我们开启开关后，离线的 index.html 直接跳转到已经恢复正常的 index-online.html，就实现了离线包的降级。"}),"\n",(0,r.jsxs)(e.h3,{id:"利用版本大小设计开关",children:["利用版本大小设计开关",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用版本大小设计开关",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上一小节，我们提到降级方案需要一个开关，设计这个开关，我们需要考虑两个问题："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"离线包有 n 个版本，有时多个版本均存在问题。比如 1.0.0 离线包没有问题，1.0.1 和 1.0.2 都有问题，我们需要保证开关能够降级多个版本。"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart LR\r\nA[1.0.0 正确] --\x3e B[1.0.1 错误] --\x3e C[1.0.2 错误]\n"})}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"我们会发布修复的离线包，比如我们会在 1.0.3 修复问题。开关打开后，不能把修复版本降级。"}),"\n"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart LR\r\nA[1.0.0 正确] --\x3e B[1.0.1 错误] --\x3e C[1.0.2 错误] --\x3e D[1.0.3 正确]\n"})}),"\n",(0,r.jsx)(e.p,{children:"怎么设计呢？我这里采取最简单粗暴的思路，把离线包本身的版本 H5_VERSION 和要降级的版本 rollbackVersion 做一个比较。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"H5_VERSION <= rollbackVersion"}),"，相当于打开降级开关。"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"H5_VERSION > rollbackVersion"}),"，相当于关闭降级开关。"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["继续使用之前的例子，1.0.2 是出现问题的最高版本，我们可以把 rollbackVersion 设置为 1.0.2，",(0,r.jsx)(e.code,{children:"<= 1.0.2"})," 全部降级。这样虽然会误伤 1.0.0 版本，但能既满足降级多个有问题的版本，又满足不降级修复版本。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart LR\r\nsubgraph 降级\r\nA[1.0.0 正确] --\x3e B[1.0.1 错误] --\x3e C[1.0.2 错误]\r\nend\r\nC --\x3e D[1.0.3 正确]\n"})}),"\n",(0,r.jsxs)(e.p,{children:["发生下一次故障时，我们再更新 rollbackVersion，比如 1.0.4 发生了故障，我们把 rollbackVersion 设置为 1.0.4，",(0,r.jsx)(e.code,{children:"<= 1.0.4"})," 全部降级。"]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart LR\r\nsubgraph 降级\r\nA[1.0.0 正确] --\x3e B[1.0.1 错误] --\x3e C[1.0.2 错误] --\x3e D[1.0.3 正确] --\x3e E[1.0.4 错误]\r\nend\r\nE --\x3e F[1.0.5 正确]\n"})}),"\n",(0,r.jsxs)(e.h3,{id:"利用-localstorage-延迟开关生效时间",children:["利用 localStorage 延迟开关生效时间",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#利用-localstorage-延迟开关生效时间",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"上一节我们介绍了如何设计开关。需要注意的是，我们不能一发现开关打开、就立即跳转，这会中断用户正常的操作。（比如用户正在浏览页面，突然页面跳转）"}),"\n",(0,r.jsx)(e.p,{children:"我们等开关打开后，在 localStorage 中存储一下代表打开的标识，等到用户下次进入页面时，发现有打开标识再跳转到 index-online.html。"}),"\n",(0,r.jsxs)(e.h3,{id:"流程图",children:["流程图",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#流程图",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"考虑完上面三个问题后，我们就可以设计一个比较完善的降级方案了，它的流程图如下："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-mermaid",children:"flowchart TD\r\n  A(开始) --\x3e B[获取 localStorage 中的 needRollback]\r\n  B --\x3e C{{needRollback 等于 1}}\r\n  C --\x3e |No| D[获取 H5 版本号 H5_VERSION, 获取降级离线包的配置 rollbackVersion]\r\n  C --\x3e |Yes| E[跳转 index-online.html]\r\n  E --\x3e I(结束)\r\n  D --\x3e F{{H5_VERSION 小于等于 rollbackVersion}}\r\n  F --\x3e |Yes| G[在 localStorage 中设置 needRollback]\r\n  F --\x3e |No| H[删除 localStorage 中的 needRollback]\r\n  G --\x3e I\r\n  H --\x3e I\n"})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"用户一进入页面，会先获取 localStorage 中的 needRollback 开关标识。"}),"\n",(0,r.jsxs)(e.li,{children:["如果 needRollback 标识打开，则跳转 index-online.html 实现降级。（注：",(0,r.jsx)(e.strong,{children:"index-online.html 中不能继续判断 needRollback，否则会无限跳转"}),"）"]}),"\n",(0,r.jsx)(e.li,{children:"如果 needRollback 标识没有打开，则继续获取 H5 本身的版本号，以及接口下发的 rollbackVersion。"}),"\n",(0,r.jsxs)(e.li,{children:["如果 ",(0,r.jsx)(e.code,{children:"H5_VERSION <= rollbackVersion"}),"，则在 localStorage 把 needRollback 设置为 1。"]}),"\n",(0,r.jsxs)(e.li,{children:["如果 ",(0,r.jsx)(e.code,{children:"H5_VERSION > rollbackVersion"}),"，则删除 localStorage 中的 needRollback 标识。"]}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"总结",children:["总结",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"本文介绍了一种离线包放入 HTML 的降级方案，它主要有三个特点："}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"利用从离线化的 index.html 跳转到线上的 index-online.html 实现降级。"}),"\n",(0,r.jsxs)(e.li,{children:["利用离线包版本 ",(0,r.jsx)(e.code,{children:"H5_VERSION <= rollbackVersion"})," 做开关，判断是否需要降级。"]}),"\n",(0,r.jsx)(e.li,{children:"利用 localStorage 中设置 needRollback 标识，延迟开关作用时间。"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"这种方案是离线包放入 HTML 后，一种成本较低的降级方案。它会在降级时误伤低版本的离线包，以损耗性能为代价，保障质量。"}),"\n",(0,r.jsxs)(e.section,{"data-footnotes":!0,className:"footnotes",children:[(0,r.jsx)(e.h2,{id:"footnote-label",className:"sr-only",children:"Footnotes"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{id:"#fn-1",children:["\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{href:"https://juejin.cn/post/7254549436625256506",target:"_blank",rel:"noopener noreferrer",children:"HTML 放入离线包？你需要了解的离线策略"})," ",(0,r.jsx)(e.a,{href:"#fnref-1","data-footnote-backref":!0,"aria-label":"Back to content",className:"data-footnote-backref",children:"↩"})]}),"\n"]}),"\n"]}),"\n"]})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(s,{...n})}):s(n)}let c=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["blog%2F2024%2F01-27%2Findex.md"]={toc:[{text:"离线包的生效机制",id:"离线包的生效机制",depth:2},{text:"我设计的降级方案",id:"我设计的降级方案",depth:2},{text:"利用跳转降级离线包",id:"利用跳转降级离线包",depth:3},{text:"利用版本大小设计开关",id:"利用版本大小设计开关",depth:3},{text:"利用 localStorage 延迟开关生效时间",id:"利用-localstorage-延迟开关生效时间",depth:3},{text:"流程图",id:"流程图",depth:3},{text:"总结",id:"总结",depth:2}],title:"H5 离线包放入 HTML 后降级方案如何设计？",frontmatter:{tags:["H5"]}}}}]);