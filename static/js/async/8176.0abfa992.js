"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["8176"],{14095:function(e,r,n){n.r(r),n.d(r,{default:function(){return o}});var s=n(85893),t=n(50065),a=n(2544),c=n(95895);function d(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",sup:"sup",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",section:"section",ol:"ol"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(r.h1,{id:"文件",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#文件",children:"#"}),"文件"]}),"\n",(0,s.jsx)(c.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(r.h2,{id:"管道流",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#管道流",children:"#"}),"管道流"]}),"\n",(0,s.jsx)(r.p,{children:"Node 本身有一个文件的管道流概念，文件就是装水的桶，文件就是水，然后用一个管道连接两个桶，从而实现大文件的复制过程。"}),"\n",(0,s.jsx)(a.Z,Object.assign({code:"graph LR\r\nsource --pipe--\x3e dest"},{config:{}})),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const { createReadStream, createWriteStream } = require('fs')\r\n\r\nconst reader = createReadStream('input.txt')\r\nconst writer = createWriteStream('output.txt')\r\n\r\nreader.pipe(writer)\n"})}),"\n",(0,s.jsx)(r.p,{children:"在 Gulp 中，不仅文件支持管道流的概念，文件夹也支持管道流的概念。"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const { src, dest } = require('gulp')\r\n\r\nfunction copy() {\r\n  return src('input/*.js')\r\n    .pipe(dest('output/'))\r\n}\r\n\r\nexports.copy = copy\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"node-的四种流类型",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#node-的四种流类型",children:"#"}),"Node 的四种流类型"]}),"\n",(0,s.jsxs)(r.p,{children:["Node.js 中有四种基本的流类型 ",(0,s.jsx)(r.sup,{children:(0,s.jsx)(r.a,{href:"#user-content-fn-2",id:"user-content-fnref-2","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"1"})}),"："]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Readable，可读的流，例如 fs.createReadStream()"}),"\n",(0,s.jsx)(r.li,{children:"Writable，可写的流，例如 fs.createWriteStream()"}),"\n",(0,s.jsx)(r.li,{children:"Duplex，可读写的流，例如 net.Socket"}),"\n",(0,s.jsx)(r.li,{children:"Transform，在读写过程中可以修改和变换数据的 Duplex 流"}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:["如果我们需要自己实现某一种流，那么需要重写一些方法：",(0,s.jsx)(r.sup,{children:(0,s.jsx)(r.a,{href:"#user-content-fn-3",id:"user-content-fnref-3","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"2"})})]}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"类"}),(0,s.jsx)(r.th,{children:"需要重写的方法"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Readable"}),(0,s.jsx)(r.td,{children:"_read"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Writable"}),(0,s.jsx)(r.td,{children:"_write"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Duplex"}),(0,s.jsx)(r.td,{children:"_read, _write"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Transform"}),(0,s.jsx)(r.td,{children:"_transform, _flush"})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"举一个自定义 Transform 的例子："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const { Transform } = require('stream')\r\n\r\nconst upperCaseTr = new Transform({\r\n  transform(chunk, encoding, callback) {\r\n    this.push(chunk.toString().toUpperCase())\r\n    callback()\r\n  }\r\n})\r\n\r\nprocess.stdin.pipe(upperCaseTr).pipe(process.stdout)\n"})}),"\n",(0,s.jsx)(r.p,{children:"这个流可以将控制台的输入流，转换为全大写的字母，然后输出。"}),"\n",(0,s.jsxs)(r.h2,{id:"nodejs-文件操作",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-文件操作",children:"#"}),"Node.js 文件操作"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.code,{children:"path.parse()"})," 函数，返回的对象有如下属性：",(0,s.jsx)(r.code,{children:"root"}),", ",(0,s.jsx)(r.code,{children:"dir"}),", ",(0,s.jsx)(r.code,{children:"base"}),", ",(0,s.jsx)(r.code,{children:"name"}),", ",(0,s.jsx)(r.code,{children:"ext"}),"。",(0,s.jsx)(r.sup,{children:(0,s.jsx)(r.a,{href:"#user-content-fn-4",id:"user-content-fnref-4","data-footnote-ref":!0,"aria-describedby":"footnote-label",children:"3"})})]}),"\n",(0,s.jsxs)(r.h2,{id:"流操作是异步的",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#流操作是异步的",children:"#"}),"流操作是异步的"]}),"\n",(0,s.jsxs)(r.p,{children:["Node.js 中的流是异步操作。使用流进行数据的读取和写入时，会异步地进行数据传输，即读取和写入过程会在后台异步完成，不会阻塞代码的执行。当读取或写入操作完成时，会触发相应的事件（例如 ",(0,s.jsx)(r.code,{children:"data"}),"，",(0,s.jsx)(r.code,{children:"end"}),"，",(0,s.jsx)(r.code,{children:"error"})," 事件等），执行这些事件对应的回调函数。"]}),"\n",(0,s.jsx)(r.p,{children:"因为流是异步的，所以为了避免数据丢失问题，我们一般会使用回调函数或者 Promise 等方式来处理数据。"}),"\n",(0,s.jsxs)(r.h2,{id:"判断是文件还是文件夹",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#判断是文件还是文件夹",children:"#"}),"判断是文件还是文件夹"]}),"\n",(0,s.jsxs)(r.p,{children:["Node.js 中，我们可以用 ",(0,s.jsx)(r.code,{children:"fs.statSync()"})," 获取文件信息，然后利用 ",(0,s.jsx)(r.code,{children:"stat.isFile()"})," 和 ",(0,s.jsx)(r.code,{children:"stat.isDirectory()"})," 来判断是文件还是文件夹。"]}),"\n",(0,s.jsxs)(r.h2,{id:"创建文件夹",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#创建文件夹",children:"#"}),"创建文件夹"]}),"\n",(0,s.jsxs)(r.p,{children:["在 Node.js 中，",(0,s.jsx)(r.code,{children:"fs.mkdir"})," 和 ",(0,s.jsx)(r.code,{children:"fs.mkdirSync"})," 方法用于创建文件夹。在调用这些方法时，需要指定需要创建的文件夹路径。如果在该路径中的某些目录不存在时，则会抛出一个错误。例如，如果我们要创建目录 ",(0,s.jsx)(r.code,{children:"./a/b/c/d"}),"，但是 ",(0,s.jsx)(r.code,{children:"./a/b"})," 这个目录不存在，就会出现错误。"]}),"\n",(0,s.jsxs)(r.p,{children:["为了解决这个问题，Node.js 从 10.x 版本开始增加了 ",(0,s.jsx)(r.code,{children:"recursive"})," 配置参数，它用于控制是否按需创建父文件夹。当该配置参数为 true 时，如果目标路径中的某些目录不存在，则会自动递归创建这些目录。如果设置为 false 或者不设置这个参数，则会抛出一个错误。"]}),"\n",(0,s.jsxs)(r.h2,{id:"复制文件",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#复制文件",children:"#"}),"复制文件"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const fs = require('fs')\r\nconst path = require('path')\r\n\r\n/**\r\n * @description 复制源路径下的文件或者文件夹到目标路径\r\n * @param {string} src 源路径\r\n * @param {string} dest 目标路径\r\n */\r\nfunction copy(src, dest) {\r\n  const stat = fs.statSync(src)\r\n  if (stat.isFile()) {\r\n    // 如果是文件，则创建读取流和写入流进行复制\r\n    const readStream = fs.createReadStream(src)\r\n    const writeStream = fs.createWriteStream(dest)\r\n    readStream.pipe(writeStream)\r\n  } else if (stat.isDirectory()) {\r\n    // 如果是文件夹，则先创建目标文件夹，然后递归调用 copy 函数复制文件夹下的所有内容\r\n    fs.mkdirSync(dest, { recursive: true })\r\n    const files = fs.readdirSync(src)\r\n    files.forEach(file => {\r\n      const fileSrc = path.join(src, file)\r\n      const fileDest = path.join(dest, file)\r\n      copy(fileSrc, fileDest)\r\n    })\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(r.p,{children:"使用 Promise 的方式改写："}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const fs = require('fs')\r\nconst path = require('path')\r\n\r\nfunction copy(src, dest) {\r\n  return new Promise((resolve, reject) => {\r\n    const stat = fs.statSync(src)\r\n    if (stat.isFile()) {\r\n      // 如果是文件，则创建读取流和写入流进行复制\r\n      const readStream = fs.createReadStream(src)\r\n      const writeStream = fs.createWriteStream(dest)\r\n      readStream.pipe(writeStream)\r\n      readStream.on('error', reject)\r\n      writeStream.on('error', reject)\r\n      writeStream.on('finish', resolve)\r\n    } else if (stat.isDirectory()) {\r\n      // 如果是文件夹，则先创建目标文件夹，然后递归调用 copy 函数复制文件夹下的内容\r\n      fs.mkdir(dest, { recursive: true }, err => {\r\n        if (err) {\r\n          reject(err)\r\n        }\r\n        const files = fs.readdirSync(src)\r\n        return Promise.all(\r\n          files.map(file => {\r\n            const fileSrc = path.join(src, file)\r\n            const fileDest = path.join(dest, file)\r\n            return copy(fileSrc, fileDest)\r\n          })\r\n        ).then(() => resolve())\r\n        .catch(reject)\r\n      })\r\n    }\r\n  })\r\n}\n"})}),"\n",(0,s.jsxs)(r.h2,{id:"nodejs-相对路径变为绝对路径",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#nodejs-相对路径变为绝对路径",children:"#"}),"Node.js 相对路径变为绝对路径"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-js",meta:"",children:"const path = require('path');\r\n\r\nconst relativePath = './example.js';\r\nconst absolutePath = path.resolve(relativePath);\r\n\r\nconsole.log(absolutePath); // 输出转换后的绝对路径\n"})}),"\n",(0,s.jsxs)(r.section,{"data-footnotes":!0,className:"footnotes",children:[(0,s.jsxs)(r.h2,{className:"sr-only",id:"footnote-label",children:[(0,s.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#footnote-label",children:"#"}),"Footnotes"]}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{id:"user-content-fn-2",children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.a,{href:"https://www.nodeapp.cn/stream.html#stream_types_of_streams",target:"_blank",rel:"noopener noreferrer",children:"流（Stream）| Node.js 中文文档"})," ",(0,s.jsx)(r.a,{href:"#user-content-fnref-2","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content",children:"↩"})]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{id:"user-content-fn-3",children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.a,{href:"https://heptaluan.github.io/2019/10/09/Node/01/#%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB",target:"_blank",rel:"noopener noreferrer",children:"Node.js 中的 Stream（流）"})," ",(0,s.jsx)(r.a,{href:"#user-content-fnref-3","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content",children:"↩"})]}),"\n"]}),"\n",(0,s.jsxs)(r.li,{id:"user-content-fn-4",children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.a,{href:"https://nodejs.cn/api/path/path_parse_path.html",target:"_blank",rel:"noopener noreferrer",children:"path.parse(path) | Node.js API"})," ",(0,s.jsx)(r.a,{href:"#user-content-fnref-4","data-footnote-backref":!0,className:"data-footnote-backref","aria-label":"Back to content",children:"↩"})]}),"\n"]}),"\n"]}),"\n"]})]})}function i(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,t.ah)(),e.components);return r?(0,s.jsx)(r,Object.assign({},e,{children:(0,s.jsx)(d,e)})):d(e)}let o=i;i.__RSPRESS_PAGE_META={},i.__RSPRESS_PAGE_META["docs%2Fnodejs%2F01-file.md"]={toc:[{id:"管道流",text:"管道流",depth:2},{id:"node-的四种流类型",text:"Node 的四种流类型",depth:2},{id:"nodejs-文件操作",text:"Node.js 文件操作",depth:2},{id:"流操作是异步的",text:"流操作是异步的",depth:2},{id:"判断是文件还是文件夹",text:"判断是文件还是文件夹",depth:2},{id:"创建文件夹",text:"创建文件夹",depth:2},{id:"复制文件",text:"复制文件",depth:2},{id:"nodejs-相对路径变为绝对路径",text:"Node.js 相对路径变为绝对路径",depth:2}],title:"文件",frontmatter:{}}}}]);