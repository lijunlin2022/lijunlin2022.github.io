"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["9134"],{6881:function(n,e,l){l.r(e),l.d(e,{default:()=>o});var r=l("5893"),s=l("65");let i=l.p+"static/image/execution-sequence4.edebb819.png",c=l.p+"static/image/execution-sequence3.fc7c5c20.png",d=l.p+"static/image/execution-sequence2.31b70277.png",h=l.p+"static/image/execution-sequence1.b89e4222.png";function t(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol",img:"img",blockquote:"blockquote",pre:"pre",code:"code"},(0,s.ah)(),n.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.h1,{id:"执行顺序",children:["执行顺序",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#执行顺序",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"JavaScript 这门语言是单线程的，所有的任务需要排队，前一个任务结束，才会执行后一个任务。\r\nJavaScript 和 DOM 渲染共用同一个线程。（因为 JS 可修改 DOM 结构），如果 Javascript 的一个任务执行时间过长，就会造成 DOM 渲染被阻塞"}),"\n",(0,r.jsxs)(e.h2,{id:"同步和异步",children:["同步和异步",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#同步和异步",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"为了让 JS 在遇到等待（网络请求、定时任务）不能卡住，就出现了异步。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的，会阻塞代码执行"}),"\n",(0,r.jsx)(e.li,{children:"异步：不会阻塞代码执行，会将任务先放到一个任务队列中排队，当同步任务完成之后再执行"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"任务执行机制",children:["任务执行机制",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#任务执行机制",children:"#"})]}),"\n",(0,r.jsxs)(e.p,{children:["同步任务都在主线程上执行，形成一个",(0,r.jsx)(e.strong,{children:"执行栈"}),"，JS 执行时"]}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:["先执行",(0,r.jsx)(e.strong,{children:"执行栈中的同步任务"})]}),"\n",(0,r.jsx)(e.li,{children:"异步任务放入任务队列"}),"\n",(0,r.jsxs)(e.li,{children:["一旦执行栈中的所有同步任务执行完毕，系统会按次序读取",(0,r.jsx)(e.strong,{children:"任务队列"}),"中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈并开始执行"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["由于主线程不断的重复获得任务、执行任务、再获取任务再执行，所以这种机制称为",(0,r.jsx)(e.strong,{children:"事件循环"})]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(e.blockquote,{children:["\n",(0,r.jsx)(e.p,{children:"JS 的异步一般都是用回调函数实现, 这并不意味着回调函数就是异步"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"异步的典型代码",children:["异步的典型代码",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步的典型代码",children:"#"})]}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"console.log(1);\r\n\r\nsetTimeout(function() {\r\n    console.log(3);\r\n}, 1000);\r\n\r\nconsole.log(2);\r\n\r\n// 1\r\n// 2\r\n// 3\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"console.log(1);\r\n\r\nsetTimeout(function() {\r\n    console.log(3);\r\n}, 0);\r\n\r\nconsole.log(2);\r\n\r\n// 1\r\n// 2\r\n// 3\n"})}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:"console.log(1);\r\nsetTimeout(function () {\r\n    console.log(2);\r\n}, 1000);\r\nconsole.log(3);\r\nsetTimeout(function () {\r\n    console.log(4);\r\n}, 0);\r\nconsole.log(5);\r\n// 1\r\n// 3\r\n// 5\r\n// 4\r\n// 2\n"})}),"\n",(0,r.jsxs)(e.h2,{id:"异步应用场景",children:["异步应用场景",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#异步应用场景",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"前端："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"网咯请求，比如 ajax 图片加载"}),"\n",(0,r.jsx)(e.li,{children:"定时任务，比如 setTimeout"}),"\n"]}),"\n",(0,r.jsx)(e.p,{children:"后端："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"文件读取"}),"\n",(0,r.jsx)(e.li,{children:"数据库读取"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"event-loop-事件循环事件轮询",children:["event loop (事件循环/事件轮询)",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#event-loop-事件循环事件轮询",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"JavaScript 是单线程执行的，它的异步要基于回调来实现，event loop 就是异步回调的实现原理"}),"\n",(0,r.jsx)(e.p,{children:"如下图所示："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:d,alt:""})}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsx)(e.li,{children:"同步代码，一行一行放在 Call Stack 执行"}),"\n",(0,r.jsx)(e.li,{children:"遇到异步，会先记录下，等待时机（定时、网络请求等）"}),"\n",(0,r.jsx)(e.li,{children:"时机到了，异步任务就移动到 Callback Queue 中"}),"\n",(0,r.jsx)(e.li,{children:"如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作"}),"\n",(0,r.jsx)(e.li,{children:"轮询查找 Callback Queue，如果有任务则移动到 Call Stack 中执行"}),"\n",(0,r.jsx)(e.li,{children:"然后继续轮询查找"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"dom-渲染和-event-loop",children:["DOM 渲染和 event loop",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#dom-渲染和-event-loop",children:"#"})]}),"\n",(0,r.jsx)(e.p,{children:"先看一段代码："}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-javascript",children:'const htmlStr = "<p>这是一段文字</p>"\r\ndocument.body.innerHTML = htmlStr;\r\n\r\nconsole.log(htmlStr.length);\r\nalert("打印之后, 渲染之前");\n'})}),"\n",(0,r.jsx)(e.p,{children:"执行效果为："}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这是因为，JavaScript 是单线程的，而且和 DOM 渲染共用一个线程。"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"每次 Call Stack 清空（即每次轮询结束），即同步任务执行完"}),"\n",(0,r.jsx)(e.li,{children:"都是 DOM 重新渲染的机会，DOM 结构如有改变则会重新渲染"}),"\n",(0,r.jsx)(e.li,{children:"然后再去触发下一次 event loop"}),"\n"]}),"\n",(0,r.jsxs)(e.h2,{id:"宏任务与微任务的执行时间",children:["宏任务与微任务的执行时间",(0,r.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#宏任务与微任务的执行时间",children:"#"})]}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"宏任务"}),": DOM 渲染后触发，如 setTimeout"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.code,{children:"微任务"}),": DOM 渲染前触发，如 Promise"]}),"\n"]}),"\n",(0,r.jsxs)(e.p,{children:["当",(0,r.jsx)(e.code,{children:"微任务"}),"执行时，它不会经过 Web APIs，而是处于另外一个队列中，即 ",(0,r.jsx)(e.code,{children:"微队列"}),"，这也是我们之前就看过的图："]}),"\n",(0,r.jsx)(e.p,{children:(0,r.jsx)("img",{src:i,alt:""})}),"\n",(0,r.jsx)(e.p,{children:"这是因为："}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"微任务是 ES6 语法规定的"}),"\n",(0,r.jsx)(e.li,{children:"宏任务是浏览器规定的"}),"\n"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(t,{...n})}):t(n)}let o=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["docs%2Fjs%2F11-%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%2F01-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.md"]={toc:[{text:"同步和异步",id:"同步和异步",depth:2},{text:"任务执行机制",id:"任务执行机制",depth:2},{text:"异步的典型代码",id:"异步的典型代码",depth:2},{text:"异步应用场景",id:"异步应用场景",depth:2},{text:"event loop (事件循环/事件轮询)",id:"event-loop-事件循环事件轮询",depth:2},{text:"DOM 渲染和 event loop",id:"dom-渲染和-event-loop",depth:2},{text:"宏任务与微任务的执行时间",id:"宏任务与微任务的执行时间",depth:2}],title:"执行顺序",frontmatter:{}}}}]);