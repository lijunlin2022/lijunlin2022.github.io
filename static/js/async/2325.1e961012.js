"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["2325"],{71189:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var s=r("85893"),i=r("50065");let c=r.p+"static/image/get-all-files.43713b6b.png",t=r.p+"static/image/components.7dd7f055.png",h=r.p+"static/image/this.is.34c7db71.png";function o(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ol:"ol",li:"li",code:"code",img:"img",h3:"h3",pre:"pre"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"小程序如何检测无流量组件分享一种打点检测方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小程序如何检测无流量组件分享一种打点检测方法",children:"#"}),"小程序如何检测无流量组件？分享一种打点检测方法"]}),"\n",(0,s.jsx)(e.p,{children:"小程序项目经过长期迭代后，内部会有大量组件。其中有些组件，虽然在页面、组件的 json 中注册了，但实际不会用到，白白占用了小程序的包体积。这种无流量组件该如何检测呢？"}),"\n",(0,s.jsx)(e.p,{children:"本文我会分享一种打点检测方法，它可以较低成本地找出所有无流量的组件。"}),"\n",(0,s.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,s.jsxs)(e.h2,{id:"思路",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路",children:"#"}),"思路"]}),"\n",(0,s.jsx)(e.p,{children:"我的整体思路分为三个步骤："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"遍历目录，获取全体组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"给组件打点，获取有流量组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"取全体组件和有流量组件的差集。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下面我会向你介绍三个步骤的细节。"}),"\n",(0,s.jsxs)(e.h2,{id:"步骤一获取全体组件集合",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤一获取全体组件集合",children:"#"}),"步骤一：获取全体组件集合"]}),"\n",(0,s.jsxs)(e.p,{children:["小程序的组件由 wxml、wxss、js 和 json 等文件组成，其中 json 文件总是有 ",(0,s.jsx)(e.code,{children:'"component": true'})," 这一项。根据这个特点，你可以分两步获取全体组件的集合。"]}),"\n",(0,s.jsx)(e.p,{children:"第一步是获取所有文件，第二步则是找到满足特点的 json 文件，该 json 文件就代表了一个组件。"}),"\n",(0,s.jsx)(e.p,{children:"为了方便你理解，我现在新建一个项目，项目目录结构如下，src 中是一个小程序的项目代码，它的 components 中有 3 个组件 comp-1、comp-2、comp-3，其中 comp-1 和 comp-2 同级，comp-3 则是 comp-1 的子级。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:c})}),"\n",(0,s.jsx)(e.p,{children:"bin 目录中，是我获取 src 全体组件的脚本，脚本的两个函数刚好对应之前说的 2 个步骤。"}),"\n",(0,s.jsxs)(e.h3,{id:"函数一获取-src-目录的所有文件路径",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数一获取-src-目录的所有文件路径",children:"#"}),"函数一：获取 src 目录的所有文件路径"]}),"\n",(0,s.jsx)(e.p,{children:"第一个步骤对应 getAllFiles 函数。在函数中，我会利用栈来获取所有文件的路径。"}),"\n",(0,s.jsx)(e.p,{children:"我会给 getAllFiles() 传入 src 的路径，开始时，函数会读取 src 内的文件和文件夹。如果我发现读到了一个文件夹，就把它压入栈 stack 中；如果我发现读到了一个文件，就把文件路径记录到 result 中。"}),"\n",(0,s.jsx)(e.p,{children:"之后，我会从栈底部取出一个文件夹，继续重复读到文件夹就压入栈中，读到文件就记录到 result 的过程。直到栈内再也没有文件夹为止。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const fs = require('fs');\r\nconst path = require('path');\r\n\r\nfunction getAllFiles(dir) {\r\n  const results = [];\r\n  const stack = [dir];\r\n\r\n  while (stack.length) {\r\n    const currentDir = stack.pop();\r\n    const list = fs.readdirSync(currentDir);\r\n\r\n    list.forEach(file => {\r\n      const filePath = path.resolve(currentDir, file);\r\n      const stat = fs.statSync(filePath);\r\n\r\n      if (stat && stat.isDirectory()) {\r\n        stack.push(filePath);\r\n      } else {\r\n        results.push(filePath);\r\n      }\r\n    });\r\n  }\r\n\r\n  return results;\r\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"函数二找到-json判断-json-是否能代表组件",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#函数二找到-json判断-json-是否能代表组件",children:"#"}),"函数二：找到 json，判断 json 是否能代表组件"]}),"\n",(0,s.jsx)(e.p,{children:"第二个步骤对应函数 isComponent。在第一步的基础上，我会先筛选出所有 json 文件，然后把每个 json 文件转变为 json 对象，看看它们内部是否有 一项是 component，且值为 true。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"function isComponent(filePath) {\r\n  if (!filePath.endsWith('.json')) {\r\n    return false\r\n  }\r\n\r\n  const jsonContent = fs.readFileSync(filePath, 'utf8');\r\n  const jsonObj = JSON.parse(jsonContent);\r\n  return jsonObj.component === true;\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"结合上述两段代码，就可以获得小程序组件的全集。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:t})}),"\n",(0,s.jsxs)(e.h2,{id:"步骤二获取有流量组件集合",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤二获取有流量组件集合",children:"#"}),"步骤二：获取有流量组件集合"]}),"\n",(0,s.jsx)(e.p,{children:"获取有流量的组件，你可能想到的方式，就是在每一个组件的生命周期里打点——组件挂载在页面时，就把组件路径上报到后台，有记录的组件就是有流量的组件。"}),"\n",(0,s.jsxs)(e.p,{children:["刚好，在组件运行时，可以直接在生命周期里用 ",(0,s.jsx)(e.code,{children:"this.is"})," 获取组件路径。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.img,{src:h})}),"\n",(0,s.jsx)(e.p,{children:"不过，如果给所有组件直接插入代码打点，工作量会非常庞大。"}),"\n",(0,s.jsxs)(e.h3,{id:"初次改进behavior-插入打点",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#初次改进behavior-插入打点",children:"#"}),"初次改进：Behavior 插入打点"]}),"\n",(0,s.jsx)(e.p,{children:"我想到的第一个优化方法是，小程序可以利用 Behavior 来给生命周期插入打点逻辑。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const myBehavior = Behavior({\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> my behavior')\r\n    }\r\n  }\r\n})\r\n\r\nComponent({\r\n  behaviors: [myBehavior],\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> normal behavior')\r\n    }\r\n  }\r\n})\r\n\r\n// 输出\r\n// >>>>> my behavior\r\n// >>>>> normal behavior\n"})}),"\n",(0,s.jsx)(e.p,{children:"不过这个思路有缺陷，如果有人新增组件，可能会忘记在 behaviors 中注册 myBehavior，为此，我需要改进这个方法。"}),"\n",(0,s.jsxs)(e.h3,{id:"再次改进用-enhancecomponent-函数替换所有的-component-函数",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#再次改进用-enhancecomponent-函数替换所有的-component-函数",children:"#"}),"再次改进：用 enhanceComponent 函数替换所有的 Component 函数"]}),"\n",(0,s.jsx)(e.p,{children:"我改进的思路，是先编写一个 enhanceComponent 函数，它是一个构建组件的函数，且 behaviors 里面已经插入了打点。之后我在构建时，把每一个 Component 函数，替换为 enhanceComponent 函数。"}),"\n",(0,s.jsx)(e.p,{children:"这样就不需要新开发组件的同学，特意去记录加 behaviors 的逻辑。"}),"\n",(0,s.jsx)(e.p,{children:"我编写的 enhanceCompnent 如下，我会把这个函数放在 src 内的 utils 目录："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const enhanceBehavior = Behavior({\r\n  lifetimes: {\r\n    attached: function () {\r\n      console.log('enhance component >>>>>: ', this.is)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports.enhanceComponent = function (config) {\r\n  const { behaviors = [], ...params } = config || {}\r\n  return Component({\r\n    behaviors: [enhanceBehavior, ...behaviors],\r\n    ...params,\r\n  })\r\n}\n"})}),"\n",(0,s.jsxs)(e.p,{children:["我构建时替换 Component 函数的关键代码如下，我会把 ",(0,s.jsx)(e.code,{children:"Component("})," 替换为 ",(0,s.jsx)(e.code,{children:"require('@utils/enhance-component.js').enhanceComponent("}),"，其中 ",(0,s.jsx)(e.code,{children:"@utils"})," 是在小程序 app.json 配置的",(0,s.jsx)(e.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#resolveAlias",target:"_blank",rel:"noopener noreferrer",children:"别名"}),"，方便小程序内部引用文件："]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"function replaceComponentFunction(filePath) {\r\n  const fileContent = fs.readFileSync(filePath, 'utf8');\r\n  const newContent = fileContent.replace(\r\n    /\\bComponent\\(/g,\r\n    \"require('@utils/enhance-component.js').enhanceComponent(\"\r\n  );\r\n  fs.writeFileSync(filePath, newContent, 'utf8');\r\n}\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"步骤三取全体组件和有流量组件差集",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#步骤三取全体组件和有流量组件差集",children:"#"}),"步骤三：取全体组件和有流量组件差集"]}),"\n",(0,s.jsx)(e.p,{children:"经过之前的处理，我们不难得到全体组件的数组，有流量组件的数组。接下来我们只需要获得它们的差集即可："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const arr1 = ['a', 'b', 'c', 'd', 'e']\r\nconst arr2 = ['a', 'b', 'e']\r\n\r\nconst diff = arr1.filter(item => !arr2.includes(item))\r\n\r\nconsole.log(diff) // ['c', 'd']\n"})}),"\n",(0,s.jsx)(e.p,{children:"之后，我们就可以酌情删除这些无流量的组件，减少包体积了。"}),"\n",(0,s.jsxs)(e.h2,{id:"总结",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,s.jsx)(e.p,{children:"本文我会分享一种打点检测方法，它可以较低成本地找出所有无流量的组件。"}),"\n",(0,s.jsx)(e.p,{children:"我的整体思路分为三个步骤："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"遍历目录，获取全体组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"给组件打点，获取有流量组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"取全体组件和有流量组件的差集。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(o,n)})):o(n)}let l=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["zh%2Fblog%2F2024%2F12%2F04%2Findex.md"]={toc:[{id:"思路",text:"思路",depth:2},{id:"步骤一获取全体组件集合",text:"步骤一：获取全体组件集合",depth:2},{id:"函数一获取-src-目录的所有文件路径",text:"函数一：获取 src 目录的所有文件路径",depth:3},{id:"函数二找到-json判断-json-是否能代表组件",text:"函数二：找到 json，判断 json 是否能代表组件",depth:3},{id:"步骤二获取有流量组件集合",text:"步骤二：获取有流量组件集合",depth:2},{id:"初次改进behavior-插入打点",text:"初次改进：Behavior 插入打点",depth:3},{id:"再次改进用-enhancecomponent-函数替换所有的-component-函数",text:"再次改进：用 enhanceComponent 函数替换所有的 Component 函数",depth:3},{id:"步骤三取全体组件和有流量组件差集",text:"步骤三：取全体组件和有流量组件差集",depth:2},{id:"总结",text:"总结",depth:2}],title:"小程序如何检测无流量组件？分享一种打点检测方法",frontmatter:{}}}}]);