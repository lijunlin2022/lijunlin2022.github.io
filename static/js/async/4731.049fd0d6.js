"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["4731"],{23467:function(n,e,r){r.r(e),r.d(e,{default:function(){return o}});var s=r(85893),t=r(50065),i=r(95895);function a(n){let e=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ol:"ol",li:"li",code:"code",pre:"pre"},(0,t.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h1,{id:"小程序如何检测无流量组件分享一种打点检测方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#小程序如何检测无流量组件分享一种打点检测方法",children:"#"}),"小程序如何检测无流量组件？分享一种打点检测方法"]}),"\n",(0,s.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsx)(e.p,{children:"小程序项目经过长期迭代后，内部会有大量组件。其中有些组件，虽然在页面、组件的 json 中注册了，但实际不会用到（无流量），白白占用了小程序的包体积。这种无流量组件该如何检测呢？"}),"\n",(0,s.jsx)(e.p,{children:"本文我分享一种打点检测方法，它可以较低成本低找出所有无流量的组件。"}),"\n",(0,s.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,s.jsxs)(e.h2,{id:"思路",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#思路",children:"#"}),"思路"]}),"\n",(0,s.jsx)(e.p,{children:"我的整体思路分为三部分："}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"遍历目录，获取全体组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"给组件打点，获取有流量组件的集合；"}),"\n",(0,s.jsx)(e.li,{children:"取全体组件和有流量组件的差集。"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"下面我会向你介绍三部分的细节。"}),"\n",(0,s.jsxs)(e.h2,{id:"获取全体组件集合",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#获取全体组件集合",children:"#"}),"获取全体组件集合"]}),"\n",(0,s.jsxs)(e.p,{children:["小程序的组件由 wxml、wxss、js 和 json 等文件组成，其中 json 文件总是有 ",(0,s.jsx)(e.code,{children:'"component": true'})," 这一项。"]}),"\n",(0,s.jsxs)(e.p,{children:["根据这个特点，我们可以遍历项目中的所有文件，如果有 json 文件，并且 json 文件中有 ",(0,s.jsx)(e.code,{children:'"component": true'})," 这一项，则认为该 json 文件代表一个组件。"]}),"\n",(0,s.jsx)(e.p,{children:"主要有两个关键代码："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 遍历项目中所有文件\r\nconst fs = require('fs');\r\nconst path = require('path');\r\n\r\n// 目标文件夹路径\r\nconst targetDir = './';\r\n\r\n// 使用栈读取文件夹中的所有文件\r\nfunction readDirWithStack(dir) {\r\n  let results = [];\r\n  let stack = [dir];\r\n\r\n  while (stack.length) {\r\n    const currentDir = stack.pop();\r\n    const list = fs.readdirSync(currentDir);\r\n\r\n    list.forEach(file => {\r\n      const filePath = path.resolve(currentDir, file);\r\n      const stat = fs.statSync(filePath);\r\n\r\n      if (stat && stat.isDirectory()) {\r\n        stack.push(filePath);\r\n      } else {\r\n        results.push(filePath);\r\n      }\r\n    });\r\n  }\r\n\r\n  return results;\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"其中，result 是用于存储所有文件路径的数组，stack 则是用来完成工作的栈。初始情况下，stack 内部是根目录，我们开始读取根目录中的所有文件和子目录；"}),"\n",(0,s.jsx)(e.p,{children:"我们利用 fs.statSyc 获取文件状态信息 stat，如果 stat.isDirectory() 为 true，证明它是一个目录，把它压入栈中，以便之后处理"}),"\n",(0,s.jsx)(e.p,{children:"如果为 false，证明它是一个文件，就放到 result 数组中"}),"\n",(0,s.jsx)(e.p,{children:"我们会不断从栈中取出目录读取文件，直到栈中再也没有目录，这样就实现了获取所有文件路径的功能"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 判断 json 是否能代表组件\r\nfunction isComponent(filePath) {\r\n  const dir = path.dirname(filePath);\r\n  const files = fs.readdirSync(dir);\r\n  const jsonFile = files.find(file => file.endsWith('.json'));\r\n  if (jsonFile) {\r\n    const jsonFilePath = path.join(dir, jsonFile);\r\n    const jsonContent = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));\r\n    return jsonContent.component === true;\r\n  }\r\n  return false;\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"结合上述两段代码，我们可以获得小程序组件的全集。"}),"\n",(0,s.jsxs)(e.h2,{id:"获取有流量组件的集合",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#获取有流量组件的集合",children:"#"}),"获取有流量组件的集合"]}),"\n",(0,s.jsx)(e.p,{children:"在每一个组件的生命周期里打点，如果走到组件生命周期，就上报一条记录，有记录的组件就是有流量的组件。"}),"\n",(0,s.jsx)(e.p,{children:"不过，如果给所有组件直接插入代码打点，工作量会非常庞大。"}),"\n",(0,s.jsx)(e.p,{children:"你可能想到的第一个优化方法是，小程序可以利用 Behavior 来给生命周期插入一段逻辑。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const myBehavior = Behavior({\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> my behavior')\r\n    }\r\n  }\r\n})\r\n\r\nComponent({\r\n  behaviors: [myBehavior],\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> normal behavior')\r\n    }\r\n  }\r\n})\r\n\r\n// 输出\r\n// >>>>> my behavior\r\n// >>>>> normal behavior\n"})}),"\n",(0,s.jsx)(e.p,{children:"它的缺陷则是，：如果有人新增组件，可能会忘记在 behaviors 中注册 myBehavior，为此，我们需要改进这个方法。"}),"\n",(0,s.jsx)(e.p,{children:"改进的思路是，用一个 enhanceComponent 函数替换所有的 Component 函数。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const enhanceBehavior = Behavior({\r\n  lifetimes: {\r\n    attached: function () {\r\n      console.log('enhance component >>>>>: ', this.is)\r\n    }\r\n  }\r\n})\r\n\r\n// 导出的 enhanceComponent 函数，默认就注册了 enhanceBehavior，enhanceBehavior 中我们可以打点\r\nmodule.exports.enhanceComponent = function (config) {\r\n  const { behaviors = [], ...params } = config || {}\r\n  return Component({\r\n    behaviors: [enhanceBehavior, ...behaviors],\r\n    ...params,\r\n  })\r\n}\n"})}),"\n",(0,s.jsx)(e.p,{children:"使用 enhanceComponent 后，组件的 js 变成："}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"require('../../utils/enhance-component').enhanceComponent({\r\n  properties: {},\r\n  data: {},\r\n  methods: {}\r\n})\n"})}),"\n",(0,s.jsx)(e.p,{children:"在组件 js 文件中，不使用 Component 函数创建组件，而是使用 enhanceComponent 函数"}),"\n",(0,s.jsx)(e.p,{children:"这样依然有缺陷，如果有人新增组件时，忘记引入 enhanceComponent 函数，那么这个组件就不会被上报"}),"\n",(0,s.jsx)(e.p,{children:"最好的办法是，我们能够在构建时，将 Component 函数替换为 enhanceComponent 函数。"}),"\n",(0,s.jsx)(e.p,{children:"替换之前，我们需要解决一个问题，那就是路径问题，所幸小程序已经可以通过设置别名。"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.a,{href:"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#resolveAlias",target:"_blank",rel:"noopener noreferrer",children:"https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#resolveAlias"})}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"// 替换 Component 函数\r\nfunction replaceComponentFunction(filePath) {\r\n  const fileContent = fs.readFileSync(filePath, 'utf8');\r\n  const newContent = fileContent.replace(\r\n    /\\bComponent\\(/g,\r\n    \"require('@utils/enhance-component.js').enhanceComponent(\"\r\n  );\r\n  fs.writeFileSync(filePath, newContent, 'utf8');\r\n}\r\n\r\n// 获取所有 .js 文件\r\nconst files = readDirWithStack(targetDir).filter(file => file.endsWith('.js'));\r\n\r\n// 替换每个文件中的 Component 函数\r\nfiles.forEach(file => {\r\n  if (isComponent(file)) {\r\n    replaceComponentFunction(file);\r\n  }\r\n});\n"})}),"\n",(0,s.jsxs)(e.h2,{id:"取全体组件和有流量组件的差集",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#取全体组件和有流量组件的差集",children:"#"}),"取全体组件和有流量组件的差集"]}),"\n",(0,s.jsx)(e.p,{children:"经过之前的处理，我们已经获取了全体组件的集合，也获取了有流量组件的集合。"}),"\n",(0,s.jsx)(e.p,{children:"它们都可以用数组来表示。因此我们其中需要做的，就是取两个数组的差集。"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",meta:"",children:"const arr1 = ['a', 'b', 'c', 'd', 'e']\r\nconst arr2 = ['a', 'b', 'e']\r\n\r\nconst diff = arr1.filter(item => !arr2.includes(item))\r\n\r\nconsole.log(diff) // ['c', 'd']\n"})})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(a,n)})):a(n)}let o=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["blog%2F2024%2F12%2F04%2Findex.md"]={toc:[{id:"思路",text:"思路",depth:2},{id:"获取全体组件集合",text:"获取全体组件集合",depth:2},{id:"获取有流量组件的集合",text:"获取有流量组件的集合",depth:2},{id:"取全体组件和有流量组件的差集",text:"取全体组件和有流量组件的差集",depth:2}],title:"小程序如何检测无流量组件？分享一种打点检测方法",frontmatter:{}}},95895:function(n,e,r){r.d(e,{Z:function(){return o}});var s=r(85893),t=r(67294),i=r(45687);r(6175);let a={"zh-CN":n=>`预计阅读时间: ${n.minutes>=1?`${Math.ceil(n.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function c(n,e,r){let s=Object.keys(a).includes(e)?e:r;return a[s](n)}let o=n=>{let{defaultLocale:e="en-US"}=n,r=(0,i.Vi)().page.readingTimeData,a=(0,i.Jr)(),o=(0,i.e7)(),[l,h]=(0,t.useState)(c(r,a,e));return(0,t.useEffect)(()=>{h(c(r,a,e))},[a,r]),(0,s.jsx)("span",{"data-dark":String(o),className:"rp-reading-time",children:l})}}}]);