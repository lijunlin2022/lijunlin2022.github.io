"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["3969"],{52598:function(n,e,r){r.r(e),r.d(e,{default:function(){return c}});var t=r(85893),s=r(50065),i=r(95895);function o(n){let e=Object.assign({p:"p",code:"code",pre:"pre"},(0,s.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n","\n","\n",(0,t.jsx)(e.p,{children:"标题：小程序无用组件检测如何设计？"}),"\n",(0,t.jsx)(e.p,{children:"背景：小程序组件越来越多，且被页面引用，但是实际由于实验完全没有用到，应该怎么检查。"}),"\n",(0,t.jsx)(e.p,{children:"思路：首先获取全体组件名单，然后获取有流量的组件的名单，二者相减后，就得到了无流量的组件。"}),"\n",(0,t.jsxs)(e.p,{children:["获得全体组件名单思路：微信小程序组件基础文件有 4 个，wxml、wxss、js 和 json，其中组件的 json 中，总是有 ",(0,t.jsx)(e.code,{children:'"component": true'})," 这个属性。你可以扫描所有的文件夹，如果文件夹内部有 json，且 json 内部有 ",(0,t.jsx)(e.code,{children:'"component": true'}),"，则和它同名的 wxml 文件就可以认定为一个组件。"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const fs = require('fs');\r\nconst path = require('path');\r\n\r\n// 目标文件夹路径\r\nconst targetDir = './';\r\n\r\n// 使用栈读取文件夹中的所有文件\r\nfunction readDirWithStack(dir) {\r\n  let results = [];\r\n  let stack = [dir];\r\n\r\n  while (stack.length) {\r\n    const currentDir = stack.pop();\r\n    const list = fs.readdirSync(currentDir);\r\n\r\n    list.forEach(file => {\r\n      const filePath = path.resolve(currentDir, file);\r\n      const stat = fs.statSync(filePath);\r\n\r\n      if (stat && stat.isDirectory()) {\r\n        stack.push(filePath);\r\n      } else {\r\n        results.push(filePath);\r\n      }\r\n    });\r\n  }\r\n\r\n  console.log(results)\r\n  return results;\r\n}\r\n\r\n// 判断是否为组件\r\nfunction isComponent(filePath) {\r\n  const dir = path.dirname(filePath);\r\n  const files = fs.readdirSync(dir);\r\n  const jsonFile = files.find(file => file.endsWith('.json'));\r\n  if (jsonFile) {\r\n    const jsonFilePath = path.join(dir, jsonFile);\r\n    const jsonContent = JSON.parse(fs.readFileSync(jsonFilePath, 'utf8'));\r\n    return jsonContent.component === true;\r\n  }\r\n  return false;\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"获取有流量组件名单思路：给每一个组件打点，如果组件走到 attached 生命周期，就上报一条记录，最后就能得到所有有流量的组件。"}),"\n",(0,t.jsx)(e.p,{children:"不过，如果给所有组件直接插入代码打点，工作量会非常庞大，如果有人新增组件，也可能忘记这条逻辑，所有我们需要其他方式。"}),"\n",(0,t.jsx)(e.p,{children:"介绍这个方式前，我先介绍一些小程序中，behavior 的概念。小程序中可以利用 Behavior 给组件生命周期内插入一段逻辑。"}),"\n",(0,t.jsx)(e.p,{children:"基础用法为："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const myBehavior = Behavior({\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> my behavior')\r\n    }\r\n  }\r\n})\r\n\r\nComponent({\r\n  behaviors: [myBehavior],\r\n  lifetimes: {\r\n    attached() {\r\n      console.log('>>>>> normal behavior')\r\n    }\r\n  }\r\n})\n"})}),"\n",(0,t.jsx)(e.p,{children:"这种方法类似 Vue 的 mixin 或 React 的 HOC，之后小程序会把 Behavior 和 Component 组件的生命周期融合。"}),"\n",(0,t.jsx)(e.p,{children:"替换生命周期"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"// 替换 Component 函数\r\nfunction replaceComponentFunction(filePath) {\r\n  const fileContent = fs.readFileSync(filePath, 'utf8');\r\n  const newContent = fileContent.replace(\r\n    /\\bComponent\\(/g,\r\n    \"require('@utils/enhance-component.js').enhanceComponent(\"\r\n  );\r\n  fs.writeFileSync(filePath, newContent, 'utf8');\r\n}\r\n\r\n// 获取所有 .js 文件\r\nconst files = readDirWithStack(targetDir).filter(file => file.endsWith('.js'));\r\n\r\n// 替换每个文件中的 Component 函数\r\nfiles.forEach(file => {\r\n  if (isComponent(file)) {\r\n    replaceComponentFunction(file);\r\n  }\r\n});\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const enhanceBehavior = Behavior({\r\n  lifetimes: {\r\n    attached: function () {\r\n      console.log('enhance component >>>>>: ', this.is)\r\n    }\r\n  }\r\n})\r\n\r\nmodule.exports.enhanceComponent = function (config) {\r\n  const { behaviors = [], ...params } = config || {}\r\n  return Component({\r\n    behaviors: [enhanceBehavior, ...behaviors],\r\n    ...params,\r\n  })\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"result 是用于存储所有文件路径的数组，stack 则是用来完成工作的栈"}),"\n",(0,t.jsx)(e.p,{children:"初始情况下，stack 内部是根目录，我们开始读取根目录中的所有文件和子目录；"}),"\n",(0,t.jsx)(e.p,{children:"我们利用 fs.statSyc 获取文件状态信息 stat，如果 stat.isDirectory() 为 true，证明它是一个目录，把它压入栈中，以便之后处理"}),"\n",(0,t.jsx)(e.p,{children:"如果为 false，证明它是一个文件，就放到 result 数组中"}),"\n",(0,t.jsx)(e.p,{children:"我们会不断从栈中取出目录读取文件，直到栈中再也没有目录，这样就实现了获取所有文件路径的功能"})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(o,n)})):o(n)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["blog%2F2024%2F11%2F25%2Foutline.md"]={toc:[],title:"",frontmatter:{}}},95895:function(n,e,r){r.d(e,{Z:function(){return c}});var t=r(85893),s=r(67294),i=r(45687);r(6175);let o={"zh-CN":n=>`预计阅读时间: ${n.minutes>=1?`${Math.ceil(n.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function a(n,e,r){let t=Object.keys(o).includes(e)?e:r;return o[t](n)}let c=n=>{let{defaultLocale:e="en-US"}=n,r=(0,i.Vi)().page.readingTimeData,o=(0,i.Jr)(),c=(0,i.e7)(),[l,h]=(0,s.useState)(a(r,o,e));return(0,s.useEffect)(()=>{h(a(r,o,e))},[o,r]),(0,t.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:l})}}}]);