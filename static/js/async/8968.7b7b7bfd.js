"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["8968"],{98215:function(e,n,r){r.r(n),r.d(n,{default:()=>x});var s=r("85893"),l=r("50065"),i=r("95895");let c=r.p+"static/image/execution-sequence1.b89e4222.png",t=r.p+"static/image/execution-sequence2.31b70277.png",d=r.p+"static/image/execution-sequence3.fc7c5c20.png",a=r.p+"static/image/execution-sequence4.edebb819.png";function h(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",ul:"ul",li:"li",strong:"strong",ol:"ol",img:"img",blockquote:"blockquote",pre:"pre",code:"code"},(0,l.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"执行顺序",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#执行顺序",children:"#"}),"执行顺序"]}),"\n",(0,s.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsx)(n.p,{children:"JavaScript 这门语言是单线程的，所有的任务需要排队，前一个任务结束，才会执行后一个任务。\r\nJavaScript 和 DOM 渲染共用同一个线程。（因为 JS 可修改 DOM 结构），如果 Javascript 的一个任务执行时间过长，就会造成 DOM 渲染被阻塞"}),"\n",(0,s.jsxs)(n.h2,{id:"同步和异步",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#同步和异步",children:"#"}),"同步和异步"]}),"\n",(0,s.jsx)(n.p,{children:"为了让 JS 在遇到等待（网络请求、定时任务）不能卡住，就出现了异步。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"同步：前一个任务结束后再执行后一个任务，程序的执行顺序与任务的排列顺序是一致的，会阻塞代码执行"}),"\n",(0,s.jsx)(n.li,{children:"异步：不会阻塞代码执行，会将任务先放到一个任务队列中排队，当同步任务完成之后再执行"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"任务执行机制",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#任务执行机制",children:"#"}),"任务执行机制"]}),"\n",(0,s.jsxs)(n.p,{children:["同步任务都在主线程上执行，形成一个",(0,s.jsx)(n.strong,{children:"执行栈"}),"，JS 执行时"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["先执行",(0,s.jsx)(n.strong,{children:"执行栈中的同步任务"})]}),"\n",(0,s.jsx)(n.li,{children:"异步任务放入任务队列"}),"\n",(0,s.jsxs)(n.li,{children:["一旦执行栈中的所有同步任务执行完毕，系统会按次序读取",(0,s.jsx)(n.strong,{children:"任务队列"}),"中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈并开始执行"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["由于主线程不断的重复获得任务、执行任务、再获取任务再执行，所以这种机制称为",(0,s.jsx)(n.strong,{children:"事件循环"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:c})}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:"JS 的异步一般都是用回调函数实现, 这并不意味着回调函数就是异步"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"异步的典型代码",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步的典型代码",children:"#"}),"异步的典型代码"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"console.log(1);\r\n\r\nsetTimeout(function() {\r\n    console.log(3);\r\n}, 1000);\r\n\r\nconsole.log(2);\r\n\r\n// 1\r\n// 2\r\n// 3\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"console.log(1);\r\n\r\nsetTimeout(function() {\r\n    console.log(3);\r\n}, 0);\r\n\r\nconsole.log(2);\r\n\r\n// 1\r\n// 2\r\n// 3\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:"console.log(1);\r\nsetTimeout(function () {\r\n    console.log(2);\r\n}, 1000);\r\nconsole.log(3);\r\nsetTimeout(function () {\r\n    console.log(4);\r\n}, 0);\r\nconsole.log(5);\r\n// 1\r\n// 3\r\n// 5\r\n// 4\r\n// 2\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"异步应用场景",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#异步应用场景",children:"#"}),"异步应用场景"]}),"\n",(0,s.jsx)(n.p,{children:"前端："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"网咯请求，比如 ajax 图片加载"}),"\n",(0,s.jsx)(n.li,{children:"定时任务，比如 setTimeout"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"后端："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"文件读取"}),"\n",(0,s.jsx)(n.li,{children:"数据库读取"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"event-loop-事件循环事件轮询",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#event-loop-事件循环事件轮询",children:"#"}),"event loop (事件循环/事件轮询)"]}),"\n",(0,s.jsx)(n.p,{children:"JavaScript 是单线程执行的，它的异步要基于回调来实现，event loop 就是异步回调的实现原理"}),"\n",(0,s.jsx)(n.p,{children:"如下图所示："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:t})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"同步代码，一行一行放在 Call Stack 执行"}),"\n",(0,s.jsx)(n.li,{children:"遇到异步，会先记录下，等待时机（定时、网络请求等）"}),"\n",(0,s.jsx)(n.li,{children:"时机到了，异步任务就移动到 Callback Queue 中"}),"\n",(0,s.jsx)(n.li,{children:"如果 Call Stack 为空（即同步代码执行完），Event Loop 开始工作"}),"\n",(0,s.jsx)(n.li,{children:"轮询查找 Callback Queue，如果有任务则移动到 Call Stack 中执行"}),"\n",(0,s.jsx)(n.li,{children:"然后继续轮询查找"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"dom-渲染和-event-loop",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#dom-渲染和-event-loop",children:"#"}),"DOM 渲染和 event loop"]}),"\n",(0,s.jsx)(n.p,{children:"先看一段代码："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",meta:"",children:'const htmlStr = "<p>这是一段文字</p>"\r\ndocument.body.innerHTML = htmlStr;\r\n\r\nconsole.log(htmlStr.length);\r\nalert("打印之后, 渲染之前");\n'})}),"\n",(0,s.jsx)(n.p,{children:"执行效果为："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:d})}),"\n",(0,s.jsx)(n.p,{children:"这是因为，JavaScript 是单线程的，而且和 DOM 渲染共用一个线程。"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"每次 Call Stack 清空（即每次轮询结束），即同步任务执行完"}),"\n",(0,s.jsx)(n.li,{children:"都是 DOM 重新渲染的机会，DOM 结构如有改变则会重新渲染"}),"\n",(0,s.jsx)(n.li,{children:"然后再去触发下一次 event loop"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"宏任务与微任务的执行时间",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#宏任务与微任务的执行时间",children:"#"}),"宏任务与微任务的执行时间"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"宏任务"}),": DOM 渲染后触发，如 setTimeout"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"微任务"}),": DOM 渲染前触发，如 Promise"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["当",(0,s.jsx)(n.code,{children:"微任务"}),"执行时，它不会经过 Web APIs，而是处于另外一个队列中，即 ",(0,s.jsx)(n.code,{children:"微队列"}),"，这也是我们之前就看过的图："]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.img,{src:a})}),"\n",(0,s.jsx)(n.p,{children:"这是因为："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"微任务是 ES6 语法规定的"}),"\n",(0,s.jsx)(n.li,{children:"宏任务是浏览器规定的"}),"\n"]})]})}function o(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,l.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(h,e)})):h(e)}let x=o;o.__RSPRESS_PAGE_META={},o.__RSPRESS_PAGE_META["docs%2Fjs%2F%E6%9C%9F%E7%BA%A6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%2F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.md"]={toc:[{id:"同步和异步",text:"同步和异步",depth:2},{id:"任务执行机制",text:"任务执行机制",depth:2},{id:"异步的典型代码",text:"异步的典型代码",depth:2},{id:"异步应用场景",text:"异步应用场景",depth:2},{id:"event-loop-事件循环事件轮询",text:"event loop (事件循环/事件轮询)",depth:2},{id:"dom-渲染和-event-loop",text:"DOM 渲染和 event loop",depth:2},{id:"宏任务与微任务的执行时间",text:"宏任务与微任务的执行时间",depth:2}],title:"执行顺序",frontmatter:{}}},95895:function(e,n,r){r.d(n,{Z:function(){return d}});var s=r(85893),l=r(67294),i=r(45687);r(6175);let c={"zh-CN":e=>`预计阅读时间: ${e.minutes>=1?`${Math.ceil(e.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function t(e,n,r){let s=Object.keys(c).includes(n)?n:r;return c[s](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,r=(0,i.Vi)().page.readingTimeData,c=(0,i.Jr)(),d=(0,i.e7)(),[a,h]=(0,l.useState)(t(r,c,n));return(0,l.useEffect)(()=>{h(t(r,c,n))},[c,r]),(0,s.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:a})}}}]);