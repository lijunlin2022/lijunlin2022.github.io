"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["6799"],{35e3:function(n,e,r){r.r(e),r.d(e,{default:()=>A});var t=r("85893"),i=r("50065"),a=r("95895");let d=r.p+"static/image/settTimeout-random.dbbd7c6a.gif";function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",pre:"pre",code:"code",h2:"h2"},(0,i.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"h5-先发出的请求后返回应该怎么办-请求竞态问题",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#h5-先发出的请求后返回应该怎么办-请求竞态问题",children:"#"}),"H5 先发出的请求后返回，应该怎么办？—— 请求竞态问题"]}),"\n",(0,t.jsx)(a.Z,{defaultLocale:"zh-CN"}),"\n",(0,t.jsx)(e.p,{children:"在 H5 开发中，遇到 Tab List 场景时，我们常常会遇到一个问题，那就是先发出的请求，可能之后返回，这个问题会导致 Tab 和列表的值不一致。"}),"\n",(0,t.jsx)(e.p,{children:"如下动图所示，你从 Tab 0 依次快速切换的 Tab 2，又从 Tab 2 快速切换到 Tab 0，最终虽然选择的是 Tab 0，但是 List 的数据却是 Tab 2。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:d})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"data:image/png;base64,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"})}),"\n",(0,t.jsx)(e.p,{children:"这其中的原因，虽然 List 2 的数据发送得比较早，但是返回却比较晚，于是就覆盖了之前 List 0 和 List 1 的数据。"}),"\n",(0,t.jsx)(e.p,{children:"你可以用 setTimeout 模拟请求不固定的情况："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(data);\r\n  }, Math.random() * 3000);\r\n}\r\n\r\nfunction updateList(data) {\r\n  // ... 省略\r\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:["完整代码在：",(0,t.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/eYqLjpo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/lijunlin2022/pen/eYqLjpo"})]}),"\n",(0,t.jsx)(e.p,{children:"可以看到，我们给 setTimout 随机设置了不同的返回时间，用来模拟不同时间的请求。"}),"\n",(0,t.jsx)(e.p,{children:"这种因为请求时间不固定，导致数据不一致的问题，被称作请求竞态问题。"}),"\n",(0,t.jsx)(e.p,{children:"下面我介绍 3 种解决问题的办法，并对它们做一个优劣做一个对比。"}),"\n",(0,t.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,t.jsxs)(e.h2,{id:"取消请求",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#取消请求",children:"#"}),"取消请求"]}),"\n",(0,t.jsx)(e.p,{children:"第一种方法是取消请求，它的思路很简单，那就是我只用我最后一次发出请求的数据，以前的数据我都不要。"}),"\n",(0,t.jsx)(e.p,{children:"我们之前用 setTimeout 模拟了不同时间的请求，也可以用 clearTimeout 模拟取消请求："}),"\n",(0,t.jsx)(e.p,{children:"关键代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"let currentIndex = 0;\r\nlet timer = null\r\n\r\nfunction switchTab(tabIndex) {\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  clearTimeout(timer);\r\n  timer = setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\nfunction updateList(data) {\r\n  // ... 省略\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"可以看到，我让所有 setTimeout 共用了一个计时器，一旦有新的 setTimeout，就把旧的给清除掉。"}),"\n",(0,t.jsxs)(e.p,{children:["完整代码在：codepen: ",(0,t.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/mdNzbWy",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/lijunlin2022/pen/mdNzbWy"})]}),"\n",(0,t.jsx)(e.p,{children:"这种清除的方法，XMLHttpRequest 和 fetch 都提供了。"}),"\n",(0,t.jsx)(e.p,{children:"XMLHttpRequest 的取消请求"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const xhr= new XMLHttpRequest();\r\n\r\nxhr.open('GET', 'https://xxx');\r\nxhr.send();\r\n    \r\nxhr.abort(); // 取消请求\n"})}),"\n",(0,t.jsx)(e.p,{children:"fetch 可以取消请求"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const controller = new AbortController();\r\nconst signal = controller.signal;\r\n\r\nfetch('/xxx', {\r\n  signal,\r\n}).then(function(response) {\r\n  //...\r\n});\r\n\r\ncontroller.abort(); // 取消请求\n"})}),"\n",(0,t.jsx)(e.p,{children:"axios 也能够取消请求"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const source = axios.CancelToken.source();\r\n\r\naxios.get('/xxx', {\r\n  cancelToken: source.token\r\n}).then(function (response) {\r\n  // ...\r\n});\r\n\r\nsource.cancel() // 取消请求\n"})}),"\n",(0,t.jsx)(e.p,{children:"需要注意的是，这里的取消请求，只是前端不再使用这个请求的数据，发到后端的请求是没有变少的。"}),"\n",(0,t.jsx)(e.p,{children:"但是按照我的经验，实际项目中，网络请求总是被封装封装再封装，而取消请求往往会被遗漏掉，此时想要再去改代码非常困难。下面我们再介绍另外两种方法，它们更简单和实用。"}),"\n",(0,t.jsxs)(e.h2,{id:"忽略请求",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#忽略请求",children:"#"}),"忽略请求"]}),"\n",(0,t.jsx)(e.p,{children:"这种做法，就是处理请求给它一个标识，如果请求结果回来之后我们发现标识对不上，那么就忽略这个请求，关键代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:'let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  currentIndex = tabIndex;\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(tabIndex, data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\nfunction updateList(tabIndex, data) {\r\n  const list = document.getElementById("list");\r\n  if (tabIndex === currentIndex) {\r\n    list.innerHTML = data;\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"我们在切换 Tab 时更新了 currentIndex，同时我们还把 tabIndex 一起传递给了 fetchData，如果后来我们反向请求结束后的 tabIndex 和我们的 currentIndex 不匹配时，我们就忽略这次请求。"}),"\n",(0,t.jsx)(e.p,{children:"完整代码如下："}),"\n",(0,t.jsxs)(e.p,{children:["codepen: ",(0,t.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/MWNPgGG",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/lijunlin2022/pen/MWNPgGG"})]}),"\n",(0,t.jsxs)(e.h2,{id:"映射请求",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#映射请求",children:"#"}),"映射请求"]}),"\n",(0,t.jsx)(e.p,{children:"接下来我们映射请求。我们回到出现问题的初始条件，除了先发出的请求后返回之外，出现这个问题的另一个核心原因是多个 Tab 只使用了一个 List，如果我们让一个 Tab 对应一个 List，就可以解决这个问题。"}),"\n",(0,t.jsx)(e.p,{children:"不过，虽然能够有多个 List，但页面上只能显示一个，因此我们还需要给选中 Tab 的 List 加上 display: block，其他 List 都是 display: none"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",meta:"",children:'<main>\r\n  <div id="tabs">\r\n    <div class="tab active" onclick="switchTab(0)">Tab 0</div>\r\n    <div class="tab" onclick="switchTab(1)">Tab 1</div>\r\n    <div class="tab" onclick="switchTab(2)">Tab 2</div>\r\n  </div>\r\n  <div id="lists">\r\n    <div class="list active">data from tab 0</div>\r\n    <div class="list"></div>\r\n    <div class="list"></div>\r\n  </div>\r\n</main>\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:'let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(tabIndex, data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\nfunction updateList(tabIndex, data) {\r\n  const lists = document.getElementById("lists");\r\n  Array.from(lists.children).forEach(l => {\r\n    l.classList.remove("active")\r\n  })\r\n  lists.children[tabIndex].classList.add("active")\r\n  lists.children[tabIndex].innerHTML = data\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"这种方法也很有效，但维护多个 List 的难度比维护单个 List 要困难，所以大部分人不会采用，不过如果能和第二种结合的话，是一种非常不错的减少请求次数的办法。"}),"\n",(0,t.jsxs)(e.p,{children:["完整代码为：codepen: ",(0,t.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/KKOGPEo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/lijunlin2022/pen/KKOGPEo"})]}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,t.jsx)(e.p,{children:"我们介绍了什么事请求竞态问题，并给出了三种解决方案。"}),"\n",(0,t.jsx)(e.p,{children:"其中忽略请求最实用，映射请求在缓存数据时很好用，而取消请求则需要更高超的使用方法。"}),"\n",(0,t.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(s,n)})):s(n)}let A=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["blog%2F2024%2F11%2F06%2Findex.md"]={toc:[{id:"取消请求",text:"取消请求",depth:2},{id:"忽略请求",text:"忽略请求",depth:2},{id:"映射请求",text:"映射请求",depth:2},{id:"总结",text:"总结",depth:2}],title:"H5 先发出的请求后返回，应该怎么办？—— 请求竞态问题",frontmatter:{}}},95895:function(n,e,r){r.d(e,{Z:function(){return c}});var t=r(85893),i=r(67294),a=r(45687);r(6175);let d={"zh-CN":n=>`预计阅读时间: ${n.minutes>=1?`${Math.ceil(n.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function s(n,e,r){let t=Object.keys(d).includes(e)?e:r;return d[t](n)}let c=n=>{let{defaultLocale:e="en-US"}=n,r=(0,a.Vi)().page.readingTimeData,d=(0,a.Jr)(),c=(0,a.e7)(),[A,l]=(0,i.useState)(s(r,d,e));return(0,i.useEffect)(()=>{l(s(r,d,e))},[d,r]),(0,t.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:A})}}}]);