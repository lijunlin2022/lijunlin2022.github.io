"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["4895"],{6222:function(e,n,r){r.r(n),r.d(n,{default:()=>c});var s=r("5893"),d=r("65");let i=r.p+"static/image/loading.ba11dc1c.gif",l=r.p+"static/image/principle.305efb05.png",a=r.p+"static/image/pull-up.70a6e8fa.gif";function t(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",code:"code",pre:"pre",h3:"h3",strong:"strong",ul:"ul",li:"li"},(0,d.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"h5-上滑加载触底加载如何实现",children:["H5 上滑加载（触底加载）如何实现？",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#h5-上滑加载触底加载如何实现",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"上滑加载（触底加载）是 H5 常见的功能，今天我们来看下如何实现。"}),"\n",(0,s.jsx)(n.p,{children:"效果如下：分页请求开始前，列表滚动，加载动画出现在屏幕中；分页请求过程中，加载动画一直旋转；分页请求完成后，列表底部插入了新节点，加载动画被挤出屏幕。"}),"\n",(0,s.jsx)(n.p,{children:"如此循环往复，直到分页请求无法返回更多数据，列表底部展示「没有更多了」提示，加载动画隐藏。"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:a,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"首先我会讲解上滑加载的原理，并简单说明 IntersectionObserver 的用法；接着我会给出上滑加载的关键布局代码、逻辑代码，接着我会介绍上滑加载需要注意的三个问题，最后我会再做个简单的总结。"}),"\n",(0,s.jsxs)(n.h2,{id:"上滑加载的原理",children:["上滑加载的原理",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#上滑加载的原理",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:l,alt:""})}),"\n",(0,s.jsx)(n.p,{children:"如图所示，蓝色矩形代表视口，绿色矩形代表包裹列表和动画的容器，金黄色矩形代表列表，橙色则代表加载动画。"}),"\n",(0,s.jsx)(n.p,{children:"最开始时，加载动画处于视口下方；当用户滚动列表到达底部时，加载动画就进入了视口，此时可以请求列表下一页数据，请求成功后新节点插入到列表底部，新节点把动画挤出了视口。"}),"\n",(0,s.jsxs)(n.p,{children:["也就是说，想实现加载更多，关键就是监听加载动画有没有进入视口内部。我们可以使用 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver",target:"_blank",rel:"noopener noreferrer",children:"IntersectionObserver"})," 这个 API 监听动画有没有进入视口。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"IntersectionObserver"})," 使用方法如下，我们首先创建了一个监听器 observer，再用这个监听器去监视元素 element。当 ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry/isIntersecting",target:"_blank",rel:"noopener noreferrer",children:"entry.isIntersecting"})," 为 true 时，说明 element 已经进入视口。"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// 创建监听器\r\nconst observer = new IntersectionObserver(([entry]) => {\r\n  if (entry.isIntersecting) {\r\n    console.log('进入视口')\r\n  }\r\n})\r\n// 开始监听\r\nobserver.observe(element)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"上滑加载关键代码",children:["上滑加载关键代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#上滑加载关键代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"知道原理后，现在我们来看实现上滑加载的关键代码，首先是布局代码："}),"\n",(0,s.jsxs)(n.h3,{id:"布局代码",children:["布局代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#布局代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"布局代码和原理图相互对应，box 是包裹列表和加载动画的容器、list 有 5 个子元素、list 下方则是加载动画的容器。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-html",children:'<div class="box">\r\n  <div id="list">\r\n    <div class="item">0</div>\r\n    <div class="item">1</div>\r\n    <div class="item">2</div>\r\n    <div class="item">3</div>\r\n    <div class="item">4</div>\r\n  </div>\r\n  <div class="loader-box">\r\n    <div id="loader"></div>\r\n    <div id="nothing" class="hidden">没有更多了~</div>\r\n  </div>\r\n</div>\n'})}),"\n",(0,s.jsx)(n.p,{children:"列表布局很基础，我们主要看动画。loader-box 中的 loader 是纯 CSS 的加载动画。我们利用 border 画出的一个圆形边框，左、上、右边框是浅灰色，下边框是深灰色："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXIAAABGCAIAAABe2ohRAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAARCSURBVHic7dw7TyJdHIDxAwMzA4OCIRMSDIkUJlpqYWNhYW/tp/DDSE9tbW9hYWOhnZpYYDAUhBABh8sMt7cYc14WVxflqOzO86uOZPjnFJsnc2EnNB6PBQCoE/7pDQD415AVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIqRFQCKkRUAipEVAIpFfnoDWHSe53U6nV6v1+/3B4PBeDwOhUKRSCQajZqmGY/HdV3/6T1isYR48z7e4jhOq9Xq9XrvH2aa5vLyciKR+J5dYfGRFfyG53n1er3b7c7+lVgslk6nOXOBICt47fn5uVarTX5iWZZlWYZhaJoWDodHo9FwOHRdt91ut9vtySNt215aWvre/WLhkBX8olqtTpYilUolk0lN0946fjgcNpvNRqMhP7EsK5PJfO0usdjICv43eZ6i67pt24ZhzPJF13VrtZrnef6fnLMEHA+Y8cLzPNkUTdOy2eyMTRFCGIaRzWblSc1kYhBAZAUv6vW6v9B1PZfLhcMf+7cRDodzuZy8ZSunIYDICoQQwnEc+dzHtu2PNsUXDodt2/bX3W7XcRxl+8NfhaxACCFarZa/SKVSs1/7vGYYRiqVmpqJoCErEJ7nyd+8JZPJOafJCb1ejzsswURWIDqdjr+wLOudZ8kz0jTNsqypyQgUsgIhT1VkDuYk5/zxh//4J5EViH6/7y/muasySc6RkxEoZAViMBj4i/mvgKbmyMkIFLICIX9p/bnnyq/JOfyGO5jICkQoFPIXo9FIyUA5R05GoJAViEjk5W1ew+FQyUA5R05GoJAViGg06i9c11UyUM6RkxEoZAXCNE1/MfXylE+Tc+RkBApZgYjH4/6i3W7Pfx00HA5lVuRkBApZgdB1XZ5WNJvNOafJCaZp8g7KYCIrEEKI5eVlf9FoNOa5w+K6rnxTnJyJoCErEEKIRCIRi8X8da1W+9yT5tFoJF8EFYvFeBd/YJEVvEin0/7C87ybm5uP/ufjqW/JaQggsoIX/strhRCNRqNYLBYKhXK5PON3y+VyoVAoFov+FZBt29xVCTJekY1fPDw8HB8fyz/39/f39vbeuZxxHOf8/Pzs7Ex+cnR0tLa29qWbxIIjK5h2eXl5cnIy+cnW1tbm5mYul1tZWdF13fO8p6enx8fH29vb6+vrySMPDw93dna+d79YOGQFv1GpVE5PT+/v72f/yvr6+sHBwerq6tftCn8LsoI3XV1dXVxclEql9w/L5/O7u7vb29vfsyssPrKCP6hUKnd3d6VSqVqtNpvNwWAQiUSSyWQmk8nn8xsbG5yhYApZAaAYD5gBKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWAChGVgAoRlYAKEZWACj2H3/xd/JlnTeYAAAAAElFTkSuQmCC",alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"#loader {\r\n  width: 25px;\r\n  height: 25px;\r\n  border: 3px solid #ddd;\r\n  border-radius: 50%;\r\n  border-bottom: 3px solid #717171;\r\n  transform: rotate(0deg);\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"我们给 loader 元素增加一个动画，让它从 0 度到 360 度无限旋转，就实现了加载动画："}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)("img",{src:i,alt:""})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-css",children:"#loader {\r\n  ...\r\n  animation: loading 1s linear infinite;\r\n}\r\n\r\n@keyframes loading {\r\n  from { transform: rotate(0deg); }\r\n  to { transform: rotate(360deg); }\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"loader 也是我们真正需要监听是否进入视口的元素。"})}),"\n",(0,s.jsxs)(n.h3,{id:"逻辑代码",children:["逻辑代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#逻辑代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"关键逻辑代码4和原理中一致，我们只需要监听到动画 loader 进入视口，就直接调用 pullUp 函数。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const loader = document.getElementById('loader')\r\nconst observer = new IntersectionObserver(([entry]) => {\r\n  if (entry.isIntersecting) {\r\n    pullUp()\r\n  }\r\n}, {\r\n  root: null,\r\n  rootMargin: '0px',\r\n  threshold: 0\r\n})\r\n\r\nobserver.observe(loader)\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"上滑加载的两个注意点",children:["上滑加载的两个注意点",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#上滑加载的两个注意点",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"实现上滑加载，我们除了关键完布局代码、逻辑代码外，还有三个点需要注意："}),"\n",(0,s.jsxs)(n.h3,{id:"加载锁",children:["加载锁",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#加载锁",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"第一点，前一次上滑加载未完成之前，不应该再次触发上滑加载。"}),"\n",(0,s.jsx)(n.p,{children:"为此，我们需要创建一个加载锁变量 loadLock，数据加载前先把 loadLock 赋值为 true，数据加载完成后再把 loadLock 赋值为 false。如果 loadLock 一直为 true，就说明前一次加载未完成，我们需要直接 return 结束 pullUp 函数。"}),"\n",(0,s.jsx)(n.p,{children:"代码如下："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let loadLock = false\r\n\r\nfunction pullUp() {\r\n  ...\r\n  if (loadLock) { return }\r\n  loadData()\r\n}\r\n\r\nfunction loadData() {\r\n  ...\r\n  loadLock = true\r\n  setTimeout(() => {\r\n    ...\r\n    loadLock = false\r\n  }, LOADING_TIME)\r\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"没有更多数据",children:["没有更多数据",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#没有更多数据",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"第二点，需要考虑没有更多数据的情况。上滑加载请求的数据是分页的，一定有请求结束的情况。请求结束时，我们需要给用户一些提示。"}),"\n",(0,s.jsx)(n.p,{children:"我们可以设置一个 hasMore 变量。hasMore 为 true 表示时候有更多数据，为 false 时表示数据了，应该隐藏加载动画，展示「没有更多了」提示。"}),"\n",(0,s.jsx)(n.p,{children:"代码如下，我限制了分页数据最多只有 LIST_LIMIT_CNT 条："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let hasMore = true\r\n\r\nfunction pullUp() {\r\n  if (!hasMore) { return }\r\n  ...\r\n  loadData()\r\n}\r\n\r\nfunction loadData() {\r\n  ...\r\n  setTimeout(() => {\r\n    if (len >= LIST_LIMIT_CNT) {\r\n      loader.className = 'hidden'\r\n      nothing.className = ''\r\n      hasMore = false\r\n      return\r\n    }\r\n    ...\r\n  }, LOADING_TIME);\r\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"请求失败",children:["请求失败",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#请求失败",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"第三点，需要考虑请求失败的情况。我们无法保证服务器一直运转正常，很可能列表前一次分页请求还成功，后一次分页请求就失败了。"}),"\n",(0,s.jsx)(n.p,{children:"这种情况有两种常见交互："}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"直接展示「请求出错了」，让用户点击重试。"}),"\n",(0,s.jsx)(n.li,{children:"继续展示加载动画，重新请求服务器数据。"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"因为请求失败不好模拟，所以 Demo 中只实现了加载锁和没有更多数据的情况，你可以根据自己的需要改写 Demo。"}),"\n",(0,s.jsxs)(n.h2,{id:"示例代码",children:["示例代码",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例代码",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://codepen.io/lijunlin2022/pen/OJrJePE",target:"_blank",rel:"noopener noreferrer",children:"上滑加载、触底加载 | codepen"})}),"\n",(0,s.jsxs)(n.h2,{id:"总结",children:["总结",(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,s.jsx)(n.p,{children:"本文讲解了上滑加载的原理——利用 IntersectionObserver 监听加载动画是否进入视口，如果动画进入则请求下一页数据。此外，本文还说明了上滑加载需要注意的三个点：加载锁、没有更多数据和请求失败。"})]})}function h(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(t,{...e})}):t(e)}let c=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["blog%2F2024-03-02-pull-up%2Findex.md"]={toc:[{text:"上滑加载的原理",id:"上滑加载的原理",depth:2},{text:"上滑加载关键代码",id:"上滑加载关键代码",depth:2},{text:"布局代码",id:"布局代码",depth:3},{text:"逻辑代码",id:"逻辑代码",depth:3},{text:"上滑加载的两个注意点",id:"上滑加载的两个注意点",depth:2},{text:"加载锁",id:"加载锁",depth:3},{text:"没有更多数据",id:"没有更多数据",depth:3},{text:"请求失败",id:"请求失败",depth:3},{text:"示例代码",id:"示例代码",depth:2},{text:"总结",id:"总结",depth:2}],title:"H5 上滑加载（触底加载）如何实现？",frontmatter:{tags:["H5"]}}}}]);