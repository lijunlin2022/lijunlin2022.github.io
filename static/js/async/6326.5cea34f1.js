"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["6326"],{3518:function(n,e,r){r.r(e),r.d(e,{default:()=>t});var l=r("5893"),s=r("65");let i=r.p+"static/image/clear-float2.01c7d50d.jpg",c=r.p+"static/image/clear-float1.0272f3e6.jpg";function d(n){let e=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",strong:"strong",h2:"h2",pre:"pre",code:"code",img:"img",ol:"ol",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,s.ah)(),n.components);return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsxs)(e.h1,{id:"清除浮动",children:["清除浮动",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#清除浮动",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"多个块级元素纵向排列可以用标准流实现，多个块级元素横向排列可以用 float（浮动）实现"}),"\n",(0,l.jsx)(e.p,{children:"它的特性为："}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["浮动元素会",(0,l.jsx)(e.strong,{children:"脱离标准流"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"脱离标准流的控制（浮），移动到指定位置（动）"}),"\n",(0,l.jsxs)(e.li,{children:["浮动的盒子",(0,l.jsx)(e.strong,{children:"不再保留原先的位置"})]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["如果多个盒子都设置了浮动，则它们",(0,l.jsx)(e.strong,{children:"一行显示并且顶端对齐排列"})]}),"\n",(0,l.jsxs)(e.li,{children:["任何元素都可以浮动，",(0,l.jsx)(e.strong,{children:"浮动元素具有行内块元素的特点"}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"如果块级盒子没有设置宽度，默认是和父级元素一样宽，但是添加浮动后，它的宽度根据内容来决定"}),"\n",(0,l.jsx)(e.li,{children:"浮动的盒子中间是没有间隙的"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"浮动的取值",children:["浮动的取值",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浮动的取值",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"值：left | right | none | inherit"}),"\n",(0,l.jsxs)(e.h2,{id:"浮动布局的注意点",children:["浮动布局的注意点",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浮动布局的注意点",children:"#"})]}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"一般浮动布局时，需要和父盒子搭配"}),"\n",(0,l.jsx)(e.p,{children:"先用父盒子排列上下位置，之后内部子元素采用浮动左右排列"}),"\n"]}),"\n",(0,l.jsxs)(e.li,{children:["\n",(0,l.jsx)(e.p,{children:"一个元素浮动了，理论上其余的兄弟元素也要浮动"}),"\n",(0,l.jsx)(e.p,{children:"浮动的盒子只会影响盒子后面的标准流，不会影响前面的标准流"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.h2,{id:"清除浮动-1",children:["清除浮动",(0,l.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#清除浮动-1",children:"#"})]}),"\n",(0,l.jsx)(e.p,{children:"使用浮动可能会导致父盒子高度坍塌，如下面例子所示："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-html",children:'<style>\r\n.container {\r\n  border: 1px solid red;\r\n}\r\n.float-left {\r\n  float: left;\r\n}\r\n.cube {\r\n  width: 100px;\r\n  height: 100px;\r\n  background: blue;\r\n}\r\n</style>\r\n\r\n<div class="container">\r\n  <div class="cube float-left"></div>\r\n</div>\n'})}),"\n",(0,l.jsx)(e.p,{children:"效果为："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:c,alt:""})}),"\n",(0,l.jsx)(e.p,{children:"而我们需要父元素的高度，将子元素包围起来，也就是清除浮动，清除浮动后的效果如下："}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)("img",{src:i,alt:""})}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"清除浮动的本质"})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"清除浮动的本质就是清除浮动元素造成的影响"}),"\n",(0,l.jsx)(e.li,{children:"如果父元素本身有高度，则不需要清除浮动"}),"\n",(0,l.jsx)(e.li,{children:"清除浮动之后，父级就会根据浮动的子盒子自动检测高度，父级有了高度，就不会影响下面的标准流了"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:(0,l.jsx)(e.strong,{children:"清除浮动的办法"})}),"\n",(0,l.jsx)(e.p,{children:"清除浮动的中心思想就是——闭合浮动，让浮动只影响父元素内部，不影响父元素外部。"}),"\n",(0,l.jsx)(e.p,{children:"清除浮动一般有四种办法，分别是："}),"\n",(0,l.jsxs)(e.ol,{children:["\n",(0,l.jsx)(e.li,{children:"额外标签法——隔墙法，是 W3C 推荐的做法"}),"\n",(0,l.jsx)(e.li,{children:"父级添加 :after 伪元素法"}),"\n",(0,l.jsx)(e.li,{children:"父级添加双伪元素法"}),"\n",(0,l.jsx)(e.li,{children:"父级添加 overflow 属性"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"(1) 额外标签法"}),"\n",(0,l.jsxs)(e.p,{children:["前三个方法都需要用到一个属性 ",(0,l.jsx)(e.code,{children:"clear"}),"，",(0,l.jsx)(e.code,{children:"clear"})," 是专门用来清除浮动的属性。"]}),"\n",(0,l.jsx)(e.p,{children:"使用 clear 的语法为："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-css",children:"选择器 { clear: 属性值; }\n"})}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:"clear"})," 拥有的属性值列举如下："]}),"\n",(0,l.jsxs)(e.table,{children:["\n",(0,l.jsxs)(e.thead,{children:["\n",(0,l.jsxs)(e.tr,{children:["\n",(0,l.jsx)(e.th,{children:"属性值"}),"\n",(0,l.jsx)(e.th,{children:"描述"}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.tbody,{children:["\n",(0,l.jsxs)(e.tr,{children:["\n",(0,l.jsx)(e.td,{children:"left"}),"\n",(0,l.jsx)(e.td,{children:"不允许左侧有浮动元素（清除左侧浮动的影响）"}),"\n"]}),"\n",(0,l.jsxs)(e.tr,{children:["\n",(0,l.jsx)(e.td,{children:"right"}),"\n",(0,l.jsx)(e.td,{children:"不允许右侧有浮动元素（清除右侧浮动的影响）"}),"\n"]}),"\n",(0,l.jsxs)(e.tr,{children:["\n",(0,l.jsx)(e.td,{children:"both"}),"\n",(0,l.jsx)(e.td,{children:"同时清除左右两侧浮动的影响"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(e.p,{children:["实际中，几乎只用到 ",(0,l.jsx)(e.code,{children:"clear: both;"})]}),"\n",(0,l.jsx)(e.p,{children:"下面是额外标签法的代码："}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-html",children:'<style>\r\n  .clear {\r\n    clear: both;\r\n  }\r\n</style>\r\n\r\n<div>\r\n  \x3c!-- 前面有很多浮动元素 --\x3e\r\n  ...\r\n  <div class="clear"></div>\r\n</div>\n'})}),"\n",(0,l.jsxs)(e.ul,{children:["\n",(0,l.jsx)(e.li,{children:"优点：通俗移动，书写方便"}),"\n",(0,l.jsx)(e.li,{children:"缺点：添加许多无意义的标签，结构化较差"}),"\n"]}),"\n",(0,l.jsx)(e.p,{children:"（2）父级添加 :after 伪元素"}),"\n",(0,l.jsxs)(e.p,{children:[(0,l.jsx)(e.code,{children:":after"})," 方式是额外标签法的升级版，也是给父元素添加标签，只不过使用伪元素添加"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-css",children:'.clearfix:after {\r\n  content: "";\r\n  display: table;\r\n  clear: both;\r\n}\r\n.clearfix { /- IE6, 7 专有 */\r\n  *zoom: 1;\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"（3）父元素添加双伪元素清除浮动"}),"\n",(0,l.jsx)(e.p,{children:"这种方式和（2）类似"}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-css",children:'.clearfix:before,\r\n.clearfix:after {\r\n  content: "";\r\n  display: table;\r\n}\r\n.clearfix:after {\r\n  clear: both;\r\n}\r\n.clearfix { /- IE6, 7 专有 */\r\n  *zoom: 1;\r\n}\n'})}),"\n",(0,l.jsx)(e.p,{children:"（4）4.2.4 父级添加 overflow 属性"}),"\n",(0,l.jsxs)(e.p,{children:["这是让父级元素符合 BFC 规范，BFC 规范本身就是元素内部形成一块隔离的空间，因此，只需要给父元素田间 ",(0,l.jsx)(e.code,{children:"overflow: hidden;"})," 就可以了"]}),"\n",(0,l.jsx)(e.pre,{children:(0,l.jsx)(e.code,{className:"language-html",children:'<style>\r\n  .box {\r\n    overflow: hidden;\r\n  }\r\n</style>\r\n\r\n<div class="box">\r\n  \x3c!-- 很多浮动元素 --\x3e\r\n  ...\r\n</div>\n'})})]})}function h(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,s.ah)(),n.components);return e?(0,l.jsx)(e,{...n,children:(0,l.jsx)(d,{...n})}):d(n)}let t=h;h.__RSPRESS_PAGE_META={},h.__RSPRESS_PAGE_META["docs%2Fcss%2F02-clear-float.md"]={toc:[{text:"浮动的取值",id:"浮动的取值",depth:2},{text:"浮动布局的注意点",id:"浮动布局的注意点",depth:2},{text:"清除浮动",id:"清除浮动-1",depth:2}],title:"清除浮动",frontmatter:{}}}}]);