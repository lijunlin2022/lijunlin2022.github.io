"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["406"],{82511:function(n,e,r){r.r(e),r.d(e,{default:()=>l});var t=r("85893"),a=r("50065"),d=r("95895");let i=r.p+"static/image/settTimeout-random.dbbd7c6a.gif";function s(n){let e=Object.assign({h1:"h1",a:"a",p:"p",img:"img",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,a.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"h5-更早发出的请求更晚被响应应该怎么办-请求竞态问题",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#h5-更早发出的请求更晚被响应应该怎么办-请求竞态问题",children:"#"}),"H5 更早发出的请求、更晚被响应，应该怎么办？—— 请求竞态问题"]}),"\n",(0,t.jsx)(d.Z,{defaultLocale:"zh-CN"}),"\n",(0,t.jsx)(e.p,{children:"H5 多个 Tab 单个 List 场景时，你也许会遇到请求竞态问题。"}),"\n",(0,t.jsx)(e.p,{children:"如动图所示，你从 Tab 0 切换到 Tab 1、Tab 2，又从 Tab 2 切换到 Tab 1、Tab 0。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:i})}),"\n",(0,t.jsx)(e.p,{children:"最后你选择了 Tab 0，List 却是 Tab 2 的数据。"}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:"data:image/png;base64,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"})}),"\n",(0,t.jsx)(e.p,{children:"这是因为更早发出的 Tab2 请求，却更晚被响应，它覆盖了 Tab 0 和 Tab 1 的响应。"}),"\n",(0,t.jsx)(e.p,{children:"多个请求发出顺序和被响应顺序不同，导致共用的数据错乱，就是请求竞态问题。"}),"\n",(0,t.jsx)(e.p,{children:"怎么解决请求竞态问题呢？我将介绍 4 种办法，并给它们做一个对比。"}),"\n",(0,t.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,t.jsxs)(e.h2,{id:"模拟问题",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#模拟问题",children:"#"}),"模拟问题"]}),"\n",(0,t.jsx)(e.p,{children:"要解决问题，需要先复现问题，你可以用 setTimeout 写一个随机延时的 Demo，模拟请求静态问题。"}),"\n",(0,t.jsx)(e.p,{children:"Demo 的 HTML 代码如下，它分为 tabs 和 list 两部分，每一个 tab 都绑定了切换 Tab 事件。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",meta:"",children:'<main>\r\n  <div id="tabs">\r\n    <div class="tab active" onclick="switchTab(0)">Tab 0</div>\r\n    <div class="tab" onclick="switchTab(1)">Tab 1</div>\r\n    <div class="tab" onclick="switchTab(2)">Tab 2</div>\r\n  </div>\r\n  <div id="list">\r\n    data from tab 0\r\n  </div>\r\n</main>\n'})}),"\n",(0,t.jsx)(e.p,{children:"Demo 的 JavaScript 代码如下，切换 Tab 时，会调用 switchTab 函数；switchTab 激活选中 Tab 的样式，并调用 fetchData；fetchData 模拟发出请求获取数据；之后调用 updateList；updateList 更新 list 的 UI。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:'let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  currentIndex = tabIndex;\r\n  const tabs = document.querySelectorAll(".tab");\r\n  tabs.forEach((tab) => {\r\n    tab.classList.remove("active");\r\n  });\r\n  tabs[currentIndex].classList.add("active");\r\n  fetchData(tabIndex);\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(data);\r\n  }, Math.random() * 3000);\r\n}\r\n\r\nfunction updateList(data) {\r\n  const list = document.getElementById("list");\r\n  list.innerHTML = data;\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"关键代码在 fetchData 上，你用 setTimeout 加上随机数，实现响应随机返回，这样请求顺序和响应顺序大概率会不一致，就能模拟请求竞态问题。"}),"\n",(0,t.jsx)(e.p,{children:"代码我放在 codepen 和码上掘金，你可以点击体验。"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["codepen: ",(0,t.jsx)(e.a,{href:"https://codepen.io/lijunlin2022/pen/eYqLjpo",target:"_blank",rel:"noopener noreferrer",children:"https://codepen.io/lijunlin2022/pen/eYqLjpo"})]}),"\n",(0,t.jsxs)(e.li,{children:["码上掘金: ",(0,t.jsx)(e.a,{href:"https://code.juejin.cn/pen/7436416858615775266",target:"_blank",rel:"noopener noreferrer",children:"https://code.juejin.cn/pen/7436416858615775266"})]}),"\n"]}),"\n",(0,t.jsxs)(e.h2,{id:"方法一加载中禁止切换",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法一加载中禁止切换",children:"#"}),"方法一：加载中禁止切换"]}),"\n",(0,t.jsx)(e.p,{children:"现在来看解决办法，第一种办法思路是，发出一个请求后，如果请求没有响应，那么就不允许用户切换 Tab，发出第二个请求。"}),"\n",(0,t.jsx)(e.p,{children:"关键代码如下，新增一个加载锁 loadLock，发出请求时将 loadLock 置为 true，请求响应后将 loadLock 置为 false。只有 loadLock 为 false 时才能切换 Tab。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"let currentIndex = 0;\r\nlet loadLock = false;\r\n\r\nfunction switchTab(tabIndex) {\r\n  if (loadLock) {\r\n    return;\r\n  }\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  loadLock = true;\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(data);\r\n    loadLock = false;\r\n  }, Math.random() * 3000);\r\n}\r\n\r\nfunction updateList(data) {\r\n  // ... 省略\r\n}\n"})}),"\n",(0,t.jsx)(e.p,{children:"这种办法，可以强制让请求顺序和响应顺序相同，规避掉竞态问题。"}),"\n",(0,t.jsx)(e.p,{children:"它的优点是简单，缺点是要求接口响应速度足够快。如果接口响应速度很慢，那么用户会被卡死在一个 Tab 上，体验很差。"}),"\n",(0,t.jsxs)(e.h2,{id:"方法二取消请求",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法二取消请求",children:"#"}),"方法二：取消请求"]}),"\n",(0,t.jsx)(e.p,{children:"第二种方法是取消请求。它的思路是，多个请求时，只使用最后一次请求的响应，以前的响应都丢弃。"}),"\n",(0,t.jsx)(e.p,{children:"这里的取消请求，是指前端不再使用请求的响应，如果请求已经发到后端了，后端接收的请求量没有减少。"}),"\n",(0,t.jsx)(e.p,{children:"你可以用 clearTimeout 模拟取消请求："}),"\n",(0,t.jsx)(e.p,{children:"关键代码如下："}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"let currentIndex = 0;\r\nlet timer = null\r\n\r\n// ... 省略\r\n\r\nfunction fetchData(tabIndex) {\r\n  clearTimeout(timer);\r\n  timer = setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\n// ... 省略\n"})}),"\n",(0,t.jsx)(e.p,{children:"所有的 setTimeout 共用了一个标识符，一旦有新的计时器，就清除掉旧的计时器。这样旧的计时器就不再调用 updateList。"}),"\n",(0,t.jsx)(e.p,{children:"真实网络请求中，XMLHttpRequest、fetch 本身有取消请求的方法，封装它们的 axios 和 useRequest 也有取消请求的方法。"}),"\n",(0,t.jsx)(e.p,{children:"它们取消请求的方式我折叠后放在了文章下方，你可以点击查看："}),"\n",(0,t.jsxs)("details",{children:[(0,t.jsx)("summary",{children:"点击查看 XMLHttpRequest 取消请求"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const xhr= new XMLHttpRequest();\r\n\r\nxhr.open('GET', 'https://xxx');\r\nxhr.send();\r\n    \r\nxhr.abort(); // 取消请求\n"})})]}),"\n",(0,t.jsxs)("details",{children:[(0,t.jsx)("summary",{children:"点击查看 fetch 取消请求"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const controller = new AbortController();\r\nconst signal = controller.signal;\r\n\r\nfetch('/xxx', {\r\n  signal,\r\n}).then(function(response) {\r\n  //...\r\n});\r\n\r\ncontroller.abort(); // 取消请求\n"})})]}),"\n",(0,t.jsxs)("details",{children:[(0,t.jsx)("summary",{children:"点击查看 axios 取消请求"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const source = axios.CancelToken.source();\r\n\r\naxios.get('/xxx', {\r\n  cancelToken: source.token\r\n}).then(function (response) {\r\n  // ...\r\n});\r\n\r\nsource.cancel() // 取消请求\n"})})]}),"\n",(0,t.jsxs)("details",{children:[(0,t.jsx)("summary",{children:"点击查看 useRequest 取消请求"}),(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:"const { result, loading, error, run, cancel } = useRequest(request);\r\n// ...\r\nconst isCanceled = cancel();\n"})})]}),"\n",(0,t.jsx)(e.p,{children:"取消请求的优点是使用简单，可以更精细地控制请求；缺点是依赖取消请求的 API，如果是不涉及请求的竞态问题，则无法使用取消请求的方法。"}),"\n",(0,t.jsxs)(e.h2,{id:"方法三忽略请求使用标志符",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法三忽略请求使用标志符",children:"#"}),"方法三：忽略请求（使用标志符）"]}),"\n",(0,t.jsx)(e.p,{children:"第三种方法是忽略请求，它的原理是，先在全局维护一个标识，再给每一个请求都携带标识，如果请求被响应后，请求标识和维护的标识对不上，就忽略这次请求。"}),"\n",(0,t.jsx)(e.p,{children:"这么说比较抽象，我们看如下代码，全局标识就是 currentIndex，每次点击 Tab 时我们都会更新 currentIndex。给每一个请求携带的标识是 tabIndex，它代表时哪一个 Tab 发出的请求。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:'let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  currentIndex = tabIndex;\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(tabIndex, data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\nfunction updateList(tabIndex, data) {\r\n  const list = document.getElementById("list");\r\n  if (tabIndex === currentIndex) {\r\n    list.innerHTML = data;\r\n  }\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"请求被响应后，我们对比 tabIndex 和 currentIndex，如果二者不匹配时，我们就忽略这次请求，不更新数据。"}),"\n",(0,t.jsx)(e.p,{children:"忽略请求的优点是实现简单，不依赖额外的 API。不过如果竞态问题更复杂，那么使用忽略请求编写的代码就会难以理解、维护。"}),"\n",(0,t.jsxs)(e.h2,{id:"方法四映射请求",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#方法四映射请求",children:"#"}),"方法四：映射请求"]}),"\n",(0,t.jsx)(e.p,{children:"第四种办法是映射请求。"}),"\n",(0,t.jsx)(e.p,{children:"回忆请求竞态问题的条件，除了请求顺序和响应顺序不同外，还有一个条件，那就是多个请求共用一个数据。"}),"\n",(0,t.jsx)(e.p,{children:"如果一个请求一个数据，那么就不会有请求竞态问题。对应到 Tab List 场景，你可以让一个 Tab 一个 List。"}),"\n",(0,t.jsx)(e.p,{children:"修改 Demo，HTML 代码如下，lists 内部包含多个 list。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-html",meta:"",children:'<main>\r\n  <div id="tabs">\r\n    <div class="tab active" onclick="switchTab(0)">Tab 0</div>\r\n    <div class="tab" onclick="switchTab(1)">Tab 1</div>\r\n    <div class="tab" onclick="switchTab(2)">Tab 2</div>\r\n  </div>\r\n  <div id="lists">\r\n    <div class="list active">data from tab 0</div>\r\n    <div class="list"></div>\r\n    <div class="list"></div>\r\n  </div>\r\n</main>\n'})}),"\n",(0,t.jsx)(e.p,{children:"JavaScript 代码如下，某个 tab 发送请求后，它的响应数据只会更新到该 tab 对应的 list。"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-js",meta:"",children:'let currentIndex = 0;\r\n\r\nfunction switchTab(tabIndex) {\r\n  // ... 省略\r\n}\r\n\r\nfunction fetchData(tabIndex) {\r\n  setTimeout(() => {\r\n    const data = `data from tab ${tabIndex}`;\r\n    updateList(tabIndex, data);\r\n  }, Math.random() * 5000);\r\n}\r\n\r\nfunction updateList(tabIndex, data) {\r\n  const lists = document.getElementById("lists");\r\n  Array.from(lists.children).forEach(l => {\r\n    l.classList.remove("active")\r\n  })\r\n  lists.children[tabIndex].classList.add("active")\r\n  lists.children[tabIndex].innerHTML = data\r\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"映射请求适合与缓存结合使用，用户点击过一个 Tab 后，就把 Tab 对应的 List 数据存下来，下次再点击同一个 Tab，就不需要再次请求数据，请求次数将大大减少。"}),"\n",(0,t.jsx)(e.p,{children:"不过结合缓存后，维护的数据会变多，程序变得更复杂。"}),"\n",(0,t.jsxs)(e.h2,{id:"总结",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"}),"总结"]}),"\n",(0,t.jsx)(e.p,{children:"最后，我们来对比一下 4 种方案："}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"方法"}),(0,t.jsx)(e.th,{children:"优点"}),(0,t.jsx)(e.th,{children:"缺点"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"加载中禁止切换"}),(0,t.jsx)(e.td,{children:"使用简单"}),(0,t.jsx)(e.td,{children:"要求接口响应足够快，否则用户体验很糟糕"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"取消请求"}),(0,t.jsx)(e.td,{children:"使用简单，可以更精细地控制请求"}),(0,t.jsx)(e.td,{children:"依赖请求 API，如果是不涉及请求的竞态问题，则无法使用"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"忽略请求（使用标志符）"}),(0,t.jsx)(e.td,{children:"实现简单，不依赖额外的 API"}),(0,t.jsx)(e.td,{children:"适用简单的竞态问题，不适合复杂的竞态问题"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"映射请求"}),(0,t.jsx)(e.td,{children:"可以配合缓存，减少请求次数"}),(0,t.jsx)(e.td,{children:"维护数据变多、程序变得更复杂"})]})]})]}),"\n",(0,t.jsx)(e.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,a.ah)(),n.components);return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(s,n)})):s(n)}let l=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["blog%2F2024%2F11%2F06%2Findex.mdx"]={toc:[{id:"模拟问题",text:"模拟问题",depth:2},{id:"方法一加载中禁止切换",text:"方法一：加载中禁止切换",depth:2},{id:"方法二取消请求",text:"方法二：取消请求",depth:2},{id:"方法三忽略请求使用标志符",text:"方法三：忽略请求（使用标志符）",depth:2},{id:"方法四映射请求",text:"方法四：映射请求",depth:2},{id:"总结",text:"总结",depth:2}],title:"H5 更早发出的请求、更晚被响应，应该怎么办？—— 请求竞态问题",frontmatter:{}}},95895:function(n,e,r){r.d(e,{Z:function(){return c}});var t=r(85893),a=r(67294),d=r(45687);r(6175);let i={"zh-CN":n=>`预计阅读时间: ${n.minutes>=1?`${Math.ceil(n.minutes)} 分钟`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function s(n,e,r){let t=Object.keys(i).includes(e)?e:r;return i[t](n)}let c=n=>{let{defaultLocale:e="en-US"}=n,r=(0,d.Vi)().page.readingTimeData,i=(0,d.Jr)(),c=(0,d.e7)(),[l,h]=(0,a.useState)(s(r,i,e));return(0,a.useEffect)(()=>{h(s(r,i,e))},[i,r]),(0,t.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:l})}}}]);