"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["4769"],{9166:function(e,n,i){i.r(n),i.d(n,{default:()=>p});var r=i("5893"),d=i("65");let s=i.p+"static/image/canvas-cover-imgRatio-le-canvasRatio.100cb603.png",c=i.p+"static/image/canvas-cover-imgRatio-ge-canvasRatio.c9aa5b24.png",a=i.p+"static/image/canvas-cover.53b0b126.png",h=i.p+"static/image/canvas-contain-imgRatio-ge-canvasRatio.dadef591.png",l=i.p+"static/image/canvas-contain-imgRatio-le-canvasRatio.7ce7560c.png",t=i.p+"static/image/canvas-contain.4b1194cf.png",o=i.p+"static/image/product.734cf3c1.png",x=i.p+"static/image/contain-and-cover.ab129568.png",j=i.p+"static/image/pdd.e929526a.jpg";function g(e){let n=Object.assign({h1:"h1",a:"a",p:"p",img:"img",code:"code",h2:"h2",strong:"strong",ul:"ul",li:"li",blockquote:"blockquote",h3:"h3",pre:"pre"},(0,d.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h1,{id:"从拼多多分享商品说起canvas-绘图如何实现-contain-和-cover-效果",children:["从拼多多分享商品说起，canvas 绘图如何实现 contain 和 cover 效果？",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#从拼多多分享商品说起canvas-绘图如何实现-contain-和-cover-效果",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"我们偶尔会在一些 H5、小程序中，看到分享商品的功能。比如拼多多小程序中，用户可以把商品分享给自己的好友。分享图主要由 2 张图片组成，一张商品图，一张背景图。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:j,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"商品图通常由商家自己配置，尺寸会变动，一般是 contain 效果；背景图通常由 UI 提供，尺寸固定，一般是 cover 效果。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:x,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["如果使用 css，我们可以给 ",(0,r.jsx)(n.code,{children:"background-size"})," 设置 ",(0,r.jsx)(n.code,{children:"contain"})," 和 ",(0,r.jsx)(n.code,{children:"cover"}),"，可惜这类分享图基本由 canvas 绘制而成。canvas 只提供了 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage",target:"_blank",rel:"noopener noreferrer",children:"drawImage()"})," 绘制图片，无法精准实现 ",(0,r.jsx)(n.code,{children:"contain"})," 和 ",(0,r.jsx)(n.code,{children:"cover"})," 效果，于是我实现了 ",(0,r.jsx)(n.code,{children:"drawContainImage"})," 和 ",(0,r.jsx)(n.code,{children:"drawCoverImage"})," 两个工具函数。"]}),"\n",(0,r.jsxs)(n.p,{children:["本文我会先分析 contain 效果的",(0,r.jsx)(n.code,{children:"图片宽高比"}),"和",(0,r.jsx)(n.code,{children:"容器宽高比"}),"，并给出 drawContainImage 工具函数；再分析 cover 效果的",(0,r.jsx)(n.code,{children:"图片宽高比"}),"和",(0,r.jsx)(n.code,{children:"容器宽高比"}),"，并给出 drawCoverImage 工具函数；最后我会用两个工具函数，绘制如下分享图："]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:o,alt:""})}),"\n",(0,r.jsx)(n.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,r.jsxs)(n.h2,{id:"contain-效果",children:["contain 效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#contain-效果",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["先来看 contain 效果。contain 效果是「缩放图片以",(0,r.jsx)(n.strong,{children:"完全装入"}),"容器」，它会有两种情况："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"图片宽高比 < 容器宽高比，缩放后图片宽度 < 容器宽度，图片高度 = 容器高度。"}),"\n",(0,r.jsx)(n.li,{children:"图片宽高比 > 容器宽高比，缩放后图片宽度 = 容器宽度，图片高度 < 容器高度。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:t,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["不难看出，contain 效果下，图片总是完整展示的，因此我们不必考虑裁剪图片。",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage",target:"_blank",rel:"noopener noreferrer",children:"drawImage"})," 的 9 个参数中，我们只需要考虑 5 个参数："]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"image"}),"，画布图像源。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dx"}),"，image 的左上角在目标画布上 X 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dy"}),"，image 的左上角在目标画布上 Y 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dw"}),"，image 在目标画布上绘制的宽度。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dh"}),"，image 在目标画布上绘制的高度。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"图片宽高比--容器宽高比",children:["图片宽高比 < 容器宽高比",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片宽高比--容器宽高比",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"图片宽高比 < 容器宽高比时，dy，dw 和 dh 可以直观看出来，而 dx 还需要单独计算。如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:l,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["dx 是 image 的左上角在目标画布上 X 轴坐标，",(0,r.jsx)(n.code,{children:"dx = (width - dw) / 2"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dy 是 image 的左上角在目标画布上 Y 轴坐标，",(0,r.jsx)(n.code,{children:"dy = 0"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dw 是 image 在目标画布上绘制的宽度，",(0,r.jsx)(n.code,{children:"dw = imgRatio * width"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dh 是 image 在目标画布上绘制的高度，",(0,r.jsx)(n.code,{children:"dh = height"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"图片宽高比--容器宽高比",children:["图片宽高比 > 容器宽高比",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片宽高比--容器宽高比",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"图片宽高比 > 容器宽高比时，dx，dw 和 dh 可以直观看出来，而 dy 还需要单独计算。如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:h,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["dx 是 image 的左上角在目标画布上 X 轴坐标，",(0,r.jsx)(n.code,{children:"dx = 0"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dy 是 image 的左上角在目标画布上 Y 轴坐标，",(0,r.jsx)(n.code,{children:"dy = (height - dh) / 2"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dw 是 image 在目标画布上绘制的宽度，",(0,r.jsx)(n.code,{children:"dw = width"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["dh 是 image 在目标画布上绘制的高度，",(0,r.jsx)(n.code,{children:"dh = dw / imgRatio"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"drawcontainimage-代码",children:["drawContainImage 代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#drawcontainimage-代码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"下面是 drawContainImage 的代码，因为 contain 效果一般会留有空白，所以我增加了一个 fillStyle 参数，用来设置空白部分的颜色。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function drawContainImage({\r\n  ctx, img, x, y, width, height, fillStyle\r\n}) {\r\n  if (fillStyle) {\r\n    ctx.fillStyle = fillStyle\r\n    ctx.fillRect(x, y, width, height)\r\n  }\r\n  const boxRatio = width / height\r\n  const imgRatio = img.width / img.height\r\n\r\n  let dx = 0, dy = 0, dw = 0, dh = 0\r\n  if (imgRatio <= boxRatio) {\r\n    dw = imgRatio * width\r\n    dh = height\r\n    dx = (width - dw) / 2\r\n    dy = 0\r\n  } else {\r\n    dw = width\r\n    dh = dw / imgRatio\r\n    dx = 0\r\n    dy = (height - dh) / 2\r\n  }\r\n  ctx.drawImage(img, x + dx, y + dy, dw, dh)\r\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"cover-效果",children:["cover 效果",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#cover-效果",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["再看 cover 效果，cover 效果是「缩放图片以",(0,r.jsx)(n.strong,{children:"完全覆盖"}),"容器」。如下示意图所示，缩放后图片（红色部分）比容器（绿色部分）大。它会有两种情况："]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"图片宽高比 > 容器宽高比，缩放后图片宽度 = 容器宽度，图片高度 > 容器高度。"}),"\n",(0,r.jsx)(n.li,{children:"图片宽高比 < 容器宽高比，缩放后图片宽度 < 容器宽度，图片高度 = 容器高度。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:a,alt:""})}),"\n",(0,r.jsxs)(n.p,{children:["不难看出，contain 效果下，图片总是需要裁剪图片，所以 ",(0,r.jsx)(n.a,{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage",target:"_blank",rel:"noopener noreferrer",children:"drawImage"})," 的 9 个参数我们都需要使用："]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"image"}),"，画布图像源。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sx"}),"，image 的矩形（裁剪）选择框的左上角 X 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sy"}),"，image 的矩形（裁剪）选择框的左上角 Y 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sw"}),"，image 的矩形（裁剪）选择框的宽度。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"sh"}),"，image的矩形（裁剪）选择框的高度。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dx"}),"，image 的左上角在目标画布上 X 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dy"}),"，image 的左上角在目标画布上 Y 轴坐标。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dw"}),"，image 在目标画布上绘制的宽度。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"dh"}),"，image 在目标画布上绘制的高度。"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"幸运的是，contain 效果下，dx, dy, dw 和 dh 的取值都是固定的，所以我们需要着重考虑的只有 sx, sy, sw 和 sh 这 4 个参数。"}),"\n",(0,r.jsxs)(n.h3,{id:"图片宽高比--容器宽高比-1",children:["图片宽高比 > 容器宽高比",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片宽高比--容器宽高比-1",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"图片宽高比 > 容器宽高比时，sy，sw 和 sh 可以直观看出来，而 sx 还需要单独计算。如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:c,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["sx 是 image 裁剪选择框（绿色部分）的左上角 X 轴坐标，",(0,r.jsx)(n.code,{children:"sx = (img.width - sw) / 2"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sy 是 image 裁剪选择框（绿色部分）的左上角 Y 轴坐标，",(0,r.jsx)(n.code,{children:"sy = 0"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sw 是 image 裁剪选择框（绿色部分）的宽度，",(0,r.jsx)(n.code,{children:"sw = sh * boxRatio"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sh 是 image 裁剪选择框（绿色部分）的高度，",(0,r.jsx)(n.code,{children:"sh = img.height"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"图片宽高比--容器宽高比-1",children:["图片宽高比 < 容器宽高比",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#图片宽高比--容器宽高比-1",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"图片宽高比 < 容器宽高比时，sx, sw 和 sh 可以直观看出来，而 sy 还需要单独计算。如下图所示："}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)("img",{src:s,alt:""})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["sx 是 image 裁剪选择框（绿色部分）的左上角 X 轴坐标，",(0,r.jsx)(n.code,{children:"sx = 0"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sy 是 image 裁剪选择框（绿色部分）的左上角 Y 轴坐标，",(0,r.jsx)(n.code,{children:"sy = (img.height - sh) / 2"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sw 是 image 裁剪选择框（绿色部分）的宽度，",(0,r.jsx)(n.code,{children:"sw = img.width"}),"；"]}),"\n",(0,r.jsxs)(n.li,{children:["sh 是 image 裁剪选择框（绿色部分）的高度，",(0,r.jsx)(n.code,{children:"sh = sw / boxRatio"}),"。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h3,{id:"drawcoverimage-代码",children:["drawCoverImage 代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#drawcoverimage-代码",children:"#"})]}),"\n",(0,r.jsx)(n.p,{children:"下面是 drawCoverImage 的代码，因为 cover 效果不会留空白，所以不需要 fillStyle 参数。"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function drawCoverImage({\r\n  ctx, img, x, y, width, height\r\n}) {\r\n  const boxRatio = width / height\r\n  const imgRatio = img.width / img.height\r\n\r\n  let sx = 0, sy = 0, sw = 0, sh = 0\r\n  if (imgRatio <= boxRatio) {\r\n    sw = img.width\r\n    sh = sw / boxRatio\r\n    sx = 0\r\n    sy = (img.height - sh) / 2\r\n  } else {\r\n    sh = img.height\r\n    sw = sh * boxRatio\r\n    sx = (img.width - sw) / 2\r\n    sy = 0\r\n  }\r\n\r\n  ctx.drawImage(img, sx, sy, sw, sh, x, y, width, height)\r\n}\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"完整代码",children:["完整代码",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#完整代码",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["完整代码可以在码上掘金上查看：",(0,r.jsx)(n.a,{href:"https://code.juejin.cn/pen/7388885726391992371",target:"_blank",rel:"noopener noreferrer",children:"https://code.juejin.cn/pen/7388885726391992371"})]}),"\n",(0,r.jsxs)(n.h2,{id:"总结",children:["总结",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#总结",children:"#"})]}),"\n",(0,r.jsxs)(n.p,{children:["本文我分析了 contain 效果、cover 效果的",(0,r.jsx)(n.code,{children:"图片宽高比"}),"和",(0,r.jsx)(n.code,{children:"容器宽高比"}),"关系，并给出 drawContainImage 和 drawCoverImage 工具函数，最后用两个工具函数，绘制了一个商品分享图。"]}),"\n",(0,r.jsx)(n.p,{children:"拳打 H5，脚踢小程序。我是「小霖家的混江龙」，关注我，带你了解更多实用的 H5、小程序武学。"}),"\n",(0,r.jsxs)(n.h2,{id:"参考文章",children:["参考文章",(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#参考文章",children:"#"})]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.cnblogs.com/AIonTheRoad/p/14063041.html",target:"_blank",rel:"noopener noreferrer",children:"canvas drawImage 绘图实现 contain 和 cover 的效果"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://developer.aliyun.com/article/916087",target:"_blank",rel:"noopener noreferrer",children:"在容器内显示图片的五种方案：contain、cover、fill、none、scale-down"})}),"\n"]})]})}function m(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,d.ah)(),e.components);return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(g,{...e})}):g(e)}let p=m;m.__RSPRESS_PAGE_META={},m.__RSPRESS_PAGE_META["blog%2F2024%2F07%2F11%2Findex.md"]={toc:[{text:"contain 效果",id:"contain-效果",depth:2},{text:"图片宽高比 < 容器宽高比",id:"图片宽高比--容器宽高比",depth:3},{text:"图片宽高比 > 容器宽高比",id:"图片宽高比--容器宽高比",depth:3},{text:"drawContainImage 代码",id:"drawcontainimage-代码",depth:3},{text:"cover 效果",id:"cover-效果",depth:2},{text:"图片宽高比 > 容器宽高比",id:"图片宽高比--容器宽高比-1",depth:3},{text:"图片宽高比 < 容器宽高比",id:"图片宽高比--容器宽高比-1",depth:3},{text:"drawCoverImage 代码",id:"drawcoverimage-代码",depth:3},{text:"完整代码",id:"完整代码",depth:2},{text:"总结",id:"总结",depth:2},{text:"参考文章",id:"参考文章",depth:2}],title:"从拼多多分享商品说起，canvas 绘图如何实现 contain 和 cover 效果？",frontmatter:{}}}}]);