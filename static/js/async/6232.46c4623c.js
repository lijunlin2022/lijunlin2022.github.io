"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([["6232"],{6489:function(r,n,e){e.r(n),e.d(n,{default:function(){return a}});var i=e(5893),s=e(65);function t(r){let n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",code:"code",pre:"pre"},(0,s.ah)(),r.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.h1,{id:"错误",children:["错误",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误",children:"#"})]}),"\n",(0,i.jsxs)(n.h2,{id:"错误处理",children:["错误处理",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#错误处理",children:"#"})]}),"\n",(0,i.jsx)(n.p,{children:"一般如果 go 语言的函数可能发生错误，那么它会有两个返回值，第一个返回值是正常返回值，第二个返回值就是错误。"}),"\n",(0,i.jsxs)(n.p,{children:["如果发生错误时，第二个返回值不再时 ",(0,i.jsx)(n.code,{children:"nil"}),"，而是一个错误类型的数据，需要我们加以处理。"]}),"\n",(0,i.jsx)(n.p,{children:"比如打开文件时，文件可能打开失败。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'func main() {\r\n  f, err := os.OpenFile("./song.txt", os.O_WRONLY|os.O_CREATE, 0666)\r\n  if err != nil {\r\n    fmt.Println("文件打开失败")\r\n    return\r\n  }\r\n  defer f.Close()\r\n}\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"自定义错误",children:["自定义错误",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义错误",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["如果编写一个函数，函数内部可能发生错误，你最好让函数的返回值中也包含错误。为此，你需要用到 ",(0,i.jsx)(n.code,{children:"errors.New()"})," 来创建错误。"]}),"\n",(0,i.jsx)(n.p,{children:"比如创建一个除法函数，你需要考虑除数为 0 时发生错误的情况。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'var errDivByZero = errors.New("除数不能为 0")\r\n\r\nfunc div(dividend, divisor int) (int, error) {\r\n  if divisor == 0 {\r\n    return 0, errDivByZero\r\n  }\r\n\r\n  return dividend / divisor, nil\r\n}\r\n\r\nfunc main() {\r\n  res, err := div(1, 0)\r\n  if err != nil {\r\n    fmt.Println(err) // 除数不能为 0\r\n    return\r\n  }\r\n  fmt.Println(res)\r\n}\n'})}),"\n",(0,i.jsxs)(n.h2,{id:"自定义信息更丰富的错误",children:["自定义信息更丰富的错误",(0,i.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#自定义信息更丰富的错误",children:"#"})]}),"\n",(0,i.jsxs)(n.p,{children:["使用 ",(0,i.jsx)(n.code,{children:"errors.New()"})," 创建的字符串信息，无法携带更多信息。但很多时候，为了方便排查报错，你可以自定义结构体实现错误接口。"]}),"\n",(0,i.jsx)(n.p,{children:"比如创建一个解析文件错误，你需要告诉用户出错的文件名和行号。"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'type ParseError struct {\r\n  Filename string\r\n  Line     int\r\n}\r\n\r\nfunc (e *ParseError) Error() string {\r\n  return fmt.Sprintf("%s:%d", e.Filename, e.Line)\r\n}\r\n\r\nfunc newParserError(filename string, line int) error {\r\n  return &ParseError{filename, line}\r\n}\r\n\r\nfunc main() {\r\n  e := newParserError("song.txt", 1)\r\n\r\n  // 通过 error 接口查看错误描述\r\n  fmt.Println(e.Error())\r\n\r\n  // 根据接口具体的类型，获取详细错误信息\r\n\r\n  switch detail := e.(type) {\r\n  case *ParseError:\r\n    fmt.Printf("Filename: %s Line: %d\\n", detail.Filename, detail.Line)\r\n  default:\r\n    fmt.Println("other error")\r\n  }\r\n}\n'})})]})}function d(){let r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),r.components);return n?(0,i.jsx)(n,{...r,children:(0,i.jsx)(t,{...r})}):t(r)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["docs%2Fgo%2F12-error.md"]={toc:[{text:"错误处理",id:"错误处理",depth:2},{text:"自定义错误",id:"自定义错误",depth:2},{text:"自定义信息更丰富的错误",id:"自定义信息更丰富的错误",depth:2}],title:"错误",frontmatter:{}}}}]);